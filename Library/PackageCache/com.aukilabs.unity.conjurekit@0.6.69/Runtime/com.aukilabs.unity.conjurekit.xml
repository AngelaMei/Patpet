<?xml version="1.0" encoding="utf-8"?>
<doc>
    <assembly>
        <name>com.aukilabs.unity.conjurekit</name>
    </assembly>
    <members>
        <member name="T:Auki.ConjureKit.AukiCredentials">
            <summary>
            Stores credentials used by ConjureKit.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.AukiCredentials.AppKey">
            <summary>
            Application key.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.AukiCredentials.AppSecret">
            <summary>
            Application secret.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.AukiCredentials.#ctor(System.String,System.String)">
            <summary>
            Constructs AukiCredentials with key+secret
            </summary>
            <param name="appKey">App key</param>
            <param name="appSecret">App secret</param>
        </member>
        <member name="T:Auki.ConjureKit.State">
            <summary>
            Represents ConjureKit state.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.State.Connecting">
            <summary>
            Connecting to a Session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.State.JoinedSession">
            <summary>
            Joined a Session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.State.Calibrated">
            <summary>
            Calibrated in a Session. 
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.State.Disconnected">
            <summary>
            Disconnected.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.State.Initializing">
            <summary>
            Disconnected.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.ConjureKit">
            <summary>
            ConjureKit main module - provides basic networking and can be used in combination with other modules to provide more functionality.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetCredentials">
            <summary>
            Gets the current credentials.
            </summary>
            <returns>AukiCredentials struct</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetNetworkQuality">
            <summary>
            Returns the current NetworkQuality object.
            </summary>
            <returns>NetworkQuality object</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetConfiguration">
            <summary>
            Gets the current configuration.
            </summary>
            <returns>ConjureKitConfiguration struct</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetCameraTransform">
            <summary>
            Gets the camera transform.
            </summary>
            <returns>Transform</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetState">
            <summary>
            Gets current ConjureKit State.
            </summary>
            <returns>ConjureKit State</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnInit">
            <summary>
            Called after successful initialization or re-initialization
            of ConjureKit and its modules. The argument passed to OnInit
            is the configuration for which initialization took place.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnParticipantJoined">
            <summary>
            Called when a new Participant joins the Session.
            </summary>
            <returns>Joining Participant object</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnParticipantLeft">
            <summary>
            Called when a Participant left the Session.
            </summary>
            <returns>Id of Participant that left</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnEntityAdded">
            <summary>
            Called when an Entity is added to the Session.
            <para>
            Note: This event is triggered only for entities created by other participants in the session.
            </para>
            </summary>
            <returns>Added Entity object</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnEntityAddedResponse">
            <summary>
            Called when an Entity add request was successful.
            </summary>
            <returns>Added Entity object</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnEntityDeleted">
            <summary>
            Called when an Entity was deleted from the Session.
            <para>
            Note: This event is triggered only for entities deleted by other participants in the session.
            </para>
            </summary>
            <returns>Id of deleted Entity</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnComponentUpdate">
            <summary>
            Low-level ECS callback method that is called when a component update is broadcast from a Session.
            Might later be replaced by Systems.
            </summary>
            <returns>ComponentUpdateBroadcast</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnComponentAdd">
            <summary>
            Low-level ECS callback method that is called when a component is added to an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
            <returns>ComponentAddBroadcast</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnComponentDelete">
            <summary>
            Low-level ECS callback method that is called when a component is deleted from an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
            <returns>ComponentDeleteBroadcast</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnEntityDeletedResponse">
            <summary>
            Called when an Entity delete request was successful.
            </summary>
            <returns>Id of deleted Entity</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnJoined">
            <summary>
            Called when a Session was joined.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnParticipantEntityCreated">
            <summary>
            Called after calibration or immediately after joining a Session if this Participant is its host. 
            </summary>
            <returns>Participant Entity object</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnLeft">
            <summary>
            Called when a Session was left. The argument is an inert copy of the old Session object as it stood before leaving.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnStateChanged">
            <summary>
            Called when the ConjureKit state has changed.
            </summary>
            <returns>New ConjureKit state</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnEntityUpdatePose">
            <summary>
            Called when an Entity%'s Pose has been updated.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnCustomMessageBroadcast">
            <summary>
            Called when a custom message broadcast has been received.
            </summary>
            <returns>CustomMessageBroadcast object</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnApplicationBackground">
            <summary>
            Called when the application was sent to the background.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKit.OnApplicationForeground">
            <summary>
            Called when the application was sent to the foreground.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetConjureKitBridge">
            <summary>
            Gets an object with common Unity callbacks. 
            </summary>
            <returns>AukiUnityBridge object</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetSession">
            <summary>
            Gets currently joined Session object.
            </summary>
            <returns>Session object or `null` when not in a Session</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.RegisterModule(Auki.ConjureKit.IConjureKitModule)">
            <summary>
            **(Internal)** Registers IAukiModule-conforming objects so they get updated and receive messages.
            </summary>
            <param name="module">Module to be registered</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetNowAsProtobufTimestamp">
            <summary>
            Standard way of getting the current time.
            </summary>
            <returns>Current time</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetNowMilliseconds">
            <summary>
            Gets current time in milliseconds.
            </summary>
            <returns>Current time in milliseconds</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.#ctor(UnityEngine.Transform,System.String,System.String,Auki.Util.AukiDebug.LogLevel)">
            <summary>
            Constructs a ConjureKit instance
            </summary>
            <param name="mainCamera">Main Scene camera</param>
            <param name="appKey">App key</param>
            <param name="appSecret">App secret</param>
            <param name="logLevel">Preferred log level</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.IsInitialized(System.String,System.String@)">
            <summary>
            Determines if ConjureKit and all of its modules are initialized
            for a specific given configuration URI.
            Returns also a reason for not being initialized.
            </summary>
            <param name="configUri">URI for configuration.</param>
            <param name="reason">Reason for not being initialized.</param>
            <returns>`true` if they are initialized, `false` if not.</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.IsInitialized(System.String@)">
            <summary>
            Determines if ConjureKit and all of its modules are initialized
            for the configuration currently being available or used.
            Returns also a reason for not being initialized.
            </summary>
            <param name="reason">Reason for not being initialized.</param>
            <returns>`true` if they are initialized, `false` if not.</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.IsInitialized(System.String)">
            <summary>
            Determines if ConjureKit and all of its modules are initialized
            for the configuration currently being available or used.
            Returns also a reason for not being initialized.
            </summary>
            <param name="configUri">Reason for not being initialized.</param>
            <returns>`true` if they are initialized, `false` if not.</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.Init(System.String,System.Action,System.Action{System.String})">
            <summary>
            Optional manual initialization ConjureKit and its modules for a non-default configUrl.
            Note that one must be in a Disconnected or Initializing state to call this function.
            </summary>
            <param name="configUri">Url of the configuration file (json)</param>
            <param name="onComplete">Callback on success</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.Init(Auki.ConjureKit.ConjureKitConfiguration,System.Action,System.Action{System.String})">
            <summary>
            Optional manual initialization of ConjureKit and its modules for a given ConjureKitConfiguration
            object. One must be in a Disconnected or Initializing state to call this function.
            </summary>
            <param name="configuration">ConjureKitConfiguration instance</param>
            <param name="onComplete">Callback on success</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.Connect(System.Action{Auki.ConjureKit.Session},System.Action{System.String})">
            <summary>
            Call when you want to connect to the Aukiverse with the default or current ConjureKitConfiguration.
            The `onComplete` callback is invoked with the same argument as ConjureKit.OnJoined,
            prior to ConjureKit.OnJoined.
            </summary> 
            <param name="onComplete">Callback on success (invoked before ConjureKit.OnJoined)</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.Connect(System.String,System.Action{Auki.ConjureKit.Session},System.Action{System.String})">
            <summary>
            Call when you want to connect to the Aukiverse to a specific session with the default or 
            current ConjureKitConfiguration.
            The `session` argument can also be set to the empty string in which case a new session will be created.
            </summary>
            <param name="sessionId">Desired Session id (can be left blank)</param>
            <param name="onComplete">Callback on success (invoked before ConjureKit.OnJoined)</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.Connect(System.String,System.String,System.Action{Auki.ConjureKit.Session},System.Action{System.String})">
            <summary>
            Call when you want to connect to the Aukiverse to a specific session with a custom
            ConjureKitConfiguration URI.
            The initialization process related to the configUri is idempotent, and will not
            result in re-initialization if the same URI is provided twice.
            </summary>
            <param name="sessionId">Desired Session id (can be left blank)</param>
            <param name="configUri">Custom configUri</param>
            <param name="onComplete">Callback on success (invoked before ConjureKit.OnJoined)</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.Connect(System.String,Auki.ConjureKit.ConjureKitConfiguration,System.Action{Auki.ConjureKit.Session},System.Action{System.String})">
            <summary>
            Call when you want to connect to the Aukiverse to a specific session with a custom
            ConjureKitConfiguration struct.
            The initialization process related to the configUri is idempotent, and will not
            result in re-initialization if the same struct is provided twice.
            </summary>
            <param name="sessionId">Desired Session id (can be left blank)</param>
            <param name="configuration">Custom ConjureKitConfiguration struct</param>
            <param name="onComplete">Callback on success (invoked before ConjureKit.OnJoined)</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.ConnectionErrorMessageIsInternetConnectivityIssue(System.String)">
            <summary>
            Tells whether a string returned by the onError callback of ConjureKit.Connect()
            denotes an internet connectivity issue.
            </summary>
            <param name="message">The argument passed to the ConjureKit onError callback</param>
            <returns>bool</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.NotifyARCameraCalibrated">
            <summary>
            Notify Auki that Session calibration has been achieved.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.Disconnect">
            <summary>
            Call to disconnect from a session.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.SetHagallFeatureConfiguration(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Sets lists of required Hagall modules and feature flags.
            </summary>
            <param name="modules">List of required Hagall modules, default is `null` for none</param>
            <param name="featureFlags">List of required Hagall feature flags, default is `null` for none</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.SetHagallMinVersion(System.String)">
            <summary>
            Sets application-side request for minimum Hagall version.
            </summary>
            <param name="version">Hagall version number in format vMajor[.Minor][.Patch] (e.g., "v4.5")</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.AddComponentType(System.String,System.Action{System.UInt32},System.Action{System.String})">
            <summary>
            Low-level ECS method to add a component type to the Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetComponentTypeId(System.String,System.Action{System.UInt32},System.Action{System.String})">
            <summary>
            Low-level ECS method to get the id of a component type by name from a Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetComponentTypeName(System.UInt32,System.Action{System.String},System.Action{System.String})">
            <summary>
            Low-level ECS method to get the name of a component type by id from a Hagall Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.AddComponent(System.UInt32,System.UInt32,System.Byte[],System.Action,System.Action{System.String})">
            <summary>
            Low-level ECS method to add a component to an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.DeleteComponent(System.UInt32,System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Low-level ECS method to delete a component from an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetComponents(System.UInt32,System.Action{System.Collections.Generic.List{Auki.ConjureKit.EntityComponent}},System.Action{System.String})">
            <summary>
            Low-level ECS method to get all components of a component type in a Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.UpdateComponent(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Low-level ECS method to update a component on an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
            <returns>bool indicating success or failure of putting update message on send queue</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.SubscribeToComponentType(System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Low-level ECS method to subscribe to updates of a component type
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.UnsubscribeToComponentType(System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Low-level ECS method to unsubscribe to updates of a component type
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.GetNewRequestId">
            <summary>
            **(Internal)** Returns a new request id.
            </summary>
            <returns>New request id</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.Request(System.UInt32,Auki.ConjureKit.Hagall.Protobuf.Gen.MsgType,System.Byte[],System.Action{System.Byte[]},System.Action{System.String})">
            <summary>
            **(Internal)** Sends a request to the server.
            </summary>
            <param name="requestId">Request id</param>
            <param name="msgType">Request MsgType</param>
            <param name="request">Byte array-encoded request</param>
            <param name="onResponse">Callback on success</param>
            <param name="onError">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.Request(System.UInt32,System.Byte[],System.Action{System.Byte[]},System.Action{System.String})">
            <summary>
            **(Internal)** Sends a request to the server. Deprecated version without the message type.
            </summary>
            <param name="requestId">Request id</param>
            <param name="request">Byte array-encoded request</param>
            <param name="onResponse">Callback on success</param>
            <param name="onError">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit._SendBytes(System.Byte[])">
            <summary>
            **(Internal)** Sends a message directly to Hagall.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.SendCustomMessage(System.UInt32[],System.Byte[])">
            <summary>
            Sends a custom message to other Participant%s.
            </summary>
            <param name="participantIds">An array of Participant Ids</param>
            <param name="data">An array of custom data</param>
            <returns>Success or failure</returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKit.MeasurePing(System.Action{System.Double},System.Action{System.String})">
            <summary>
            Perform a millisecond ping measurement of the current session. The measurement
            is aggregated to ConjureKit's NetworkQuality object, accessible via ConjureKit.GetNetworkQuality().
            </summary>
            <param name="onComplete">Callback on success, invoked with millisecond amount</param>
            <param name="onError">Callback on failure</param>
        </member>
        <member name="T:Auki.ConjureKit.ConjureKitBridge">
            <summary>
            A MonoBehaviour that provides callbacks for common Unity event functions.
            </summary>
        </member>
        <member name="E:Auki.ConjureKit.ConjureKitBridge.UpdateCallback">
            <summary>
            Callback from Unity's Update() method. (Do not remove event modifier.)
            </summary>
        </member>
        <member name="E:Auki.ConjureKit.ConjureKitBridge.GUICallback">
            <summary>
            Callback from Unity's OnGUI() method. (Do not remove event modifier.)
            </summary>
        </member>
        <member name="E:Auki.ConjureKit.ConjureKitBridge.ApplicationPauseCallback">
            <summary>
            Callback from Unity's OnApplicationPause() method.
            </summary>
        </member>
        <member name="E:Auki.ConjureKit.ConjureKitBridge.DestroyCallback">
            <summary>
            Callback from Unity's OnDestroy() method for this MonoBehaviour object.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.ConjureKitConfiguration">
            <summary>
            A class that retrieves and stores ConjureKit configuration data used by
            ConjureKit.Init().
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.DefaultConfigUri">
            <summary>
            Default ConjureKit configuration URL.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.ConfigUri">
            <summary>
            URI used to created the config, if any.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.HdsUri">
            <summary>
            Hagall discovery service URI.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.HagallMinVersion">
            <summary>
            Hagall server minimum version.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.EventUri">
            <summary>
            Event logging service URI.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.ApiUri">
            <summary>
            API URI.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.CatalogUri">
            <summary>
            Asset catalog URI.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.ParticipantAssetId">
            <summary>
            Participant asset id.
            </summary>
            <remarks>
            Used by Odal. This asset will be instantiated for every Participant and will be attached to their Pose.
            </remarks>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.MetricUri">
            <summary>
            Metric reporting URI..
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.DeviceOffsets">
            <summary>
            Contains the offsets of the physical camera position from the device display, for each supported device.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.PmsUri">
            <summary>
            The URI for Posemesh metrics service.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.PingInterval">
            <summary>
            Ping interval for PMS.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.PmsFirstReportInterval">
            <summary>
            Time until first report for PMS is sent after connecting.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.PmsNextReportInterval">
            <summary>
            Time until successive (after first) reports for PMS are sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.PmsMessageTypes">
            <summary>
            Hagall message types that will also be used to track latency.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration">
            <summary>
            Represents the configuration for ConjureKit, a structured data containing various URIs and settings.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.hds_uri">
            <summary>
            The URI for HDS (Hagall Discovery Service).
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.hagall_min_version">
            <summary>
            The minimum required version of the Hagall server to be used.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.event_uri">
            <summary>
            The URI for event-related functionality.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.api_uri">
            <summary>
            The URI for the ConjureKit API.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.catalog_uri">
            <summary>
            The URI for the catalog.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.unity_participant_asset_id">
            <summary>
            The asset ID for Unity participant assets.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.metric_uri">
            <summary>
            The URI for metrics-related functionality.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.device_offsets">
            <summary>
            A dictionary of device offsets, with keys as strings and values as float arrays.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.pms_uri">
            <summary>
            The URI for Posemesh metrics service.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.ping_interval">
            <summary>
            Ping interval for PMS.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.pms_first_report_interval">
            <summary>
            Time until first report for PMS is sent after connecting.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.pms_next_report_interval">
            <summary>
            Time until successive (after first) reports for PMS are sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitConfiguration.conjurekit_configuration.pms_message_types">
            <summary>
            Hagall message types that will also be used to track latency.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitConfiguration.op_Equality(Auki.ConjureKit.ConjureKitConfiguration,Auki.ConjureKit.ConjureKitConfiguration)">
            <summary>
            Equality operator between two ConjureKitConfiguration objects
            </summary>
            <param name="c1">configuration 1</param>
            <param name="c2">configuration 2</param>
            <returns></returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitConfiguration.op_Inequality(Auki.ConjureKit.ConjureKitConfiguration,Auki.ConjureKit.ConjureKitConfiguration)">
            <summary>
            Inequality operator between two ConjureKitConfiguration objects
            </summary>
            <param name="c1">configuration 1</param>
            <param name="c2">configuration 2</param>
            <returns></returns>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitConfiguration.TryGet(System.Action{Auki.ConjureKit.ConjureKitConfiguration},System.Action{System.String})">
            <summary>
            Asynchronous download of a configuration file from the default ConjureKit hardcoded URL
            (a.k.a., ConjureKitConfiguration.DefaultConfigUri), and manufacture of a ConjureKitConfiguration
            object from the downloaded JSON.
            </summary>
            <param name="onComplete">Callback on success</param>
            <param name="onFailed">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitConfiguration.TryGet(System.String,System.Action{Auki.ConjureKit.ConjureKitConfiguration},System.Action{System.String})">
            <summary>
            Asynchronous download of a configuration file from a specified URL and manufacture of a 
            ConjureKitConfiguration object from the downloaded JSON.
            </summary>
            <param name="configUri">Endpoint for the HTTP.GET request</param>
            <param name="onComplete">Callback on success</param>
            <param name="onFailed">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitConfiguration.Get(System.String)">
            <summary>
            Synchronous ConjureKit configuration download. (Deprecated.)
            </summary>
            <param name="configUri">URI of configuration file</param>
            <returns>ConjureKitConfiguration struct</returns>
        </member>
        <member name="T:Auki.ConjureKit.IConjureKitModule">
            <summary>
            Generic interface for a ConjureKit module
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKitModule._GetMessageTypeRange">
            <summary>
            **(Internal)** Returns the message type range expected by the module. Invoked by the IConjureKit-implementing object the module was constructed with.
            </summary>
            <returns>Message type range tuple</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKitModule._HandleMessage(System.UInt32,System.Byte[])">
            <summary>
            **(Internal)** Handles a message. Invoked by the IConjureKit-implementing object the module was constructed with.
            </summary>
            <param name="messageType">Message type</param>
            <param name="data">Byte array-encoded data</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKitModule._Update">
            <summary>
            **(Internal)** Game loop per-frame update. Invoked by the IConjureKit-implementing object the module was constructed with.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKitModule._Init(System.Action,System.Action{System.String})">
            <summary>
            **(Internal)** Called by ConjureKit.Init() for post-constructor online initializations.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKitModule._Name">
            <summary>
            **(Internal)** Used to identify modules and to prevent duplicate registration of modules, in particular.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKitModule.OnInit">
            <summary>
            Called after successful initialization or re-initialization
            of the module. The argument passed to OnInit is the configuration for 
            which initialization took place.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.ConjureKitModule">
            <summary>
            Base class for ConjureKit modules.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitModule._conjureKit">
            <summary>
            **(Internal)** IConjureKit-implementing object that manages the module.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ConjureKitModule.NoMessageRange">
            <summary>
            **(Internal)** Default range for no messages expected by the module.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitModule._GetMessageTypeRange">
            <summary>
            **(Internal)** Returns the message type range expected by the module.
            </summary>
            <returns>Message type range tuple</returns>
        </member>
        <member name="P:Auki.ConjureKit.ConjureKitModule.OnInit">
            <summary>
            Called after successful initialization or re-initialization
            of the module. The argument passed to OnInit is the configuration for 
            which initialization took place.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitModule._HandleMessage(System.UInt32,System.Byte[])">
            <summary>
            **(Internal)** Handles a message.
            </summary>
            <param name="messageType">Message type</param>
            <param name="data">Byte array-encoded data</param>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitModule._Update">
            <summary>
            **(Internal)** Game loop per-frame update.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitModule._Init(System.Action,System.Action{System.String})">
            <summary>
            **(Internal)** Called by ConjureKit.Init() for post-constructor online initializations.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitModule._InvokeOnInit(Auki.ConjureKit.ConjureKitConfiguration)">
            <summary>
            **(Internal)** Called by ConjureKit.Init() for post-constructor online initializations.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitModule._Name">
            <summary>
            **(Internal)** Used to identify modules and to prevent duplicate registration of modules, in particular.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ConjureKitModule.#ctor(Auki.ConjureKit.IConjureKit)">
            <summary>
            Base constructor for AukiModule%s.
            </summary>
            <param name="conjureKit">IConjureKit-implementing object</param>
            <exception cref="T:System.Exception">Throws an exception if the IConjureKit-implementing object is null</exception>
        </member>
        <member name="T:Auki.ConjureKit.ECS.IPoseSystem">
            <summary>
            Represents a system for managing entity poses.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ECS.IPoseSystem.AddEntityPose(System.UInt32,UnityEngine.Pose,System.Action,System.Action{System.String})">
            <summary>
            Adds a Pose to an existing entity. This will attach a new component of `auki.pose` to the given entity.
            </summary>
            <param name="entityId">The ID of the entity to which the Pose will be added.</param>
            <param name="pose">The Pose to add to the entity.</param>
            <param name="onComplete">An action to execute upon successful completion.</param>
            <param name="onError">An action to execute if an error occurs during the operation.</param>
        </member>
        <member name="M:Auki.ConjureKit.ECS.IPoseSystem.UpdateEntityPose(System.UInt32,UnityEngine.Pose)">
            <summary>
            Tries to update the Pose of an existing entity.
            </summary>
            <param name="entityId">The ID of the entity to update the Pose for.</param>
            <param name="pose">The new Pose to set for the entity.</param>
            <returns>False if the entity does not exist or if the entity does not have an `auki.pose` component attached.</returns>
        </member>
        <member name="M:Auki.ConjureKit.ECS.IPoseSystem.GetEntityPose(System.UInt32)">
            <summary>
            Queries the Pose of a specific entity.
            </summary>
            <param name="entityId">The ID of the entity for which to retrieve the Pose.</param>
            <returns>The entity's Pose if the entity has an `auki.pose` component attached; otherwise, returns a default Pose.</returns>
        </member>
        <member name="M:Auki.ConjureKit.ECS.IPoseSystem.GetEntityPose(Auki.ConjureKit.Entity)">
            <summary>
            Queries the Pose of a specific entity.
            </summary>
            <param name="entity">The entity for which to retrieve the Pose.</param>
            <returns>The entity's Pose if the entity has an `auki.pose` component attached; otherwise, returns a default Pose.</returns>
        </member>
        <member name="E:Auki.ConjureKit.ECS.IPoseSystem.OnEntityUpdatePose">
            <summary>
            Event triggered when an entity's Pose is updated.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.ECS.ISystem">
            <summary>
            Definition for Systems interface.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ECS.ISystem.GetComponentTypeNames">
            <summary>
            Will be invoked by ConjureKit and has to return an array of all component type names that the System will use.
            </summary>
            <returns>Array of component type names</returns>
        </member>
        <member name="M:Auki.ConjureKit.ECS.ISystem.Update(System.Collections.Generic.IReadOnlyList{System.ValueTuple{Auki.ConjureKit.EntityComponent,System.Boolean}})">
            <summary>
            Invoked by ConjureKit when EntityComponent%s are altered.
            </summary>
            <param name="updated">List of pairs of the form (EntityComponent, bool) in chronological order of updated EntityComponent%s since the last invocation of the same function, possibly containing the same Component on the same Entity several times. The boolean indicates whether the change to the EntityComponent was effected by the local participant (true) or by a remote participant (false).</param>
        </member>
        <member name="M:Auki.ConjureKit.ECS.ISystem.Delete(System.Collections.Generic.IReadOnlyList{System.ValueTuple{Auki.ConjureKit.EntityComponent,System.Boolean}})">
            <summary>
            Invoked by ConjureKit when EntityComponent are removed.
            </summary>
            <param name="deleted">List of pairs of the form (EntityComponent, bool) in chronological order of deleted EntityComponent%s. The boolean indicates whether the deletion was performed by the local participant (true) or by a remote participant (false).</param>
        </member>
        <member name="T:Auki.ConjureKit.ECS.PoseSystem">
            <summary>
            Base class for ConjureKit Systems. Methods are going to be called by ConjureKit.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ECS.PoseSystem.AUKI_SYSTEM_POSE_COMPONENT_NAME">
            <summary>
            Component type used by PoseSystem
            </summary>
        </member>
        <member name="E:Auki.ConjureKit.ECS.PoseSystem.OnEntityUpdatePose">
            <summary>
            Event triggered when an entity's Pose is updated.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ECS.PoseSystem.SetParticipantPoseUpdatesPerSecond(System.Int32)">
            <summary>
            Sets the amount of times the participant's pose should be updated per second.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ECS.PoseSystem.GetParticipantPoseUpdatesPerSecond">
            <summary>
            </summary>
            <returns> The amount of times the participant's pose updates per second.</returns>
        </member>
        <member name="M:Auki.ConjureKit.ECS.PoseSystem.AddEntityPose(System.UInt32,UnityEngine.Pose,System.Action,System.Action{System.String})">
            <summary>
            Adds a Pose to an existing entity. This will attach a new component of `auki.pose` to the given entity.
            </summary>
            <param name="entityId">The ID of the entity to which the Pose will be added.</param>
            <param name="pose">The Pose to add to the entity.</param>
            <param name="onComplete">An action to execute upon successful completion.</param>
            <param name="onError">An action to execute if an error occurs during the operation.</param>
        </member>
        <member name="M:Auki.ConjureKit.ECS.PoseSystem.UpdateEntityPose(System.UInt32,UnityEngine.Pose)">
            <summary>
            Tries to update the Pose of an existing entity.
            </summary>
            <param name="entityId">The ID of the entity to update the Pose for.</param>
            <param name="pose">The new Pose to set for the entity.</param>
            <returns>False if the entity does not exist or if the entity does not have an `auki.pose` component attached.</returns>
        </member>
        <member name="M:Auki.ConjureKit.ECS.PoseSystem.GetEntityPose(System.UInt32)">
            <summary>
            Queries the Pose of a specific entity.
            </summary>
            <param name="entityId">The ID of the entity for which to retrieve the Pose.</param>
            <returns>The entity's Pose if the entity has an `auki.pose` component attached; otherwise, returns a default Pose.</returns>
        </member>
        <member name="M:Auki.ConjureKit.ECS.PoseSystem.GetEntityPose(Auki.ConjureKit.Entity)">
            <summary>
            Queries the Pose of a specific entity.
            <returns> the entity Pose, ff entity has an `auki.pose` component attached.</returns>
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ECS.PoseSystem.GetComponentTypeNames">
            <summary>
            Will be invoked by ConjureKit and has to return an array of all component type names that the System will use.
            </summary>
            <returns>Array of component type names</returns>
        </member>
        <member name="M:Auki.ConjureKit.ECS.PoseSystem.Update(System.Collections.Generic.IReadOnlyList{System.ValueTuple{Auki.ConjureKit.EntityComponent,System.Boolean}})">
            <summary>
            Invoked by ConjureKit when EntityComponent%s are altered.
            </summary>
            <param name="updated">List of pairs of the form (EntityComponent, bool) in chronological order of updated EntityComponent%s since the last invocation of the same function, possibly containing the same Component on the same Entity several times. The boolean indicates whether the change to the EntityComponent was effected by the local participant (true) or by a remote participant (false).</param>
        </member>
        <member name="M:Auki.ConjureKit.ECS.PoseSystem.Delete(System.Collections.Generic.IReadOnlyList{System.ValueTuple{Auki.ConjureKit.EntityComponent,System.Boolean}})">
            <summary>
            Invoked by ConjureKit when EntityComponent are removed.
            </summary>
            <param name="deleted">List of pairs of the form (EntityComponent, bool) in chronological order of deleted EntityComponent%s. The boolean indicates whether the deletion was performed by the local participant (true) or by a remote participant (false).</param>
        </member>
        <member name="T:Auki.ConjureKit.ECS.SystemBase">
            <summary>
            Base class for ConjureKit Systems. Methods are going to be called by ConjureKit.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.ECS.SystemBase._session">
            <summary>
            Session instance used by the system.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.ECS.SystemBase.#ctor(Auki.ConjureKit.Session)">
            <summary>
            System constructor with session instance
            </summary>
            <param name="session">The session instance</param>
        </member>
        <member name="M:Auki.ConjureKit.ECS.SystemBase.GetComponentTypeNames">
            <summary>
            Will be invoked by ConjureKit and has to return an array of all component type names that the System will use.
            </summary>
            <returns>Array of component type names</returns>
        </member>
        <member name="M:Auki.ConjureKit.ECS.SystemBase.Update(System.Collections.Generic.IReadOnlyList{System.ValueTuple{Auki.ConjureKit.EntityComponent,System.Boolean}})">
            <summary>
            Invoked by ConjureKit when EntityComponent%s are altered.
            </summary>
            <param name="updated">List of pairs of the form (EntityComponent, bool) in chronological order of updated EntityComponent%s since the last invocation of the same function, possibly containing the same Component on the same Entity several times. The boolean indicates whether the change to the EntityComponent was effected by the local participant (true) or by a remote participant (false).</param>
        </member>
        <member name="M:Auki.ConjureKit.ECS.SystemBase.Delete(System.Collections.Generic.IReadOnlyList{System.ValueTuple{Auki.ConjureKit.EntityComponent,System.Boolean}})">
            <summary>
            Invoked by ConjureKit when EntityComponent are removed.
            </summary>
            <param name="deleted">List of pairs of the form (EntityComponent, bool) in chronological order of deleted EntityComponent%s. The boolean indicates whether the deletion was performed by the local participant (true) or by a remote participant (false).</param>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Messages.CustomMessageBroadcast">
            <summary>
            Defines a custom broadcast message to all participants in a session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.CustomMessageBroadcast.ParticipantId">
            <summary>
            Message sender Participant id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.CustomMessageBroadcast.Body">
            <summary>
            Message data in byte encoded array format.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.CustomMessageBroadcast.Timestamp">
            <summary>
            Timestamp of the message creation.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.CustomMessageBroadcast.OriginTimestamp">
            <summary>
            Timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.Hagall.Messages.CustomMessageBroadcast.#ctor(System.UInt32,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Constructor to initialize a new message.
            </summary>
            <param name="participantId">ParticipantId creating the message</param>
            <param name="body">Payload of the message</param>
            <param name="timestamp">Timestamp of the message creation</param>
            <param name="originTimestamp">Timestamp of the request that triggered the broadcast</param>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Messages.ComponentUpdateBroadcast">
            <summary>
            Represents a ComponentUpdateBroadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.ComponentUpdateBroadcast.Timestamp">
            <summary>
            Timestamp of the message creation.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.ComponentUpdateBroadcast.OriginTimestamp">
            <summary>
            Timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.ComponentUpdateBroadcast.EntityComponent">
            <summary>
            EntityComponent object that got updated.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.Hagall.Messages.ComponentUpdateBroadcast.#ctor(Auki.ConjureKit.EntityComponent,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the ComponentUpdateBroadcast class.
            </summary>
            <param name="entityComponent">The EntityComponent object that got updated.</param>
            <param name="timestamp">Timestamp of the message creation.</param>
            <param name="originTimestamp">Timestamp of the request that triggered the broadcast.</param>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Messages.ComponentAddBroadcast">
            <summary>
            Represents a ComponentAddBroadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.ComponentAddBroadcast.Timestamp">
            <summary>
            Timestamp of the message creation.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.ComponentAddBroadcast.OriginTimestamp">
            <summary>
            Timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.ComponentAddBroadcast.EntityComponent">
            <summary>
            EntityComponent object that got added.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.Hagall.Messages.ComponentAddBroadcast.#ctor(Auki.ConjureKit.EntityComponent,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the ComponentAddBroadcast class.
            </summary>
            <param name="entityComponent">The EntityComponent object that got added.</param>
            <param name="timestamp">Timestamp of the message creation.</param>
            <param name="originTimestamp">Timestamp of the request that triggered the broadcast.</param>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Messages.ComponentDeleteBroadcast">
            <summary>
            Represents a ComponentDeleteBroadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.ComponentDeleteBroadcast.Timestamp">
            <summary>
            Timestamp of the message creation.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.ComponentDeleteBroadcast.OriginTimestamp">
            <summary>
            Timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Messages.ComponentDeleteBroadcast.EntityComponent">
            <summary>
            EntityComponent object that got deleted.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.Hagall.Messages.ComponentDeleteBroadcast.#ctor(Auki.ConjureKit.EntityComponent,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the ComponentDeleteBroadcast class.
            </summary>
            <param name="entityComponent">The EntityComponent object that got deleted.</param>
            <param name="timestamp">Timestamp of the message creation.</param>
            <param name="originTimestamp">Timestamp of the request that triggered the broadcast.</param>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.HagallReflection">
            <summary>Holder for reflection information generated from hagall.proto</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.HagallReflection.Descriptor">
            <summary>File descriptor for hagall.proto</summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityFlag">
             <summary>
             EntityFlag represents a flag that gives context to an entity.
            
             Note: this is currently only used to be able to tell what entity represents
             a participant, used for toggling rendering of participant entities assets.
             </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.MsgType">
             <summary>
             MsgType represents the type of message passed between Hagall and a client.
            
             Note that enum values are prefixed because protobuf enum values use C++
             scoping rules, meaning that enum values are siblings of their type, not
             children of it. Therefore, enum values must be unique within "hagall_proto",
             not just within "MsgType".
             </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorCode">
             <summary>
             Error represents a request status code given with Hagall responses.
            
             Note that enum values are prefixed because protobuf enum values use C++
             scoping rules, meaning that enum values are siblings of their type, not
             children of it. Therefore, enum values must be unique within "hagall_proto",
             not just within "ErrorCode".
             </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorCode.Unknown">
            <summary>
            copy paste the resason why use prefix.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.Participant">
            <summary>
            Participant represents a Hagall client connected from a WebSocket.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Participant.IdFieldNumber">
            <summary>Field number for the "id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Participant.Id">
            <summary>
            The participant id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity">
            <summary>
            An entity that have a pose in a session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity.IdFieldNumber">
            <summary>Field number for the "id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity.Id">
            <summary>
            The entity id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity.ParticipantIdFieldNumber">
            <summary>Field number for the "participant_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity.ParticipantId">
            <summary>
            The id of the participant who owns the entity.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity.PoseFieldNumber">
            <summary>Field number for the "pose" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity.Pose">
            <summary>
            The pose in the current session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity.FlagFieldNumber">
            <summary>Field number for the "flag" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity.Flag">
            <summary>
            The entity flag.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.Pose">
            <summary>
            Pose represents a position within a session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Pose.PxFieldNumber">
            <summary>Field number for the "px" field.</summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Pose.PyFieldNumber">
            <summary>Field number for the "py" field.</summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Pose.PzFieldNumber">
            <summary>Field number for the "pz" field.</summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Pose.RxFieldNumber">
            <summary>Field number for the "rx" field.</summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Pose.RyFieldNumber">
            <summary>Field number for the "ry" field.</summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Pose.RzFieldNumber">
            <summary>Field number for the "rz" field.</summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Pose.RwFieldNumber">
            <summary>Field number for the "rw" field.</summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.Msg">
            <summary>
            Msg represents a message passed between Hagall and its clients through a
            WebSocket.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Msg.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Msg.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Msg.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Msg.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.Request">
            <summary>
            Request represents a client request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Request.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Request.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Request.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Request.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Request.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Request.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.Response">
            <summary>
            Response represents a message returned in response to a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Response.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Response.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Response.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Response.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.Response.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Response.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse">
            <summary>
            ErrorResponse represents a message returned when a request error occurs.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse.CodeFieldNumber">
            <summary>Field number for the "code" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse.Code">
            <summary>
            The error code.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.SyncClock">
            <summary>
            SyncClock represents a message periodically sent by a Hagall server to ping a
            client.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.SyncClock.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.SyncClock.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.SyncClock.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.SyncClock.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState">
            <summary>
            SessionState represents a session state.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.ParticipantsFieldNumber">
            <summary>Field number for the "participants" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.Participants">
            <summary>
            The participants that joined the session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.EntitiesFieldNumber">
            <summary>Field number for the "entities" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.Entities">
            <summary>
            The entities present in the session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.EntityComponentsFieldNumber">
            <summary>Field number for the "entity_components" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.EntityComponents">
            <summary>
            The entity components present in the session.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest">
             <summary>
             ParticipantJoinRequest represents a message for a client to request joining a
             session.
            
             It returns an error when the request is sent while the participant is already
             in a session.
             </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest.SessionIdFieldNumber">
            <summary>Field number for the "session_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest.SessionId">
            <summary>
            The id of the session to join. A new session is joined when this field is
            left empty.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse">
            <summary>
            ParticipantJoinResponse represents a message returned in response to a
            participant join request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.SessionIdFieldNumber">
            <summary>Field number for the "session_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.SessionId">
            <summary>
            The id of the joined session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.ParticipantIdFieldNumber">
            <summary>Field number for the "participant_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.ParticipantId">
            <summary>
            The participant id given to the requester.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.SessionUuidFieldNumber">
            <summary>Field number for the "session_uuid" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.SessionUuid">
            <summary>
            The UUID of the session
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast">
            <summary>
            ParticipantJoinBroadcast represents a message that notifies that a
            participant joined the current session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast.OriginTimestampFieldNumber">
            <summary>Field number for the "origin_timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast.OriginTimestamp">
            <summary>
            The timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast.ParticipantIdFieldNumber">
            <summary>Field number for the "participant_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast.ParticipantId">
            <summary>
            The id of the participant that joined the current session.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveRequest">
            <summary>
            ParticipantLeaveRequest represents a message for a client to leave the
            current session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast">
            <summary>
            ParticipantLeaveRequest represents a message that notifies that a participant
            left the current session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast.OriginTimestampFieldNumber">
            <summary>Field number for the "origin_timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast.OriginTimestamp">
            <summary>
            The timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast.ParticipantIdFieldNumber">
            <summary>Field number for the "participant_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast.ParticipantId">
            <summary>
            The id of the participant that left the session.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest">
            <summary>
            EntityAddRequest represents a message to add an entity into the current
            session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.PoseFieldNumber">
            <summary>Field number for the "pose" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.Pose">
            <summary>
            The initial pose of the entity.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.PersistFieldNumber">
            <summary>Field number for the "persist" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.Persist">
            <summary>
            A boolean that reports whether the entity is deleted when its owner
            (a participant) leaves the current session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.FlagFieldNumber">
            <summary>Field number for the "flag" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.Flag">
            <summary>
            The entity flag that gives context to the entity.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse">
            <summary>
            EntityAddResponse represents a message returned in response to an entity add
            request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse.EntityIdFieldNumber">
            <summary>Field number for the "entity_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse.EntityId">
            <summary>
            The entity id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast">
            <summary>
            EntityAddBroadcast represents a message that notifies that an entity has been
            added to the current session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast.OriginTimestampFieldNumber">
            <summary>Field number for the "origin_timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast.OriginTimestamp">
            <summary>
            The timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast.EntityFieldNumber">
            <summary>Field number for the "entity" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast.Entity">
            <summary>
            The added entity.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest">
            <summary>
            EntityDeleteRequest represents a message to delete an entity from the current
            session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest.EntityIdFieldNumber">
            <summary>Field number for the "entity_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest.EntityId">
            <summary>
            The entity id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteResponse">
             <summary>
             EntityDeleteResponse represents a message returned in response to an entity
             delete request.
            
             Clients should also delete the resources associated with the entity, such as
             asset instances.
             </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast">
             <summary>
             EntityDeleteBroadcast represents a message that notifies that an entity has
             been deleted from the current session.
            
             Clients should also delete the resources associated with the entity, such as
             asset instances.
             </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast.OriginTimestampFieldNumber">
            <summary>Field number for the "origin_timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast.OriginTimestamp">
            <summary>
            The timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast.EntityIdFieldNumber">
            <summary>Field number for the "entity_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast.EntityId">
            <summary>
            The id of the deleted entity.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose">
            <summary>
            EntityUpdatePoseRequest represents a message to update an entity pose in the
            current session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose.EntityIdFieldNumber">
            <summary>Field number for the "entity_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose.EntityId">
            <summary>
            The id of the entity to update.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose.PoseFieldNumber">
            <summary>Field number for the "pose" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose.Pose">
            <summary>
            The updated entity pose.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast">
            <summary>
            EntityUpdatePoseBroadcast represents a message that notifies an entity pose
            update within the current session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.OriginTimestampFieldNumber">
            <summary>Field number for the "origin_timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.OriginTimestamp">
            <summary>
            The timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.EntityIdFieldNumber">
            <summary>Field number for the "entity_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.EntityId">
            <summary>
            The entity id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.PoseFieldNumber">
            <summary>Field number for the "pose" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.Pose">
            <summary>
            The updated pose.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage">
            <summary>
            CustomMessage represents a message to send a custom message to one or many
            other participants.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage.ParticipantIdsFieldNumber">
            <summary>Field number for the "participant_ids" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage.ParticipantIds">
            <summary>
            The ids of the participants who will receive the message. The message is
            sent to all participants when empty.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage.BodyFieldNumber">
            <summary>Field number for the "body" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage.Body">
            <summary>
            The message body.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast">
            <summary>
            CustomMessageBroadcast represents a message that notifies a participant that
            a custom message has been sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.OriginTimestampFieldNumber">
            <summary>Field number for the "origin_timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.OriginTimestamp">
            <summary>
            The timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.ParticipantIdFieldNumber">
            <summary>Field number for the "participant_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.ParticipantId">
            <summary>
            The id of the participant that sent the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.BodyFieldNumber">
            <summary>Field number for the "body" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.Body">
            <summary>
            The message body.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponent">
            <summary>
            An entity component.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponent.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponent.EntityComponentTypeId">
            <summary>
            The entity component type id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponent.EntityIdFieldNumber">
            <summary>Field number for the "entity_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponent.EntityId">
            <summary>
            The entity id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponent.DataFieldNumber">
            <summary>Field number for the "data" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponent.Data">
            <summary>
            The component data.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest">
            <summary>
            EntityComponentTypeAddRequest represents a message for a client to add and
            entity component type. It returns an error when the named entity component
            type has already been added.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest.EntityComponentTypeNameFieldNumber">
            <summary>Field number for the "entity_component_type_name" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest.EntityComponentTypeName">
            <summary>
            The entity component type name.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse">
            <summary>
            EntityComponentTypeAddResponse represents a message returned in response to
            an entity component type add request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse.EntityComponentTypeId">
            <summary>
            The entity component type id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest">
            <summary>
            EntityComponentTypeGetNameRequest represents a message for a client to
            request a component name. It returns an error when there is no entity
            component type with the given entity component id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest.EntityComponentTypeId">
            <summary>
            The entity component type id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse">
            <summary>
            EntityComponentTypeGetNameResponse represents a message returned in response
            to a get entity component type name request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse.EntityComponentTypeNameFieldNumber">
            <summary>Field number for the "entity_component_type_name" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse.EntityComponentTypeName">
            <summary>
            The entity component type name.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest">
            <summary>
            EntityComponentTypeGetIdRequest represents a message for a client to request
            a component id. It returns an error when there is no component registered
            with the given name.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest.EntityComponentTypeNameFieldNumber">
            <summary>Field number for the "entity_component_type_name" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest.EntityComponentTypeName">
            <summary>
            The entity component type name.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse">
            <summary>
            EntityComponentTypeGetIdResponse represents a message returned in response to
            a get entity component type id request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse.EntityComponentTypeId">
            <summary>
            The entity component type id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest">
            <summary>
            EntityComponentAddRequest represents a message for a client to add an entity
            component. It returns an error when an entity does not exist or when an
            entity component is not registered.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.EntityComponentTypeId">
            <summary>
            The entity component type id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.EntityIdFieldNumber">
            <summary>Field number for the "entity_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.EntityId">
            <summary>
            The entity id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.DataFieldNumber">
            <summary>Field number for the "data" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.Data">
            <summary>
            The component data.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddResponse">
            <summary>
            EntityComponentAddResponse represents a message returned in response to an
            add entity component id request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast">
            <summary>
            EntityComponentAddBroadcast represents a message that notifies that an entity
            component has been added.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast.OriginTimestampFieldNumber">
            <summary>Field number for the "origin_timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast.OriginTimestamp">
            <summary>
            The timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast.EntityComponentFieldNumber">
            <summary>Field number for the "entity_component" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast.EntityComponent">
            <summary>
            The entity component.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest">
            <summary>
            EntityComponentDeleteRequest represents a message for a client to delete an
            entity component.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.EntityComponentTypeId">
            <summary>
            The entity component type id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.EntityIdFieldNumber">
            <summary>Field number for the "entity_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.EntityId">
            <summary>
            The entity id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteResponse">
            <summary>
            EntityComponentDeleteResponse represents a message returned in response to a
            delete entity component id request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast">
            <summary>
            EntityComponentDeleteBroadcast represents a message that notifies that an
            entity component has been deleted.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast.OriginTimestampFieldNumber">
            <summary>Field number for the "origin_timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast.OriginTimestamp">
            <summary>
            The timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast.EntityComponentFieldNumber">
            <summary>Field number for the "entity_component" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast.EntityComponent">
            <summary>
            The entity component.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate">
            <summary>
            EntityComponentUpdate represents a message to update an added entity
            component. The update is silently aborted when the entity component has not
            been previously added.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.EntityComponentTypeId">
            <summary>
            The entity component type id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.EntityIdFieldNumber">
            <summary>Field number for the "entity_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.EntityId">
            <summary>
            The entity id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.DataFieldNumber">
            <summary>Field number for the "data" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.Data">
            <summary>
            The component data.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast">
            <summary>
            EntityComponentUpdateBroadcast represents a message that notifies that an
            entity component has been updated.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast.OriginTimestampFieldNumber">
            <summary>Field number for the "origin_timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast.OriginTimestamp">
            <summary>
            The timestamp of the request that triggered the broadcast.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast.EntityComponentFieldNumber">
            <summary>Field number for the "entity_component" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast.EntityComponent">
            <summary>
            The entity component id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest">
            <summary>
            EntityComponentListRequest represents a message for a client to request a
            list of entity components.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest.EntityComponentTypeId">
            <summary>
            The component entity type id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse">
            <summary>
            EntityComponentListResponse represents a message returned in response to a
            list entity component request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse.EntityComponentsFieldNumber">
            <summary>Field number for the "entity_components" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse.EntityComponents">
            <summary>
            The entity component list.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest">
            <summary>
            EntityComponentTypeSubscribeRequest represents a message to subscribe to
            entity components type broadcasts.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest.EntityComponentTypeId">
            <summary>
            The entity component type id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeResponse">
            <summary>
            EntityComponentTypeSubscribeResponse represents a message returned in
            response to an entity component type subscription.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest">
            <summary>
            EntityComponentTypeUnsubscribeRequest represents a message to unsubscribe to
            entity component type subscriptions.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest.EntityComponentTypeIdFieldNumber">
            <summary>Field number for the "entity_component_type_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest.EntityComponentTypeId">
            <summary>
            The entity component type id.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeResponse">
            <summary>
            EntityComponentTypeUnsubscribeResponse represents a message returned in
            response to an entity component type unsubscribe request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest">
            <summary>
            ReceiptRequest represents a message sent by the SDK to the Hagall
            containing proof of work receipt, with hash and signature
            to be passed on to NetworkCreditService
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.Type">
            <summary>
            The type of the message
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.ReceiptFieldNumber">
            <summary>Field number for the "receipt" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.Receipt">
            <summary>
            proof of work receipt, serialized to json string
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.HashFieldNumber">
            <summary>Field number for the "hash" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.Hash">
            <summary>
            hash of the receipt
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.SignatureFieldNumber">
            <summary>Field number for the "signature" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.Signature">
            <summary>
            signature of the receipt, signed by App's private ECDSA key
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptResponse">
            <summary>
            ReceiptResponse represents a message returned in response to a receipt request
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptResponse.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptResponse.Type">
            <summary>
            The type of the message.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptResponse.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptResponse.Timestamp">
            <summary>
            The time the message is sent.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptResponse.RequestIdFieldNumber">
            <summary>Field number for the "request_id" field.</summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptResponse.RequestId">
            <summary>
            The id that identifies a request.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.IConjureKit">
            <summary>
            Generic interface for ConjureKit API
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetConfiguration">
            <summary>
            Gets the current configuration.
            </summary>
            <returns>ConjureKitConfiguration struct</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetCameraTransform">
            <summary>
            Gets the camera transform.
            </summary>
            <returns>Transform</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetCredentials">
            <summary>
            Gets the current credentials.
            </summary>
            <returns>AukiCredentials struct</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnInit">
            <summary>
            Called after successful initialization or re-initialization
            of ConjureKit and its modules. The argument passed to OnInit
            is the configuration for which initialization took place.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnParticipantJoined">
            <summary>
            Called when a new Participant joins the Session.
            </summary>
            <returns>Joining Participant object</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnParticipantLeft">
            <summary>
            Called when a Participant left the Session.
            </summary>
            <returns>Id of Participant that left</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnEntityAdded">
            <summary>
            Called when an Entity is added to the Session.
            <para>
            Note: This event is triggered only for entities created by other participants in the session.
            </para>
            </summary>
            <returns>Added Entity object</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnEntityAddedResponse">
            <summary>
            Called when an Entity add request was successful.
            </summary>
            <returns>Added Entity object</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit._SendBytes(System.Byte[])">
            <summary>
            **(Internal)** Sends a message directly to Hagall.
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnEntityDeleted">
            <summary>
            Called when an Entity was deleted from the Session.
            <para>
            Note: This event is triggered only for entities deleted by other participants in the session.
            </para>
            </summary>
            <returns>Id of deleted Entity</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnEntityDeletedResponse">
            <summary>
            Called when an Entity delete request was successful.
            </summary>
            <returns>Id of deleted Entity</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnJoined">
            <summary>
            Called when a Session was joined.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnParticipantEntityCreated">
            <summary>
            Called after calibration or immediately after joining a Session if this Participant is its host. 
            </summary>
            <returns>Participant Entity object</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnLeft">
            <summary>
            Called when a Session was left. The argument is an inert copy of the old Session object as it stood before leaving.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnStateChanged">
            <summary>
            Called when the ConjureKit state has changed.
            </summary>
            <returns>New ConjureKit state</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetState">
            <summary>
            Gets current ConjureKit State.
            </summary>
            <returns>ConjureKit State</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetNetworkQuality">
            <summary>
            Returns the current NetworkQuality object.
            </summary>
            <returns>NetworkQuality object</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnEntityUpdatePose">
            <summary>
            Called when an Entity%'s Pose has been updated.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnCustomMessageBroadcast">
            <summary>
            Called when a custom message broadcast has been received.
            </summary>
            <returns>CustomMessageBroadcast object</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnApplicationBackground">
            <summary>
            Called when the application was sent to the background.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnApplicationForeground">
            <summary>
            Called when the application was sent to the foreground.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.RegisterModule(Auki.ConjureKit.IConjureKitModule)">
            <summary>
            **(Internal)** Registers IAukiModule-conforming objects so they get updated and receive messages.
            </summary>
            <param name="module">Module to be registered</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetNowAsProtobufTimestamp">
            <summary>
            Standard way of getting the current time.
            </summary>
            <returns>Current time</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetNowMilliseconds">
            <summary>
            Gets current time in milliseconds.
            </summary>
            <returns>Current time in milliseconds</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetNewRequestId">
            <summary>
            **(Internal)** Returns a new request id.
            </summary>
            <returns>New request id</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.Request(System.UInt32,Auki.ConjureKit.Hagall.Protobuf.Gen.MsgType,System.Byte[],System.Action{System.Byte[]},System.Action{System.String})">
            <summary>
            **(Internal)** Sends a request to the server.
            </summary>
            <param name="requestId">Request id</param>
            <param name="msgType">Request MsgType</param>
            <param name="request">Byte array-encoded request</param>
            <param name="onResponse">Callback on success</param>
            <param name="onError">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.Request(System.UInt32,System.Byte[],System.Action{System.Byte[]},System.Action{System.String})">
            <summary>
            **(Internal)** Sends a request to the server. Deprecated version without the message type.
            </summary>
            <param name="requestId">Request id</param>
            <param name="request">Byte array-encoded request</param>
            <param name="onResponse">Callback on success</param>
            <param name="onError">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.MeasurePing(System.Action{System.Double},System.Action{System.String})">
            <summary>
            Perform a millisecond ping measurement of the current session. The measurement
            is aggregated to ConjureKit's NetworkQuality object, accessible via ConjureKit.GetNetworkQuality().
            </summary>
            <param name="onComplete">Callback on success, invoked with millisecond amount</param>
            <param name="onError">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.SendCustomMessage(System.UInt32[],System.Byte[])">
            <summary>
            Sends a custom message to other Participant%s.
            </summary>
            <param name="participantIds">An array of Participant Ids</param>
            <param name="data">An array of custom data</param>
            <returns>Success or failure</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.NotifyARCameraCalibrated">
            <summary>
            Notify Auki that Session calibration has been achieved.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetConjureKitBridge">
            <summary>
            Gets an object with common Unity callbacks. 
            </summary>
            <returns>AukiUnityBridge object</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetSession">
            <summary>
            Gets currently joined Session object.
            </summary>
            <returns>Session object or `null` when not in a Session</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.Connect(System.Action{Auki.ConjureKit.Session},System.Action{System.String})">
            <summary>
            Call when you want to connect to the Aukiverse with the default or current ConjureKitConfiguration.
            The `onComplete` callback is invoked with the same argument as ConjureKit.OnJoined,
            prior to ConjureKit.OnJoined.
            </summary> 
            <param name="onComplete">Callback on success (invoked before ConjureKit.OnJoined)</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.Connect(System.String,System.Action{Auki.ConjureKit.Session},System.Action{System.String})">
            <summary>
            Call when you want to connect to the Aukiverse to a specific session with the default or 
            current ConjureKitConfiguration.
            The `session` argument can also be set to the empty string in which case a new session will be created.
            </summary>
            <param name="sessionId">Desired Session id (can be left blank)</param>
            <param name="onComplete">Callback on success (invoked before ConjureKit.OnJoined)</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.Connect(System.String,System.String,System.Action{Auki.ConjureKit.Session},System.Action{System.String})">
            <summary>
            Call when you want to connect to the Aukiverse to a specific session with a custom
            ConjureKitConfiguration URI.
            The initialization process related to the configUri is idempotent, and will not
            result in re-initialization if the same URI is provided twice.
            </summary>
            <param name="sessionId">Desired Session id (can be left blank)</param>
            <param name="configUri">Custom configUri</param>
            <param name="onComplete">Callback on success (invoked before ConjureKit.OnJoined)</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.Connect(System.String,Auki.ConjureKit.ConjureKitConfiguration,System.Action{Auki.ConjureKit.Session},System.Action{System.String})">
            <summary>
            Call when you want to connect to the Aukiverse to a specific session with a custom
            ConjureKitConfiguration struct.
            The initialization process related to the configUri is idempotent, and will not
            result in re-initialization if the same struct is provided twice.
            </summary>
            <param name="sessionId">Desired Session id (can be left blank)</param>
            <param name="configuration">Custom ConjureKitConfiguration struct</param>
            <param name="onComplete">Callback on success (invoked before ConjureKit.OnJoined)</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.IsInitialized(System.String,System.String@)">
            <summary>
            Determines if ConjureKit and all of its modules are initialized
            for a specific given configuration URI.
            Returns also a reason for not being initialized.
            </summary>
            <param name="configUri">URI for configuration.</param>
            <param name="reason">Reason for not being initialized.</param>
            <returns>`true` if they are initialized, `false` if not.</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.IsInitialized(System.String@)">
            <summary>
            Determines if ConjureKit and all of its modules are initialized
            for the configuration currently being available or used.
            Returns also a reason for not being initialized.
            </summary>
            <param name="reason">Reason for not being initialized.</param>
            <returns>`true` if they are initialized, `false` if not.</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.IsInitialized(System.String)">
            <summary>
            Determines if ConjureKit and all of its modules are initialized
            for the configuration currently being used or,
            when a URI is provided, for the given configuration URI.
            </summary>
            <param name="configUri">Optional URI for configuration.</param>
            <returns>`true` if they are initialized, `false` if not.</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.Init(System.String,System.Action,System.Action{System.String})">
            <summary>
            Optional manual initialization ConjureKit and its modules for a non-default configUrl.
            Note that one must be in a Disconnected or Initializing state to call this function.
            </summary>
            <param name="configUrl">Url of the configuration file (json)</param>
            <param name="onComplete">Callback on success</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.Init(Auki.ConjureKit.ConjureKitConfiguration,System.Action,System.Action{System.String})">
            <summary>
            Optional manual initialization of ConjureKit and its modules for a given ConjureKitConfiguration
            object. One must be in a Disconnected or Initializing state to call this function.
            </summary>
            <param name="configuration">ConjureKitConfiguration instance</param>
            <param name="onComplete">Callback on success</param>
            <param name="onFailed">Callback on failure</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.ConnectionErrorMessageIsInternetConnectivityIssue(System.String)">
            <summary>
            Tells whether a string returned by the onError callback of ConjureKit.Connect()
            denotes an internet connectivity issue.
            </summary>
            <param name="errorMessage">The argument passed to the ConjureKit onError callback</param>
            <returns>bool</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.Disconnect">
            <summary>
            Call to disconnect from a session.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.SetHagallFeatureConfiguration(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Sets lists of required Hagall modules and feature flags.
            </summary>
            <param name="modules">List of required Hagall modules, default is `null` for none</param>
            <param name="featureFlags">List of required Hagall feature flags, default is `null` for none</param>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.SetHagallMinVersion(System.String)">
            <summary>
            Sets application-side request for minimum Hagall version.
            </summary>
            <param name="version">Hagall version number in format vMajor[.Minor][.Patch] (e.g., "v4.5")</param>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnComponentUpdate">
            <summary>
            Low-level ECS callback method that is called when a component update is broadcast from a Session.
            Might later be replaced by Systems.
            </summary>
            <returns>ComponentUpdateBroadcast</returns>
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnComponentAdd">
            <summary>
            Low-level ECS callback method that is called when a component is added to an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
            <returns>ComponentAddBroadcast</returns>           
        </member>
        <member name="P:Auki.ConjureKit.IConjureKit.OnComponentDelete">
            <summary>
            Low-level ECS callback method that is called when a component is deleted from an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
            <returns>ComponentDeleteBroadcast</returns>                       
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.AddComponentType(System.String,System.Action{System.UInt32},System.Action{System.String})">
            <summary>
            Low-level ECS method to add a component type to the Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetComponentTypeId(System.String,System.Action{System.UInt32},System.Action{System.String})">
            <summary>
            Low-level ECS method to get the id of a component type by name from a Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetComponentTypeName(System.UInt32,System.Action{System.String},System.Action{System.String})">
            <summary>
            Low-level ECS method to get the name of a component type by id from a Hagall Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.AddComponent(System.UInt32,System.UInt32,System.Byte[],System.Action,System.Action{System.String})">
            <summary>
            Low-level ECS method to add a component to an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.DeleteComponent(System.UInt32,System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Low-level ECS method to delete a component from an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.GetComponents(System.UInt32,System.Action{System.Collections.Generic.List{Auki.ConjureKit.EntityComponent}},System.Action{System.String})">
            <summary>
            Low-level ECS method to get all components of a component type in a Session.
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.UpdateComponent(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Low-level ECS method to update a component on an Entity in a Session.
            Might later be replaced by Systems.
            </summary>
            <returns>bool indicating success or failure of putting update message on send queue</returns>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.SubscribeToComponentType(System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Low-level ECS method to subscribe to updates of a component type
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.IConjureKit.UnsubscribeToComponentType(System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Low-level ECS method to unsubscribe to updates of a component type
            Might later be replaced by Systems.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.EntityFlag">
            <summary>
            Entity flag enumerated type.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.EntityFlag.EntityFlagEmpty">
            <summary>
            Flag for a standard Entity.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.EntityFlag.EntityFlagParticipantEntity">
            <summary>
            Flag for Entity that is attached to a Participant.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Entity">
            <summary>
            Represents an Entity - an object in a Session with a Pose and an ID that is owned by a specific participant.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Entity.Id">
            <summary>
            Entity id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Entity.ParticipantId">
            <summary>
            Entity owner Participant identifier.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Entity.Flag">
            <summary>
            Entity type.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Entity.Components">
            <summary>
            Dictionary containing the collection of EntityComponents on this Entity, indexed by EntityComponent id.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.Entity.#ctor(System.UInt32,System.UInt32,Auki.ConjureKit.EntityFlag)">
            <summary>
            Constructs an Entity given an Id, its owner (participantId) and any additional flags
            </summary>
            <param name="id">The given id</param>
            <param name="participantId">The owning participant id</param>
            <param name="flag">Any additional EntityFlag(s)</param>
        </member>
        <member name="M:Auki.ConjureKit.Entity.ToString">
            <summary>
            Prints Entity data into a human-readable string.
            </summary>
            <returns>Human-readable string.</returns>
        </member>
        <member name="T:Auki.ConjureKit.EntityComponent">
            <summary>
            Represents a component in HECS (Hagall Entity Component System) - labels an entity as possessing a particular aspect, and holds the data needed to model that aspect.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.EntityComponent.ComponentTypeId">
            <summary>
            Component type id.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.EntityComponent.EntityId">
            <summary>
            Entity id to which the EntityComponent is attached.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.EntityComponent.Data">
            <summary>
            EntityComponent data in byte encoded array.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.EntityComponent.#ctor(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Constructor.
            </summary>
            <param name="componentTypeId">Component type id</param>
            <param name="entityId">Entity id</param>
            <param name="data">Byte encoded array</param>
        </member>
        <member name="T:Auki.ConjureKit.Participant">
            <summary>
            Represents a Participant - a connected client e.g. a mobile device or other hardware
            that wishes to interact with Entities and other Participants in a Session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Participant.Id">
            <summary>
            Participant identifier.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.Participant.#ctor(System.UInt32)">
            <summary>
            Constructs a Participant with a given Id
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Auki.ConjureKit.Participant.ToString">
            <summary>
            Prints Participant info into a human-readable string.
            </summary>
            <returns>Human-readable string.</returns>
        </member>
        <member name="T:Auki.ConjureKit.NetworkQuality">
            <summary>
            Aggregates ping time data to the current session. ConjureKit automatically 
            instantiates a private NetworkQuality instance that is accessible via ConjureKit.GetNetworkQuality(),
            but that instance must be manually hydrated by the user via calls to ConjureKit.MeasurePing().
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.NetworkQuality.AverageRoundtripTimeInMilliseconds">
            <summary>
            Gets the average roundtrip time in milliseconds.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.NetworkQuality.LastRoundtripTimeInMilliseconds">
            <summary>
            Gets the last roundtrip time in milliseconds.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.NetworkQuality.LongestRoundtripTimeInMilliseconds">
            <summary>
            Gets the longest roundtrip time in milliseconds.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.NetworkQuality.ShortestRoundtripTimeInMilliseconds">
            <summary>
            Gets the shortest roundtrip time in milliseconds.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.NetworkQuality.AverageRoundtripTimeInMillisecondsLastTen">
            <summary>
            Gets the average roundtrip time in milliseconds for the last ten measurements.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.NetworkQuality.HagallUri">
            <summary>
            Gets the Hagall URI associated with the network quality data.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.NetworkQuality.#ctor">
            <summary>
            Initializes a new instance of the NetworkQuality class with default values.
            </summary>
        </member>
        <member name="T:Auki.ConjureKit.Session">
            <summary>
            Abstracts the shared state of a ConjureKit multiplayer session.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Session.Id">
            <summary>
            Session identifier.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Session.Uuid">
            <summary>
            **(Internal)** Session backend UUID.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Session.Tag">
            <summary>
            Write-once string that may be set by code that calls ConjureKit.Connect() 
            to mark the connection origin of the Session.
            For best practices, set .Tag in the `onComplete` callback of ConjureKit.Connect().
            The session's .Tag is automatically prepended by a string "X:" where X is a
            counter for the overall number of locally instantiated sessions.
            </summary>
        </member>
        <member name="F:Auki.ConjureKit.Session.ParticipantId">
            <summary>
            Participant identifier for the currently connected user.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetEntity(System.UInt32)">
            <summary>
            Gets Entity object for a given Entity identifier.
            </summary>
            <param name="entityId">Entity identifier</param>
            <returns>Entity object if such Entity exists or null if it doesn't</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetLocalParticipantEntity">
            <summary>
            Gets local Participant Entity.
            </summary>
            <returns>Entity object if such entity exists or null if it doesn't</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.AddEntity(System.Action{Auki.ConjureKit.Entity},System.Action{System.String})">
            <summary>
            Call when you want to add an Entity.
            </summary>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.AddEntity(UnityEngine.Pose,System.Action{Auki.ConjureKit.Entity},System.Action{System.String})">
            <summary>
            Call when you want to add an Entity.
            </summary>
            <param name="pose">Desired Pose of Entity</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.AddEntity(UnityEngine.Pose,System.Boolean,System.Action{Auki.ConjureKit.Entity},System.Action{System.String})">
            <summary>
            Call when you want to add an Entity.
            </summary>
            <param name="pose">Desired Pose of Entity</param>
            <param name="persistent">`true` if the Entity should persist when you've left the Session, `false` if it should be removed</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.AddEntity(UnityEngine.Pose,System.Boolean,Auki.ConjureKit.EntityFlag,System.Action{Auki.ConjureKit.Entity},System.Action{System.String})">
            <summary>
            Call when you want to add an Entity to the current Session.
            </summary>
            <param name="pose">Desired Pose of Entity</param>
            <param name="persistent">`true` if the Entity should persist when you've left the Session, `false` if it should be removed</param>
            <param name="entityFlag">Entity flag for the added Entity</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.DeleteEntity(System.UInt32,System.Action)">
            <summary>
            Call when you want to delete an Entity.
            </summary>
            <param name="entityId">Entity id</param>
            <param name="onComplete">Callback on success</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetComponentTypeIdCached(System.String)">
            <summary>
            Returns, if available, a component Type Id given a component Type Name
            </summary>
            <param name="componentTypeName">The component type name</param>
            <returns>If a type id was already present in cache, true is returned with its type id</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetComponentTypeId(System.String,System.Action{System.UInt32},System.Action{System.String})">
            <summary>
            Gets the id of a component type by name.
            </summary>
            <param name="componentTypeName">Component type name</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetComponentTypeName(System.UInt32,System.Action{System.String},System.Action{System.String})">
            <summary>
            Gets the name of a component type by id.
            </summary>
            <param name="componentTypeId">Component type id</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.AddComponentType(System.String,System.Action{System.UInt32},System.Action{System.String})">
            <summary>
            Adds a component type.
            </summary>
            <param name="componentTypeName">Component type name</param>
            <param name="onComplete">Callback on success that returns component type id</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.AddComponent(System.String,System.UInt32,System.Byte[],System.Action,System.Action{System.String})">
            <summary>
            Adds a component with a given name to an Entity.
            </summary>
            <param name="componentTypeName">Component type name</param>
            <param name="entityId">Id of Entity to which the component will be attached</param>
            <param name="data">Component data</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.AddComponent(System.UInt32,System.UInt32,System.Byte[],System.Action,System.Action{System.String})">
            <summary>
            Adds a component with a given id to an Entity.
            </summary>
            <param name="componentTypeId">Component type id</param>
            <param name="entityId">Id of Entity to which the component will be attached</param>
            <param name="data">Component data</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.DeleteComponent(System.String,System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Deletes a component with a given name from an Entity.
            </summary>
            <param name="componentTypeName">Component type name</param>
            <param name="entityId">Id of Entity to which the component will be attached</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.DeleteComponent(System.UInt32,System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Deletes a component with a given id from an Entity.
            </summary>
            <param name="componentTypeId">Component type id</param>
            <param name="entityId">Id of Entity to which the component will be attached</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetComponentsCached(System.UInt32)">
            <summary>
            Gets a cached list of components for a component type id in the Session.
            </summary>
            <param name="componentTypeId">Component type id</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetComponents(System.UInt32,System.Action{System.Collections.Generic.List{Auki.ConjureKit.EntityComponent}},System.Action{System.String})">
            <summary>
            Gets all components for a component type id in the Session.
            </summary>
            <param name="componentTypeId">Component type id</param>
            <param name="onComplete">Callback on success with a list of EntityComponent%s</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.UpdateComponent(System.String,System.UInt32,System.Byte[])">
            <summary>
            Update component data by component type name for a particular Entity.
            </summary>
            <param name="componentTypeName">Component type name</param>
            <param name="entityId">Entity id which should have its component data updated</param>
            <param name="data">Component data</param>
            <returns>bool indicating success or failure of putting update message on send queue</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.UpdateComponent(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Update component data by component type id for a particular Entity.
            </summary>
            <param name="componentTypeId">Component type id</param>
            <param name="entityId">Entity id which should have its component data updated</param>
            <param name="data">Component data</param>
            <returns>bool indicating success or failure of putting update message on send queue</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.SubscribeToComponentType(System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Subscribe to updates of a component type by component type id.
            </summary>
            <param name="componentTypeId">Component type id</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.UnsubscribeToComponentType(System.UInt32,System.Action,System.Action{System.String})">
            <summary>
            Unsubscribe to updates of a component type by component type id.
            </summary>
            <param name="componentTypeId">Component type id</param>
            <param name="onComplete">Callback on success</param>
            <param name="onError">Callback on error</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetEntityPose(System.UInt32)">
            <summary>
            Gets the Pose for an Entity by its id.
            </summary>
            <param name="entityId">Entity id</param>
            <returns>Pose of Entity</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetEntityPose(Auki.ConjureKit.Entity)">
            <summary>
            Gets the Pose for an Entity.
            </summary>
            <param name="entity">Entity object</param>
            <returns>Pose of Entity</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.SetEntityPose(System.UInt32,UnityEngine.Pose)">
            <summary>
            Sets the Pose for an Entity.
            </summary>
            <param name="entityId">Entity id</param>
            <param name="pose">Desired new Pose</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetEntityComponent(System.UInt32,System.String)">
            <summary>
            Gets EntityComponent for an Entity by component type name.
            </summary>
            <param name="entityId">Entity id</param>
            <param name="componentName">Component type name</param>
            <returns>EntityComponent if it exists or null if it doesn't</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetEntityComponent(System.UInt32,System.UInt32)">
            <summary>
            Gets EntityComponent for an Entity by component type id.
            </summary>
            <param name="entityId">Entity id</param>
            <param name="componentId">Component type id</param>
            <returns>EntityComponent if it exists or null if it doesn't</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetEntityCount">
            <summary>
            Gets total number of Entity objects.
            </summary>
            <returns>Total count of Entity objects</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetEntities">
            <summary>
            Gets a list of all Entity objects
            </summary>
            <returns>List of Entity objects</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetParticipantCount">
            <summary>
            Gets total number of Participant objects.
            </summary>
            <returns>Total count of Participant objects</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetParticipantsIds">
            <summary>
            Gets a list of Participant ids.
            </summary>
            <returns>List of Participant ids</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetParticipants">
            <summary>
            Gets a list of all Participant objects.
            </summary>
            <returns>List of Participant objects</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetParticipantEntities(System.UInt32)">
            <summary>
            Gets a list of all Entities that are owned by a specific Participant.
            </summary>
            <param name="participantId">Participant identifier</param>
            <returns>List of Entity objects</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.RegisterSystem(Auki.ConjureKit.ECS.ISystem,System.Action)">
            <summary>
            Registers a System.
            </summary>
            <param name="system">System that will be registered</param>
            <param name="onComplete">Callback on success</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.UnregisterSystem(Auki.ConjureKit.ECS.ISystem)">
            <summary>
            Unregisters a System.
            </summary>
            <param name="system">System that will be unregistered</param>
        </member>
        <member name="M:Auki.ConjureKit.Session.UnregisterAllSystems">
            <summary>
            Unregisters all System%s.
            </summary>
        </member>
        <member name="M:Auki.ConjureKit.Session.GetRegisteredSystemsForComponentType(System.String)">
            <summary>
            Gets a list of all registered System%s that have a specific component type by its name.
            </summary>
            <param name="componentTypeName">Component type name</param>
            <returns>List of registered System%s with given component type</returns>
        </member>
        <member name="M:Auki.ConjureKit.Session.ToString">
            <summary>
            Prints the state of a Session into a readable string.
            </summary>
            <returns>Printable string of the Session</returns>
        </member>
        <member name="T:Auki.Util.ArrayView`1">
            <summary>
            Array View object constrained to read-only operation, which gives access to a partition of an existing array.
            This allows to provide a view on a portion of an existing array (as if it was a new separate array) without the
            need to copy it.
            </summary>
        </member>
        <member name="M:Auki.Util.ArrayView`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the ArrayView structure, which provides read-only access to an array of a specified type.
            </summary>
            <param name="buffer">The array of type T to create a view from.</param>
            <param name="minIndex">The starting index within the array to begin the view.</param>
            <param name="length">The length of the view, constrained to this length but may be shorter than the provided array.</param>
        </member>
        <member name="P:Auki.Util.ArrayView`1.Count">
            <summary>
            Gets the number of elements in the view.
            </summary>
        </member>
        <member name="P:Auki.Util.ArrayView`1.Length">
            <summary>
            Gets the number of elements in the view.
            </summary>
        </member>
        <member name="M:Auki.Util.ArrayView`1.CopyTo(`0[])">
            <summary>
            Copies the elements from the view to a provided array, starting at the beginning of the array.
            </summary>
            <param name="array">The target array to copy elements to.</param>
        </member>
        <member name="M:Auki.Util.ArrayView`1.CopyTo(Unity.Collections.NativeArray{`0})">
            <summary>
            Copies the elements from the view to a provided NativeArray, starting at the beginning of the array.
            </summary>
            <param name="array">The target NativeArray to copy elements to.</param>
        </member>
        <member name="M:Auki.Util.ArrayView`1.ToArray">
            <summary>
            Converts the view to an array of the same type, copying the elements from the view to the new array.
            </summary>
            <returns>An array of type T containing the elements from the view.</returns>
        </member>
        <member name="P:Auki.Util.ArrayView`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index within the view.
            </summary>
            <param name="index">The index of the element to retrieve.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="M:Auki.Util.ArrayView`1.GetEnumerator">
            <summary>
            Gets an enumerator for iterating through the elements in the view.
            </summary>
            <returns>An enumerator for iterating through the elements.</returns>
        </member>
        <member name="M:Auki.Util.ArrayView`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Gets an enumerator for iterating through the elements in the view.
            </summary>
            <returns>An enumerator for iterating through the elements.</returns>
        </member>
        <member name="M:Auki.Util.ArrayView`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for iterating through the elements in the view.
            </summary>
            <returns>An enumerator for iterating through the elements.</returns>
        </member>
        <member name="T:Auki.Util.ArrayView`1.Enumerator">
            <summary>
            A struct that provides an enumerator for the elements in the ArrayView.
            </summary>
        </member>
        <member name="M:Auki.Util.ArrayView`1.Enumerator.#ctor(Auki.Util.ArrayView{`0}@)">
            <summary>
            Initializes a new instance of the Enumerator struct.
            </summary>
            <param name="array">The ArrayView to enumerate over.</param>
        </member>
        <member name="M:Auki.Util.ArrayView`1.Enumerator.Dispose">
            <summary>
            Disposes of the Enumerator instance.
            </summary>
        </member>
        <member name="M:Auki.Util.ArrayView`1.Enumerator.MoveNext">
            <summary>
            Moves the enumerator to the next element in the view.
            </summary>
            <returns>True if the enumerator was successfully moved to the next element; otherwise, false.</returns>
        </member>
        <member name="M:Auki.Util.ArrayView`1.Enumerator.Reset">
            <summary>
            Resets the enumerator to its initial state.
            </summary>
        </member>
        <member name="P:Auki.Util.ArrayView`1.Enumerator.Current">
            <summary>
            Gets the value of the current element in the view.
            </summary>
        </member>
        <member name="T:Auki.Util.AtomicConditionVariable">
            <summary>
            An internal class for implementing an atomic condition variable.
            This does not block a thread, but checks and enters the area only if no other thread is in.
            </summary>
        </member>
        <member name="M:Auki.Util.AtomicConditionVariable.TryEnter">
            <summary>
            Attempts to enter a locked area in an atomic manner. It does NOT block the thread.
            </summary>
            <returns>True if the lock was successfully acquired; otherwise, false.</returns>
        </member>
        <member name="M:Auki.Util.AtomicConditionVariable.Exit">
            <summary>
            Exits the lock in an atomic manner.
            </summary>
        </member>
        <member name="M:Auki.Util.AtomicConditionVariable.Dispose">
            <summary>
            Releases any acquired lock when this object is disposed.
            </summary>
        </member>
        <member name="T:Auki.Util.AukiDebug">
            <summary>
            Provides debug logging functionality with various log levels.
            </summary>
        </member>
        <member name="T:Auki.Util.AukiDebug.LogLevel">
            <summary>
            Represents different log levels.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.LogLevel.TRACE">
            <summary>
            Trace log level (lowest).
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.LogLevel.DEBUG">
            <summary>
            Debug log level.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.LogLevel.INFO">
            <summary>
            Information log level.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.LogLevel.WARNING">
            <summary>
            Warning log level.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.LogLevel.ERROR">
            <summary>
            Error log level.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.LogLevel.CRITICAL">
            <summary>
            Critical log level.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.LogLevel.NONE">
            <summary>
            No log messages will be shown (highest).
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.logLevel">
            <summary>
            The current log level setting.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.AukiPrefix">
            <summary>
            Prefix used for Auki logs
            </summary>
        </member>
        <member name="T:Auki.Util.AukiDebug.FileByFileMuteMode">
            <summary>
            Enumerates the available modes for muting/unmuting logs based on specific files.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.FileByFileMuteMode.UNUSED">
            <summary>
            Indicates that the file-by-file mute mode is not in use.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.FileByFileMuteMode.MUTED_BY_DEFAULT">
            <summary>
            Indicates that the log files are muted by default unless explicitly unmuted.
            </summary>
        </member>
        <member name="F:Auki.Util.AukiDebug.FileByFileMuteMode.UNMUTED_BY_DEFAULT">
            <summary>
            Indicates that the log files are unmuted by default unless explicitly muted.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiDebug.ShowMuted">
            <summary>
            Shows the list of muted files.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiDebug.ShowUnmuted">
            <summary>
            Shows the list of unmuted files.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiDebug.Mute(System.String)">
            <summary>
            Mutes logs from a specific file.
            </summary>
            <param name="file">The name of the file to mute.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.Unmute(System.String)">
            <summary>
            Unmutes logs from a specific file.
            </summary>
            <param name="file">The name of the file to unmute.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.Mute(System.Collections.Generic.List{System.String})">
            <summary>
            Mutes logs from a list of files.
            </summary>
            <param name="files">A list of file names to mute.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.Unmute(System.Collections.Generic.List{System.String})">
            <summary>
            Unmutes logs from a list of files.
            </summary>
            <param name="files">A list of file names to unmute.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.LogTrace(System.String,UnityEngine.StackTraceLogType,System.String,System.String,System.Int32)">
            <summary>
            Logs a message with the TRACE log level.
            </summary>
            <param name="message">The message to log.</param>
            <param name="stackTraceLogType">The type of stack trace information to include.</param>
            <param name="caller">The name of the calling method.</param>
            <param name="file">The file in which the log message is generated.</param>
            <param name="line">The line number where the log message is generated.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.LogDebug(System.String,UnityEngine.StackTraceLogType,System.String,System.String,System.Int32)">
            <summary>
            Logs a message with the DEBUG log level.
            </summary>
            <param name="message">The message to log.</param>
            <param name="stackTraceLogType">The type of stack trace information to include.</param>
            <param name="caller">The name of the calling method.</param>
            <param name="file">The file in which the log message is generated.</param>
            <param name="line">The line number where the log message is generated.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.LogInformation(System.String,UnityEngine.StackTraceLogType,System.String,System.String,System.Int32)">
            <summary>
            Logs a message with the INFO log level.
            </summary>
            <param name="message">The message to log.</param>
            <param name="stackTraceLogType">The type of stack trace information to include.</param>
            <param name="caller">The name of the calling method.</param>
            <param name="file">The file in which the log message is generated.</param>
            <param name="line">The line number where the log message is generated.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.LogInfo(System.String,UnityEngine.StackTraceLogType,System.String,System.String,System.Int32)">
            <summary>
            Logs a message with the INFO log level.
            </summary>
            <param name="message">The message to log.</param>
            <param name="stackTraceLogType">The type of stack trace information to include.</param>
            <param name="caller">The name of the calling method.</param>
            <param name="file">The file in which the log message is generated.</param>
            <param name="line">The line number where the log message is generated.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.LogWarning(System.String,UnityEngine.StackTraceLogType,System.String,System.String,System.Int32)">
            <summary>
            Logs a message with the WARNING log level.
            </summary>
            <param name="message">The message to log.</param>
            <param name="stackTraceLogType">The type of stack trace information to include.</param>
            <param name="caller">The name of the calling method.</param>
            <param name="file">The file in which the log message is generated.</param>
            <param name="line">The line number where the log message is generated.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.LogError(System.String,UnityEngine.StackTraceLogType,System.String,System.String,System.Int32)">
            <summary>
            Logs a message with the ERROR log level.
            </summary>
            <param name="message">The message to log.</param>
            <param name="stackTraceLogType">The type of stack trace information to include.</param>
            <param name="caller">The name of the calling method.</param>
            <param name="file">The file in which the log message is generated.</param>
            <param name="line">The line number where the log message is generated.</param>
        </member>
        <member name="M:Auki.Util.AukiDebug.LogCritical(System.String,UnityEngine.StackTraceLogType,System.String,System.String,System.Int32)">
            <summary>
            Logs a message with the CRITICAL log level.
            </summary>
            <param name="message">The message to log.</param>
            <param name="stackTraceLogType">The type of stack trace information to include.</param>
            <param name="caller">The name of the calling method.</param>
            <param name="file">The file in which the log message is generated.</param>
            <param name="line">The line number where the log message is generated.</param>
        </member>
        <member name="T:Auki.Util.AukiDiagnostics">
            <summary>
            Provides diagnostic information related to data transmission in the Auki application.
            </summary>
        </member>
        <member name="P:Auki.Util.AukiDiagnostics.BytesSent">
            <summary>
            Gets or sets the total number of bytes sent by the Auki application.
            </summary>
        </member>
        <member name="P:Auki.Util.AukiDiagnostics.BytesReceived">
            <summary>
            Gets or sets the total number of bytes received by the Auki application.
            </summary>
        </member>
        <member name="P:Auki.Util.AukiDiagnostics.EventLogBytesSent">
            <summary>
            Gets or sets the total number of event log bytes sent by the Auki application.
            </summary>
        </member>
        <member name="T:Auki.Util.AukiStopwatch">
            <summary>
            A utility class for measuring time intervals and performance.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiStopwatch.Init">
            <summary>
            Initializes the stopwatch by starting its internal timer.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiStopwatch.Start(System.String)">
            <summary>
            Starts timing a specific operation identified by the given key.
            </summary>
            <param name="key">A unique identifier for the operation being timed.</param>
        </member>
        <member name="M:Auki.Util.AukiStopwatch.Stop(System.String)">
            <summary>
            Stops timing the specified operation and returns the elapsed time.
            </summary>
            <param name="key">The key associated with the operation being timed.</param>
            <returns>The elapsed time as a TimeSpan.</returns>
        </member>
        <member name="T:Auki.Util.AukiUnityWebRequestBuilder">
            <summary>
            This builder will produce a UnityWebRequest object that has a user ID request header set.
            It is a fluent builder which means you can use it in the following fashion:
            <code>
            var request = new AukiUnityWebRequestBuilder(url, "GET")
                 .SetRequestHeader("Content-Type", "application/json")
                 .SetRequestHeader("Authorization", _authorizationHeaderValue)
                 .SetUploadHandler(new UploadHandlerRaw(Encoding.UTF8.GetBytes(jsonString)))
                 .SetDownloadHandler(new DownloadHandlerBuffer())
                 .GetResult();
            </code>
            </summary>
        </member>
        <member name="M:Auki.Util.AukiUnityWebRequestBuilder.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the AukiUnityWebRequestBuilder class with the specified URL and HTTP method.
            </summary>
            <param name="url">The URL for the UnityWebRequest.</param>
            <param name="method">The HTTP method (e.g., "GET" or "POST").</param>
        </member>
        <member name="M:Auki.Util.AukiUnityWebRequestBuilder.AddQueryParameter(System.String,System.String,System.String@)">
            <summary>
            Adds a query parameter to the request's URL.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiUnityWebRequestBuilder.AddQueryParameter(System.String,System.String)">
            <summary>
            Adds a query parameter to the request's URL.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiUnityWebRequestBuilder.SetRequestHeader(System.String,System.String)">
            <summary>
            Sets a request header with the given name and value.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiUnityWebRequestBuilder.SetDownloadHandler(UnityEngine.Networking.DownloadHandler)">
            <summary>
            Sets the download handler for the UnityWebRequest.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiUnityWebRequestBuilder.SetUploadHandler(UnityEngine.Networking.UploadHandlerRaw)">
            <summary>
            Sets the upload handler for the UnityWebRequest.
            </summary>
        </member>
        <member name="M:Auki.Util.AukiUnityWebRequestBuilder.GetResult">
            <summary>
            Gets the configured UnityWebRequest instance.
            </summary>
            <returns>The UnityWebRequest object with the specified settings.</returns>
        </member>
        <member name="T:Auki.Util.UserIdFromPlayerPrefsRequestHeader">
            <summary>
            Constructs the name and value for the user ID request header from a GUID stored in PlayerPrefs.
            </summary>
        </member>
        <member name="P:Auki.Util.UserIdFromPlayerPrefsRequestHeader.Name">
            <summary>
            Request Header name for User ID
            </summary>
        </member>
        <member name="P:Auki.Util.UserIdFromPlayerPrefsRequestHeader.Value">
            <summary>
            Gets the user ID value from PlayerPrefs or generates a new one if it doesn't exist.
            </summary>
            <returns>The user ID as a string.</returns>
        </member>
        <member name="T:Auki.Util.BitwiseArrayView">
            <summary>
            Array View interface constrained to read-only operation, which indexes single bits in the array.
            This tool allows to pass a span of any existing array of bits without need of copying.
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseArrayView.#ctor(System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the BitwiseArrayView structure, which provides read-only access to individual bits in an array of uint values.
            </summary>
            <param name="buffer">The array of uint values containing the bits to be viewed.</param>
            <param name="startIndexInBits">The starting bit index within the array to begin the view.</param>
            <param name="lengthInBits">The length, in bits, of the view. The view is constrained to this length, but may be shorter than the provided array.</param>
        </member>
        <member name="P:Auki.Util.BitwiseArrayView.Count">
            <summary>
            Gets the total number of bits in the view.
            </summary>
        </member>
        <member name="P:Auki.Util.BitwiseArrayView.Length">
            <summary>
            Gets the total number of bits in the view.
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseArrayView.ToBoolArray">
            <summary>
            Converts the view to a boolean array. This involves a new array being created.
            </summary>
            <returns>An array of boolean values corresponding to the bits in the view.</returns>
        </member>
        <member name="P:Auki.Util.BitwiseArrayView.Item(System.Int32)">
            <summary>
            Gets the value of the bit at the specified index.
            </summary>
            <param name="index">The index of the bit to retrieve.</param>
            <returns>The value of the bit at the specified index.</returns>
        </member>
        <member name="M:Auki.Util.BitwiseArrayView.GetEnumerator">
            <summary>
            Gets an enumerator for iterating through the bits in the view.
            </summary>
            <returns>An enumerator for iterating through the bits.</returns>
        </member>
        <member name="M:Auki.Util.BitwiseArrayView.System#Collections#Generic#IEnumerable{System#Boolean}#GetEnumerator">
            <summary>
            Gets an enumerator for iterating through the bits in the view.
            </summary>
            <returns>An enumerator for iterating through the bits.</returns>
        </member>
        <member name="M:Auki.Util.BitwiseArrayView.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for iterating through the bits in the view.
            </summary>
            <returns>An enumerator for iterating through the bits.</returns>
        </member>
        <member name="T:Auki.Util.BitwiseArrayView.Enumerator">
            <summary>
            Enumerator for iterating over the bits in the <see cref="T:Auki.Util.BitwiseArrayView" />..
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseArrayView.Enumerator.#ctor(Auki.Util.BitwiseArrayView@)">
            <summary>
            Initializes the Enumerator for <see cref="T:Auki.Util.BitwiseArrayView" />.
            </summary>
            <param name="array">The array the enumerator should iterate on.</param>
        </member>
        <member name="M:Auki.Util.BitwiseArrayView.Enumerator.Dispose">
            <summary>
            Disposes of the Enumerator instance.
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseArrayView.Enumerator.MoveNext">
            <summary>
            Moves the enumerator to the next bit in the view.
            </summary>
            <returns>True if the enumerator was successfully moved to the next bit; otherwise, false.</returns>
        </member>
        <member name="M:Auki.Util.BitwiseArrayView.Enumerator.Reset">
            <summary>
            Resets the enumerator to the initial state.
            </summary>
        </member>
        <member name="P:Auki.Util.BitwiseArrayView.Enumerator.Current">
            <summary>
            Gets the value of the current bit in the view.
            </summary>
        </member>
        <member name="T:Auki.Util.BitwiseNativeArrayView">
            <summary>
            NativeArray View interface constrained to read-only operation, which indexes single bits in the array.
            This tool allows to pass a span of any existing NativeArray of bits without need of copying.
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseNativeArrayView.#ctor(Unity.Collections.NativeArray{System.UInt32},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the BitwiseNativeArrayView structure, which provides read-only access to individual bits in a NativeArray of uint values.
            </summary>
            <param name="buffer">The NativeArray of uint values containing the bits to be viewed.</param>
            <param name="startIndexInBits">The starting bit index within the NativeArray to begin the view.</param>
            <param name="lengthInBits">The length, in bits, of the view. The view is constrained to this length, but may be shorter than the provided NativeArray.</param>
        </member>
        <member name="P:Auki.Util.BitwiseNativeArrayView.Count">
            <summary>
            Gets the total number of bits in the view.
            </summary>
        </member>
        <member name="P:Auki.Util.BitwiseNativeArrayView.Length">
            <summary>
            Gets the total number of bits in the view.
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseNativeArrayView.ToBoolArray">
            <summary>
            Converts the view to a boolean array. This involves a new array being created.
            </summary>
            <returns>An array of boolean values corresponding to the bits in the view.</returns>
        </member>
        <member name="P:Auki.Util.BitwiseNativeArrayView.Item(System.Int32)">
            <summary>
            Gets the value of the bit at the specified index.
            </summary>
            <param name="index">The index of the bit to retrieve.</param>
            <returns>The value of the bit at the specified index.</returns>
        </member>
        <member name="P:Auki.Util.BitwiseNativeArrayView.IsCreated">
            <summary>
            Gets a value indicating whether the BitwiseNativeArrayView is created.
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseNativeArrayView.GetEnumerator">
            <summary>
            Provides an enumerator for iterating over the bits in the BitwiseNativeArrayView.
            </summary>
        </member>
        <member name="T:Auki.Util.BitwiseNativeArrayView.Enumerator">
            <summary>
            Enumerator for iterating over the bits in the <see cref="T:Auki.Util.BitwiseNativeArrayView" />..
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseNativeArrayView.Enumerator.#ctor(Auki.Util.BitwiseNativeArrayView@)">
            <summary>
            Initializes the Enumerator for <see cref="T:Auki.Util.BitwiseNativeArrayView" />.
            </summary>
            <param name="array">The array the enumerator should iterate on.</param>
        </member>
        <member name="M:Auki.Util.BitwiseNativeArrayView.Enumerator.Dispose">
            <summary>
            Disposing of the enumerator.
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseNativeArrayView.Enumerator.MoveNext">
            <summary>
            Moves the enumerator to the next bit in the view.
            </summary>
            <returns>True if the enumerator was successfully moved to the next bit; otherwise, false.</returns>
        </member>
        <member name="M:Auki.Util.BitwiseNativeArrayView.Enumerator.Reset">
            <summary>
            Resets the enumerator to the initial state.
            </summary>
        </member>
        <member name="P:Auki.Util.BitwiseNativeArrayView.Enumerator.Current">
            <summary>
            Gets the value of the current bit in the view.
            </summary>
        </member>
        <member name="T:Auki.Util.Crc32">
            <summary>
            A utility class for calculating CRC32 checksums.
            </summary>
        </member>
        <member name="M:Auki.Util.Crc32.UPDC32(System.Byte,System.UInt32)">
            <summary>
            Updates the CRC-32 value with a new octet (byte).
            </summary>
            <param name="octet">The octet (byte) to update the CRC-32 with.</param>
            <param name="crc">The current CRC-32 value to update.</param>
            <returns>The updated CRC-32 value.</returns>
        </member>
        <member name="M:Auki.Util.Crc32.GetCRC32(Unity.Collections.NativeArray{System.UInt32},System.Int32,System.Int32)">
            <summary>
            Calculates the CRC-32 checksum for a specified range of data in a NativeArray.
            </summary>
            <param name="data">The NativeArray containing the data to calculate the checksum for.</param>
            <param name="offset">The index in the NativeArray where the data range begins.</param>
            <param name="len">The length of the data range for which the checksum is calculated.</param>
            <returns>The CRC-32 checksum of the specified data range.</returns>
        </member>
        <member name="T:Auki.Util.Drawing">
             <summary>
             A utility class for drawing lines in 2D space, suitable for use in Unity's OnGUI calls.
             Originally courtesy of Linusmartensson:
             http://forum.unity3d.com/threads/71979-Drawing-lines-in-the-editor
            
             Rewritten to improve performance by Yossarian King / August 2013.
            
             This version produces virtually identical results to the original (tested by drawing
             one over the other and observing errors of one pixel or less), but for large numbers
             of lines this version is more than four times faster than the original, and comes
             within about 70% of the raw performance of Graphics.DrawTexture.
            
             Peak performance on my laptop is around 200,000 lines per second. The laptop is
             Windows 7 64-bit, Intel Core2 Duo CPU 2.53GHz, 4G RAM, NVIDIA GeForce GT 220M.
             Line width and anti-aliasing had negligible impact on performance.
            
             For a graph of benchmark results in a standalone Windows build, see <see href="https://app.box.com/s/hyuhi565dtolqdm97e00">this image</see>.
            
             For a Google spreadsheet with full benchmark results, see <see href="https://docs.google.com/spreadsheet/ccc?key=0AvJlJlbRO26VdHhzeHNRMVF2UHZHMXFCTVFZN011V1E">HERE</see>.
             </summary>
        </member>
        <member name="M:Auki.Util.Drawing.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Single,System.Single,System.Boolean)">
            <summary>
            Draws a line in screen space from point A to point B with the specified color, width, and anti-aliasing.
            </summary>
            <param name="pointA">The starting point of the line.</param>
            <param name="pointB">The ending point of the line.</param>
            <param name="color">The color of the line.</param>
            <param name="width">The width of the line.</param>
            <param name="screenHeight">The height of the screen in pixels.</param>
            <param name="antiAlias">Whether to apply anti-aliasing to the line.</param>
        </member>
        <member name="M:Auki.Util.Drawing.DrawLine(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Color,System.Single,System.Boolean)">
            <summary>
            Draws a line in screen space from point A to point B with the specified color, width, and anti-aliasing.
            </summary>
            <param name="pointA">The starting point of the line.</param>
            <param name="pointB">The ending point of the line.</param>
            <param name="color">The color of the line.</param>
            <param name="width">The width of the line.</param>
            <param name="antiAlias">Whether to apply anti-aliasing to the line.</param>
        </member>
        <member name="T:Auki.Util.Hashing">
            <summary>
            Utility class containing various algorithms to perform Hashing on bytes.
            </summary>
        </member>
        <member name="M:Auki.Util.Hashing.Crc32IterateHash(System.Byte,System.UInt32)">
            <summary>
            CRC32 hashing, to be called iterative for each item you want to include in the hash.
            To finalize the hash (and avalance), call <see cref="M:Auki.Util.Hashing.Crc32FinalizeHash(System.UInt32)" /> on the resulting value.
            </summary>
            <param name="nextValue">the next value to hash</param>
            <param name="prevHash">the previous hash result</param>
            <returns>The hashed value (not finalized)</returns>
        </member>
        <member name="M:Auki.Util.Hashing.Crc32FinalizeHash(System.UInt32)">
            <summary>
            CRC32 hashing finalization, to be called after the iterative hashing with <see cref="M:Auki.Util.Hashing.Crc32IterateHash(System.Byte,System.UInt32)" /> has ended.
            Call this on the result value To finalize the hash.
            </summary>
            <param name="hash">the hash result of the iterative hashing</param>
            <returns>The finalized hash value</returns>
        </member>
        <member name="M:Auki.Util.Hashing.JenkinsIterateHash(System.Byte,System.UInt32)">
            <summary>
            Jenkins hashing, to be called iterative for each item you want to include in the hash.
            To finalize the hash (and avalance), call <see cref="M:Auki.Util.Hashing.JenkinsFinalizeHash(System.UInt32)" /> on the resulting value.
            Ref: https://en.wikipedia.org/wiki/Jenkins_hash_function
            </summary>
            <param name="nextValue">the next value to hash</param>
            <param name="prevHash">the previous hash result</param>
            <returns>The hashed value (not finalized)</returns>
        </member>
        <member name="M:Auki.Util.Hashing.JenkinsFinalizeHash(System.UInt32)">
            <summary>
            Jenkins hashing finalization, to be called after the iterative hashing with <see cref="M:Auki.Util.Hashing.JenkinsIterateHash(System.Byte,System.UInt32)" /> has ended.
            Call this on the result value To finalize the hash (and avalance).
            Ref: https://en.wikipedia.org/wiki/Jenkins_hash_function
            </summary>
            <param name="hash">the hash result of the iterative hashing</param>
            <returns>The finalized hash value</returns>
        </member>
        <member name="M:Auki.Util.Hashing.KnuthIterateHash(System.Byte,System.UInt64)">
            <summary>
            Knut hashing, to be called iterative for each item you want to include in the hash.
            Ref: https://stackoverflow.com/questions/9545619/a-fast-hash-function-for-string-in-c-sharp
            </summary>
            <param name="nextValue">the next value to hash</param>
            <param name="prevHash">the previous hash result</param>
            <returns>The hashed value</returns>
        </member>
        <member name="T:Auki.Util.JsonConvertWrapper">
            <summary>
            Wraps JsonConvert deserialization with JsonSerializerSettings set to ignore null values.
            </summary>
        </member>
        <member name="M:Auki.Util.JsonConvertWrapper.DeserializeWhileMappingNullToDefault``1(System.String)">
            <summary>
            Wraps JSON deserialization that ignores any null values in the input string.
            </summary>
            <param name="json">JSON string to be deserialized</param>
            <returns>Deserialized object</returns>
        </member>
        <member name="M:Auki.Util.JsonConvertWrapper.SerializeObjectToBytes(System.Object)">
            <summary>
            Encodes given object as a JSON and then serializes it as a byte array.
            </summary>
            <param name="obj">Object to serialize</param>
            <returns>Byte array encoded object</returns>
        </member>
        <member name="M:Auki.Util.JsonConvertWrapper.DeserializeObjectFromBytes``1(System.Byte[])">
            <summary>
            Deserializes a byte array to a string and then parses it like a JSON.
            </summary>
            <param name="byteArray">Input byte array</param>
            <returns>Deserialized object</returns>
        </member>
        <member name="T:Auki.Util.NativeArrayView`1">
            <summary>
            NativeArray View interface constrained to read-only operation, which gives access to a partition of an existing NativeArray.
            This allows to provide a view on a portion of an existing NativeArray (as if it was a new separate array) without the
            need to copy it.
            </summary>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.#ctor(Unity.Collections.NativeArray{`0},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the NativeArrayView structure, providing read-only access to a NativeArray of a specified type.
            </summary>
            <param name="buffer">The NativeArray of type T to create a view from.</param>
            <param name="minIndex">The starting index within the NativeArray to begin the view.</param>
            <param name="length">The length of the view, constrained to this length but may be shorter than the provided NativeArray.</param>
        </member>
        <member name="P:Auki.Util.NativeArrayView`1.Count">
            <summary>
            Gets the number of elements in the view.
            </summary>
        </member>
        <member name="P:Auki.Util.NativeArrayView`1.Length">
            <summary>
            Gets the number of elements in the view.
            </summary>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.CopyTo(`0[])">
            <summary>
            Copies the elements from the view to a provided array, starting at the beginning of the array.
            </summary>
            <param name="array">The target array to copy elements to.</param>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.CopyTo(Unity.Collections.NativeArray{`0})">
            <summary>
            Copies the elements from the view to a provided NativeArray, starting at the beginning of the NativeArray.
            </summary>
            <param name="array">The target NativeArray to copy elements to.</param>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.ToArray">
            <summary>
            Converts the view to an array of the same type, copying the elements from the view to the new array.
            </summary>
            <returns>An array of type T containing the elements from the view.</returns>
        </member>
        <member name="P:Auki.Util.NativeArrayView`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index within the view.
            </summary>
            <param name="index">The index of the element to retrieve.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="P:Auki.Util.NativeArrayView`1.IsCreated">
            <summary>
            Gets a value indicating whether the associated NativeArray is created.
            </summary>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.GetEnumerator">
            <summary>
            Gets an enumerator for iterating through the elements in the view.
            </summary>
            <returns>An enumerator for iterating through the elements.</returns>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Gets an enumerator for iterating through the elements in the view.
            </summary>
            <returns>An enumerator for iterating through the elements.</returns>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for iterating through the elements in the view.
            </summary>
            <returns>An enumerator for iterating through the elements.</returns>
        </member>
        <member name="T:Auki.Util.NativeArrayView`1.Enumerator">
            <summary>
            A struct that provides an enumerator for the elements in the NativeArrayView.
            </summary>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.Enumerator.#ctor(Auki.Util.NativeArrayView{`0}@)">
            <summary>
            Initializes a new instance of the Enumerator struct.
            </summary>
            <param name="array">The NativeArrayView to enumerate over.</param>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.Enumerator.Dispose">
            <summary>
            Disposes of the Enumerator instance.
            </summary>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.Enumerator.MoveNext">
            <summary>
            Moves the enumerator to the next element in the view.
            </summary>
            <returns>True if the enumerator was successfully moved to the next element; otherwise, false.</returns>
        </member>
        <member name="M:Auki.Util.NativeArrayView`1.Enumerator.Reset">
            <summary>
            Resets the enumerator to its initial state.
            </summary>
        </member>
        <member name="P:Auki.Util.NativeArrayView`1.Enumerator.Current">
            <summary>
            Gets the value of the current element in the view.
            </summary>
        </member>
        <member name="T:Auki.Util.TextureDraw">
            <summary>
            A utility class for drawing shapes and lines on a Texture2D.
            </summary>
        </member>
        <member name="M:Auki.Util.TextureDraw.SetTarget(UnityEngine.Texture2D)">
            <summary>
            Sets the target Texture2D for drawing operations.
            </summary>
            <param name="texture">The target Texture2D to draw on.</param>
        </member>
        <member name="M:Auki.Util.TextureDraw.Clear">
            <summary>
            Clears the target Texture2D by setting all pixels to transparent.
            </summary>
        </member>
        <member name="M:Auki.Util.TextureDraw.DrawCross(UnityEngine.Vector2,System.Int32,UnityEngine.Color32)">
            <summary>
            Draws a cross shape at a specified position with a given length and color.
            </summary>
            <param name="pos">The position of the center of the cross.</param>
            <param name="length">The length of the cross arms.</param>
            <param name="color">The color of the cross.</param>
        </member>
        <member name="M:Auki.Util.TextureDraw.DrawCross(UnityEngine.Vector2Int,System.Int32,UnityEngine.Color32)">
            <summary>
            Draws a cross shape at a specified position with a given length and color.
            </summary>
            <param name="pos">The position of the center of the cross.</param>
            <param name="length">The length of the cross arms.</param>
            <param name="color">The color of the cross.</param>
        </member>
        <member name="M:Auki.Util.TextureDraw.DrawFilledRect(UnityEngine.Vector2Int,System.Int32,UnityEngine.Color32)">
            <summary>
            Draws a filled rectangle at a specified position with a given size and color.
            </summary>
            <param name="pos">The position of the center of the rectangle.</param>
            <param name="size">The size of the rectangle.</param>
            <param name="color">The color of the rectangle.</param>
        </member>
        <member name="M:Auki.Util.TextureDraw.DrawRect(UnityEngine.Vector2,System.Single,UnityEngine.Color32)">
            <summary>
            Draws an empty rectangle at a specified center position with a given size and color.
            </summary>
            <param name="center">The center position of the rectangle.</param>
            <param name="size">The size of the rectangle.</param>
            <param name="color">The color of the rectangle.</param>
        </member>
        <member name="M:Auki.Util.TextureDraw.SetPixel(UnityEngine.Vector2,UnityEngine.Color32)">
            <summary>
            Sets a single pixel at the specified position to the given color.
            </summary>
            <param name="pos">The position to set the pixel.</param>
            <param name="c">The color of the pixel.</param>
        </member>
        <member name="M:Auki.Util.TextureDraw.AddPixel(UnityEngine.Vector2,UnityEngine.Color,System.Single)">
            <summary>
            Adds a color with lerp to a pixel at the specified position.
            </summary>
            <param name="pos">The position to add the color.</param>
            <param name="c">The color to add.</param>
            <param name="lerp">The interpolation factor for the add operation.</param>
        </member>
        <member name="M:Auki.Util.TextureDraw.DrawHorizontalLine(UnityEngine.Vector2,System.Int32,UnityEngine.Color32)">
            <summary>
            Draws a horizontal line of a specified length starting from a position with the given color.
            </summary>
            <param name="pos">The starting position of the line.</param>
            <param name="length">The length of the line.</param>
            <param name="c">The color of the line.</param>
        </member>
        <member name="M:Auki.Util.TextureDraw.DrawVerticalLine(UnityEngine.Vector2Int,System.Int32,UnityEngine.Color32)">
            <summary>
            Draws a vertical line of a specified length starting from a position with the given color.
            </summary>
            <param name="pos">The starting position of the line.</param>
            <param name="length">The length of the line.</param>
            <param name="c">The color of the line.</param>
        </member>
        <member name="M:Auki.Util.TextureDraw.DrawLine(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Color32)">
            <summary>
            Draws a line from the starting point to the ending point with a specified color.
            </summary>
            <param name="start">The starting point of the line.</param>
            <param name="end">The ending point of the line.</param>
            <param name="color">The color of the line.</param>
        </member>
        <member name="T:Auki.Util.UnityWebRequestAwaiter">
            <summary>
            A custom awaiter for UnityWebRequestAsyncOperation, allowing asynchronous waiting for web requests.
            </summary>
        </member>
        <member name="M:Auki.Util.UnityWebRequestAwaiter.#ctor(UnityEngine.Networking.UnityWebRequestAsyncOperation)">
            <summary>
            Initializes a new instance of the UnityWebRequestAwaiter class with the provided async operation.
            </summary>
            <param name="asyncOp">The UnityWebRequestAsyncOperation to await.</param>
        </member>
        <member name="P:Auki.Util.UnityWebRequestAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the asynchronous operation is completed.
            </summary>
        </member>
        <member name="M:Auki.Util.UnityWebRequestAwaiter.GetResult">
            <summary>
            Gets the result of the asynchronous operation. This method is not used for UnityWebRequestAwaiter.
            </summary>
        </member>
        <member name="M:Auki.Util.UnityWebRequestAwaiter.OnCompleted(System.Action)">
            <summary>
            Registers the continuation callback to execute when the operation is completed.
            </summary>
            <param name="continuation">The callback action to execute upon completion.</param>
        </member>
        <member name="T:Auki.Util.ExtensionMethods">
            <summary>
            Contains extension methods for UnityWebRequestAsyncOperation to provide awaitable functionality.
            </summary>
        </member>
        <member name="M:Auki.Util.ExtensionMethods.GetAwaiter(UnityEngine.Networking.UnityWebRequestAsyncOperation)">
            <summary>
            Returns a UnityWebRequestAwaiter for the given UnityWebRequestAsyncOperation, allowing it to be awaited asynchronously.
            </summary>
            <param name="asyncOp">The UnityWebRequestAsyncOperation to be awaited.</param>
            <returns>A UnityWebRequestAwaiter for asynchronous waiting.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.ByteString">
            <summary>
            Immutable array of bytes.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.ByteString.Empty">
            <summary>
            Returns an empty ByteString.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.ByteString.Length">
            <summary>
            Returns the length of this ByteString in bytes.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.ByteString.IsEmpty">
            <summary>
            Returns <c>true</c> if this byte string is empty, <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.ToByteArray">
            <summary>
            Converts this <see cref="T:Auki.Util.Protobuf.ByteString" /> into a byte array.
            </summary>
            <remarks>The data is copied - changes to the returned array will not be reflected in this <c>ByteString</c>.</remarks>
            <returns>A byte array with the same data as this <c>ByteString</c>.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.ToBase64">
            <summary>
            Converts this <see cref="T:Auki.Util.Protobuf.ByteString" /> into a standard base64 representation.
            </summary>
            <returns>A base64 representation of this <c>ByteString</c>.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.FromBase64(System.String)">
            <summary>
            Constructs a <see cref="T:Auki.Util.Protobuf.ByteString" /> from the Base64 Encoded String.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.FromStream(System.IO.Stream)">
            <summary>
            Constructs a <see cref="T:Auki.Util.Protobuf.ByteString" /> from data in the given stream, synchronously.
            </summary>
            <remarks>If successful, <paramref name="stream" /> will be read completely, from the position
            at the start of the call.</remarks>
            <param name="stream">The stream to copy into a ByteString.</param>
            <returns>A ByteString with content read from the given stream.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.FromStreamAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Constructs a <see cref="T:Auki.Util.Protobuf.ByteString" /> from data in the given stream, asynchronously.
            </summary>
            <remarks>If successful, <paramref name="stream" /> will be read completely, from the position
            at the start of the call.</remarks>
            <param name="stream">The stream to copy into a ByteString.</param>
            <param name="cancellationToken">The cancellation token to use when reading from the stream, if any.</param>
            <returns>A ByteString with content read from the given stream.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.CopyFrom(System.Byte[])">
            <summary>
            Constructs a <see cref="T:Auki.Util.Protobuf.ByteString" /> from the given array. The contents
            are copied, so further modifications to the array will not
            be reflected in the returned ByteString.
            This method can also be invoked in <c>ByteString.CopyFrom(0xaa, 0xbb, ...)</c> form
            which is primarily useful for testing.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.CopyFrom(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Auki.Util.Protobuf.ByteString" /> from a portion of a byte array.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.CopyFrom(System.String,System.Text.Encoding)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.ByteString" /> by encoding the specified text with
            the given encoding.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.CopyFromUtf8(System.String)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.ByteString" /> by encoding the specified text in UTF-8.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.ByteString.Item(System.Int32)">
            <summary>
            Retuns the byte at the given index.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.ToString(System.Text.Encoding)">
            <summary>
            Converts this <see cref="T:Auki.Util.Protobuf.ByteString" /> into a string by applying the given encoding.
            </summary>
            <remarks>
            This method should only be used to convert binary data which was the result of encoding
            text with the given encoding.
            </remarks>
            <param name="encoding">The encoding to use to decode the binary data into text.</param>
            <returns>The result of decoding the binary data with the given decoding.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.ToStringUtf8">
            <summary>
            Converts this <see cref="T:Auki.Util.Protobuf.ByteString" /> into a string by applying the UTF-8 encoding.
            </summary>
            <remarks>
            This method should only be used to convert binary data which was the result of encoding
            text with UTF-8.
            </remarks>
            <returns>The result of decoding the binary data with the given decoding.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.GetEnumerator">
            <summary>
            Returns an iterator over the bytes in this <see cref="T:Auki.Util.Protobuf.ByteString" />.
            </summary>
            <returns>An iterator over the bytes in this object.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an iterator over the bytes in this <see cref="T:Auki.Util.Protobuf.ByteString" />.
            </summary>
            <returns>An iterator over the bytes in this object.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.CreateCodedInput">
            <summary>
            Creates a CodedInputStream from this ByteString's data.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.op_Equality(Auki.Util.Protobuf.ByteString,Auki.Util.Protobuf.ByteString)">
            <summary>
            Compares two byte strings for equality.
            </summary>
            <param name="lhs">The first byte string to compare.</param>
            <param name="rhs">The second byte string to compare.</param>
            <returns><c>true</c> if the byte strings are equal; false otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.op_Inequality(Auki.Util.Protobuf.ByteString,Auki.Util.Protobuf.ByteString)">
            <summary>
            Compares two byte strings for inequality.
            </summary>
            <param name="lhs">The first byte string to compare.</param>
            <param name="rhs">The second byte string to compare.</param>
            <returns><c>false</c> if the byte strings are equal; true otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.Equals(System.Object)">
            <summary>
            Compares this byte string with another object.
            </summary>
            <param name="obj">The object to compare this with.</param>
            <returns><c>true</c> if <paramref name="obj" /> refers to an equal <see cref="T:Auki.Util.Protobuf.ByteString" />; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.GetHashCode">
            <summary>
            Returns a hash code for this object. Two equal byte strings
            will return the same hash code.
            </summary>
            <returns>A hash code for this object.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.Equals(Auki.Util.Protobuf.ByteString)">
            <summary>
            Compares this byte string with another.
            </summary>
            <param name="other">The <see cref="T:Auki.Util.Protobuf.ByteString" /> to compare this with.</param>
            <returns><c>true</c> if <paramref name="other" /> refers to an equal byte string; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the entire byte array to the destination array provided at the offset specified.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ByteString.WriteTo(System.IO.Stream)">
            <summary>
            Writes the entire byte array to the provided stream
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.CodedInputStream">
            <summary>
            Reads and decodes protocol message fields.
            </summary>
            <remarks>
            <para>
            This class is generally used by generated code to read appropriate
            primitives from the stream. It effectively encapsulates the lowest
            levels of protocol buffer format.
            </para>
            <para>
            Repeated fields and map fields are not handled by this class; use <see cref="T:Auki.Util.Protobuf.Collections.RepeatedField`1" />
            and <see cref="T:Auki.Util.Protobuf.Collections.MapField`2" /> to serialize such fields.
            </para>
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.#ctor(System.Byte[])">
            <summary>
            Creates a new CodedInputStream reading data from the given byte array.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.CodedInputStream" /> that reads from the given byte array slice.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.CodedInputStream" /> reading data from the given stream, which will be disposed
            when the returned object is disposed.
            </summary>
            <param name="input">The stream to read from.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.CodedInputStream" /> reading data from the given stream.
            </summary>
            <param name="input">The stream to read from.</param>
            <param name="leaveOpen"><c>true</c> to leave <paramref name="input" /> open when the returned
            <c cref="T:Auki.Util.Protobuf.CodedInputStream" /> is disposed; <c>false</c> to dispose of the given stream when the
            returned object is disposed.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.CreateWithLimits(System.IO.Stream,System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Auki.Util.Protobuf.CodedInputStream" /> with the specified size and recursion limits, reading
            from an input stream.
            </summary>
            <remarks>
            This method exists separately from the constructor to reduce the number of constructor overloads.
            It is likely to be used considerably less frequently than the constructors, as the default limits
            are suitable for most use cases.
            </remarks>
            <param name="input">The input stream to read from</param>
            <param name="sizeLimit">The total limit of data to read from the stream.</param>
            <param name="recursionLimit">The maximum recursion depth to allow while reading.</param>
            <returns>A <c>CodedInputStream</c> reading from <paramref name="input" /> with the specified size
            and recursion limits.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.CodedInputStream.Position">
            <summary>
            Returns the current position in the input stream, or the position in the input buffer
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.CodedInputStream.SizeLimit">
            <summary>
            Returns the size limit for this stream.
            </summary>
            <remarks>
            This limit is applied when reading from the underlying stream, as a sanity check. It is
            not applied when reading from a byte array data source without an underlying stream.
            The default value is Int32.MaxValue.
            </remarks>
            <value>
            The size limit.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.CodedInputStream.RecursionLimit">
            <summary>
            Returns the recursion limit for this stream. This limit is applied whilst reading messages,
            to avoid maliciously-recursive data.
            </summary>
            <remarks>
            The default limit is 100.
            </remarks>
            <value>
            The recursion limit for this stream.
            </value>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.Dispose">
            <summary>
            Disposes of this instance, potentially closing any underlying stream.
            </summary>
            <remarks>
            As there is no flushing to perform here, disposing of a <see cref="T:Auki.Util.Protobuf.CodedInputStream" /> which
            was constructed with the <c>leaveOpen</c> option parameter set to <c>true</c> (or one which
            was constructed to read from a byte array) has no effect.
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.PeekTag">
            <summary>
            Peeks at the next field tag. This is like calling <see cref="M:Auki.Util.Protobuf.CodedInputStream.ReadTag" />, but the
            tag is not consumed. (So a subsequent call to <see cref="M:Auki.Util.Protobuf.CodedInputStream.ReadTag" /> will return the
            same value.)
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadTag">
            <summary>
            Reads a field tag, returning the tag of 0 for "end of stream".
            </summary>
            <remarks>
            If this method returns 0, it doesn't necessarily mean the end of all
            the data in this CodedInputStream; it may be the end of the logical stream
            for an embedded message, for example.
            </remarks>
            <returns>The next field tag, or 0 for end of stream. (0 is never a valid tag.)</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.SkipLastField">
            <summary>
            Skips the data for the field with the tag we've just read.
            This should be called directly after <see cref="M:Auki.Util.Protobuf.CodedInputStream.ReadTag" />, when
            the caller wishes to skip an unknown field.
            </summary>
            <remarks>
            This method throws <see cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException" /> if the last-read tag was an end-group tag.
            If a caller wishes to skip a group, they should skip the whole group, by calling this method after reading the
            start-group tag. This behavior allows callers to call this method on any field they don't understand, correctly
            resulting in an error if an end-group tag has not been paired with an earlier start-group tag.
            </remarks>
            <exception cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException">The last tag was an end-group tag</exception>
            <exception cref="T:System.InvalidOperationException">The last read operation read to the end of the logical stream</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadDouble">
            <summary>
            Reads a double field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadFloat">
            <summary>
            Reads a float field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadUInt64">
            <summary>
            Reads a uint64 field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadInt64">
            <summary>
            Reads an int64 field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadInt32">
            <summary>
            Reads an int32 field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadFixed64">
            <summary>
            Reads a fixed64 field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadFixed32">
            <summary>
            Reads a fixed32 field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadBool">
            <summary>
            Reads a bool field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadString">
            <summary>
            Reads a string field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadMessage(Auki.Util.Protobuf.IMessage)">
            <summary>
            Reads an embedded message field value from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadGroup(Auki.Util.Protobuf.IMessage)">
            <summary>
            Reads an embedded group field from the stream.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadBytes">
            <summary>
            Reads a bytes field value from the stream.
            </summary>   
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadUInt32">
            <summary>
            Reads a uint32 field value from the stream.
            </summary>   
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadEnum">
            <summary>
            Reads an enum field value from the stream.
            </summary>   
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadSFixed32">
            <summary>
            Reads an sfixed32 field value from the stream.
            </summary>   
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadSFixed64">
            <summary>
            Reads an sfixed64 field value from the stream.
            </summary>   
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadSInt32">
            <summary>
            Reads an sint32 field value from the stream.
            </summary>   
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadSInt64">
            <summary>
            Reads an sint64 field value from the stream.
            </summary>   
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.ReadLength">
            <summary>
            Reads a length for length-delimited data.
            </summary>
            <remarks>
            This is internally just reading a varint, but this method exists
            to make the calling code clearer.
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedInputStream.MaybeConsumeTag(System.UInt32)">
            <summary>
            Peeks at the next tag in the stream. If it matches <paramref name="tag" />,
            the tag is consumed and the method returns <c>true</c>; otherwise, the
            stream is left in the original position and the method returns <c>false</c>.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.CodedInputStream.IsAtEnd">
            <summary>
            Returns true if the stream has reached the end of the input. This is the
            case if either the end of the underlying input source has been reached or
            the stream has reached a limit created using PushLimit.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.CodedOutputStream">
            <summary>
            Encodes and writes protocol message fields.
            </summary>
            <remarks>
            <para>
            This class is generally used by generated code to write appropriate
            primitives to the stream. It effectively encapsulates the lowest
            levels of protocol buffer format. Unlike some other implementations,
            this does not include combined "write tag and value" methods. Generated
            code knows the exact byte representations of the tags they're going to write,
            so there's no need to re-encode them each time. Manually-written code calling
            this class should just call one of the <c>WriteTag</c> overloads before each value.
            </para>
            <para>
            Repeated fields and map fields are not handled by this class; use <c>RepeatedField&lt;T&gt;</c>
            and <c>MapField&lt;TKey, TValue&gt;</c> to serialize such fields.
            </para>
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeDoubleSize(System.Double)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            double field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeFloatSize(System.Single)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            float field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeUInt64Size(System.UInt64)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            uint64 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeInt64Size(System.Int64)">
            <summary>
            Computes the number of bytes that would be needed to encode an
            int64 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeInt32Size(System.Int32)">
            <summary>
            Computes the number of bytes that would be needed to encode an
            int32 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeFixed64Size(System.UInt64)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            fixed64 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeFixed32Size(System.UInt32)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            fixed32 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeBoolSize(System.Boolean)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            bool field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeStringSize(System.String)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            string field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeGroupSize(Auki.Util.Protobuf.IMessage)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            group field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeMessageSize(Auki.Util.Protobuf.IMessage)">
            <summary>
            Computes the number of bytes that would be needed to encode an
            embedded message field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeBytesSize(Auki.Util.Protobuf.ByteString)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            bytes field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeUInt32Size(System.UInt32)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            uint32 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeEnumSize(System.Int32)">
            <summary>
            Computes the number of bytes that would be needed to encode a
            enum field, including the tag. The caller is responsible for
            converting the enum value to its numeric value.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeSFixed32Size(System.Int32)">
            <summary>
            Computes the number of bytes that would be needed to encode an
            sfixed32 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeSFixed64Size(System.Int64)">
            <summary>
            Computes the number of bytes that would be needed to encode an
            sfixed64 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeSInt32Size(System.Int32)">
            <summary>
            Computes the number of bytes that would be needed to encode an
            sint32 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeSInt64Size(System.Int64)">
            <summary>
            Computes the number of bytes that would be needed to encode an
            sint64 field, including the tag.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeLengthSize(System.Int32)">
            <summary>
            Computes the number of bytes that would be needed to encode a length,
            as written by <see cref="M:Auki.Util.Protobuf.CodedOutputStream.WriteLength(System.Int32)" />.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeRawVarint32Size(System.UInt32)">
            <summary>
            Computes the number of bytes that would be needed to encode a varint.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeRawVarint64Size(System.UInt64)">
            <summary>
            Computes the number of bytes that would be needed to encode a varint.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.ComputeTagSize(System.Int32)">
            <summary>
            Computes the number of bytes that would be needed to encode a tag.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.CodedOutputStream.DefaultBufferSize">
            <summary>
            The buffer size used by CreateInstance(Stream).
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.#ctor(System.Byte[])">
            <summary>
            Creates a new CodedOutputStream that writes directly to the given
            byte array. If more bytes are written than fit in the array,
            OutOfSpaceException will be thrown.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.CodedOutputStream" /> which write to the given stream, and disposes of that
            stream when the returned <c>CodedOutputStream</c> is disposed.
            </summary>
            <param name="output">The stream to write to. It will be disposed when the returned <c>CodedOutputStream is disposed.</c></param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a new CodedOutputStream which write to the given stream and uses
            the specified buffer size.
            </summary>
            <param name="output">The stream to write to. It will be disposed when the returned <c>CodedOutputStream is disposed.</c></param>
            <param name="bufferSize">The size of buffer to use internally.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a new CodedOutputStream which write to the given stream.
            </summary>
            <param name="output">The stream to write to.</param>
            <param name="leaveOpen">If <c>true</c>, <paramref name="output" /> is left open when the returned <c>CodedOutputStream</c> is disposed;
            if <c>false</c>, the provided stream is disposed as well.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
            Creates a new CodedOutputStream which write to the given stream and uses
            the specified buffer size.
            </summary>
            <param name="output">The stream to write to.</param>
            <param name="bufferSize">The size of buffer to use internally.</param>
            <param name="leaveOpen">If <c>true</c>, <paramref name="output" /> is left open when the returned <c>CodedOutputStream</c> is disposed;
            if <c>false</c>, the provided stream is disposed as well.</param>
        </member>
        <member name="P:Auki.Util.Protobuf.CodedOutputStream.Position">
            <summary>
            Returns the current position in the stream, or the position in the output buffer
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteDouble(System.Double)">
            <summary>
            Writes a double field value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteFloat(System.Single)">
            <summary>
            Writes a float field value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteUInt64(System.UInt64)">
            <summary>
            Writes a uint64 field value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteInt64(System.Int64)">
            <summary>
            Writes an int64 field value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteInt32(System.Int32)">
            <summary>
            Writes an int32 field value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteFixed64(System.UInt64)">
            <summary>
            Writes a fixed64 field value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteFixed32(System.UInt32)">
            <summary>
            Writes a fixed32 field value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteBool(System.Boolean)">
            <summary>
            Writes a bool field value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteString(System.String)">
            <summary>
            Writes a string field value, without a tag, to the stream.
            The data is length-prefixed.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteMessage(Auki.Util.Protobuf.IMessage)">
            <summary>
            Writes a message, without a tag, to the stream.
            The data is length-prefixed.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteGroup(Auki.Util.Protobuf.IMessage)">
            <summary>
            Writes a group, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteBytes(Auki.Util.Protobuf.ByteString)">
            <summary>
            Write a byte string, without a tag, to the stream.
            The data is length-prefixed.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteUInt32(System.UInt32)">
            <summary>
            Writes a uint32 value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteEnum(System.Int32)">
            <summary>
            Writes an enum value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteSFixed32(System.Int32)">
            <summary>
            Writes an sfixed32 value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteSFixed64(System.Int64)">
            <summary>
            Writes an sfixed64 value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteSInt32(System.Int32)">
            <summary>
            Writes an sint32 value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteSInt64(System.Int64)">
            <summary>
            Writes an sint64 value, without a tag, to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteLength(System.Int32)">
            <summary>
            Writes a length (in bytes) for length-delimited data.
            </summary>
            <remarks>
            This method simply writes a rawint, but exists for clarity in calling code.
            </remarks>
            <param name="length">Length value, in bytes.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteTag(System.Int32,Auki.Util.Protobuf.WireFormat.WireType)">
            <summary>
            Encodes and writes a tag.
            </summary>
            <param name="fieldNumber">The number of the field to write the tag for</param>
            <param name="type">The wire format type of the tag to write</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteTag(System.UInt32)">
            <summary>
            Writes an already-encoded tag.
            </summary>
            <param name="tag">The encoded tag</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteRawTag(System.Byte)">
            <summary>
            Writes the given single-byte tag directly to the stream.
            </summary>
            <param name="b1">The encoded tag</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteRawTag(System.Byte,System.Byte)">
            <summary>
            Writes the given two-byte tag directly to the stream.
            </summary>
            <param name="b1">The first byte of the encoded tag</param>
            <param name="b2">The second byte of the encoded tag</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteRawTag(System.Byte,System.Byte,System.Byte)">
            <summary>
            Writes the given three-byte tag directly to the stream.
            </summary>
            <param name="b1">The first byte of the encoded tag</param>
            <param name="b2">The second byte of the encoded tag</param>
            <param name="b3">The third byte of the encoded tag</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteRawTag(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Writes the given four-byte tag directly to the stream.
            </summary>
            <param name="b1">The first byte of the encoded tag</param>
            <param name="b2">The second byte of the encoded tag</param>
            <param name="b3">The third byte of the encoded tag</param>
            <param name="b4">The fourth byte of the encoded tag</param>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.WriteRawTag(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Writes the given five-byte tag directly to the stream.
            </summary>
            <param name="b1">The first byte of the encoded tag</param>
            <param name="b2">The second byte of the encoded tag</param>
            <param name="b3">The third byte of the encoded tag</param>
            <param name="b4">The fourth byte of the encoded tag</param>
            <param name="b5">The fifth byte of the encoded tag</param>
        </member>
        <member name="T:Auki.Util.Protobuf.CodedOutputStream.OutOfSpaceException">
            <summary>
            Indicates that a CodedOutputStream wrapping a flat byte array
            ran out of space.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.Dispose">
            <summary>
            Flushes any buffered data and optionally closes the underlying stream, if any.
            </summary>
            <remarks>
            <para>
            By default, any underlying stream is closed by this method. To configure this behaviour,
            use a constructor overload with a <c>leaveOpen</c> parameter. If this instance does not
            have an underlying stream, this method does nothing.
            </para>
            <para>
            For the sake of efficiency, calling this method does not prevent future write calls - but
            if a later write ends up writing to a stream which has been disposed, that is likely to
            fail. It is recommend that you not call any other methods after this.
            </para>
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.Flush">
            <summary>
            Flushes any buffered data to the underlying stream (if there is one).
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.CodedOutputStream.CheckNoSpaceLeft">
            <summary>
            Verifies that SpaceLeft returns zero. It's common to create a byte array
            that is exactly big enough to hold a message, then write to it with
            a CodedOutputStream. Calling CheckNoSpaceLeft after writing verifies that
            the message was actually as big as expected, which can help bugs.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.CodedOutputStream.SpaceLeft">
            <summary>
            If writing to a flat array, returns the space left in the array. Otherwise,
            throws an InvalidOperationException.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Collections.Lists">
            <summary>
            Utility to compare if two Lists are the same, and the hash code
            of a List.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.Lists.Equals``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Checks if two lists are equal.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.Lists.GetHashCode``1(System.Collections.Generic.List{``0})">
            <summary>
            Gets the list's hash code.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Collections.MapField`2">
            <summary>
            Representation of a map field in a Protocol Buffer message.
            </summary>
            <typeparam name="TKey">Key type in the map. Must be a type supported by Protocol Buffer map keys.</typeparam>
            <typeparam name="TValue">Value type in the map. Must be a type supported by Protocol Buffers.</typeparam>
            <remarks>
            <para>
            For string keys, the equality comparison is provided by <see cref="P:System.StringComparer.Ordinal" />.
            </para>
            <para>
            Null values are not permitted in the map, either for wrapper types or regular messages.
            If a map is deserialized from a data stream and the value is missing from an entry, a default value
            is created instead. For primitive types, that is the regular default value (0, the empty string and so
            on); for message types, an empty instance of the message is created, as if the map entry contained a 0-length
            encoded value for the field.
            </para>
            <para>
            This implementation does not generally prohibit the use of key/value types which are not
            supported by Protocol Buffers (e.g. using a key type of <code>byte</code>) but nor does it guarantee
            that all operations will work in such cases.
            </para>
            <para>
            The order in which entries are returned when iterating over this object is undefined, and may change
            in future versions.
            </para>
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.Clone">
            <summary>
            Creates a deep clone of this object.
            </summary>
            <returns>
            A deep clone of this object.
            </returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.Add(`0,`1)">
            <summary>
            Adds the specified key/value pair to the map.
            </summary>
            <remarks>
            This operation fails if the key already exists in the map. To replace an existing entry, use the indexer.
            </remarks>
            <param name="key">The key to add</param>
            <param name="value">The value to add.</param>
            <exception cref="T:System.ArgumentException">The given key already exists in map.</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.ContainsKey(`0)">
            <summary>
            Determines whether the specified key is present in the map.
            </summary>
            <param name="key">The key to check.</param>
            <returns><c>true</c> if the map contains the given key; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.Remove(`0)">
            <summary>
            Removes the entry identified by the given key from the map.
            </summary>
            <param name="key">The key indicating the entry to remove from the map.</param>
            <returns><c>true</c> if the map contained the given key before the entry was removed; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found;
            otherwise, the default value for the type of the <paramref name="value" /> parameter.
            This parameter is passed uninitialized.</param>
            <returns><c>true</c> if the map contains an element with the specified key; otherwise, <c>false</c>.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and key does not exist in the collection.</exception>
            <returns>The value associated with the specified key. If the specified key is not found,
            a get operation throws a <see cref="T:System.Collections.Generic.KeyNotFoundException" />, and a set operation creates a new element with the specified key.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.Keys">
            <summary>
            Gets a collection containing the keys in the map.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.Values">
            <summary>
            Gets a collection containing the values in the map.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.Add(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Adds the specified entries to the map. The keys and values are not automatically cloned.
            </summary>
            <param name="entries">The entries to add to the map.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An enumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds the specified item to the map.
            </summary>
            <param name="item">The item to add to the map.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.Clear">
            <summary>
            Removes all items from the map.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether map contains an entry equivalent to the given key/value pair.
            </summary>
            <param name="item">The key/value pair to find.</param>
            <returns></returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the key/value pairs in this map to an array.
            </summary>
            <param name="array">The array to copy the entries into.</param>
            <param name="arrayIndex">The index of the array at which to start copying values.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes the specified key/value pair from the map.
            </summary>
            <remarks>Both the key and the value must be found for the entry to be removed.</remarks>
            <param name="item">The key/value pair to remove.</param>
            <returns><c>true</c> if the key/value pair was found and removed; <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.Count">
            <summary>
            Gets the number of elements contained in the map.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.IsReadOnly">
            <summary>
            Gets a value indicating whether the map is read-only.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.Equals(Auki.Util.Protobuf.Collections.MapField{`0,`1})">
            <summary>
            Compares this map with another for equality.
            </summary>
            <remarks>
            The order of the key/value pairs in the maps is not deemed significant in this comparison.
            </remarks>
            <param name="other">The map to compare this with.</param>
            <returns><c>true</c> if <paramref name="other" /> refers to an equal map; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.AddEntriesFrom(Auki.Util.Protobuf.CodedInputStream,Auki.Util.Protobuf.Collections.MapField{`0,`1}.Codec)">
            <summary>
            Adds entries to the map from the given stream.
            </summary>
            <remarks>
            It is assumed that the stream is initially positioned after the tag specified by the codec.
            This method will continue reading entries from the stream until the end is reached, or
            a different tag is encountered.
            </remarks>
            <param name="input">Stream to read from</param>
            <param name="codec">Codec describing how the key/value pairs are encoded</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.WriteTo(Auki.Util.Protobuf.CodedOutputStream,Auki.Util.Protobuf.Collections.MapField{`0,`1}.Codec)">
            <summary>
            Writes the contents of this map to the given coded output stream, using the specified codec
            to encode each entry.
            </summary>
            <param name="output">The output stream to write to.</param>
            <param name="codec">The codec to use for each entry.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.CalculateSize(Auki.Util.Protobuf.Collections.MapField{`0,`1}.Codec)">
            <summary>
            Calculates the size of this map based on the given entry codec.
            </summary>
            <param name="codec">The codec to use to encode each entry.</param>
            <returns></returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.ToString">
            <summary>
            Returns a string representation of this repeated field, in the same
            way as it would be represented by the default JSON formatter.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Collections.MapField`2.Codec">
            <summary>
            A codec for a specific map field. This contains all the information required to encode and
            decode the nested messages.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.Codec.#ctor(Auki.Util.Protobuf.FieldCodec{`0},Auki.Util.Protobuf.FieldCodec{`1},System.UInt32)">
            <summary>
            Creates a new entry codec based on a separate key codec and value codec,
            and the tag to use for each map entry.
            </summary>
            <param name="keyCodec">The key codec.</param>
            <param name="valueCodec">The value codec.</param>
            <param name="mapTag">The map tag to use to introduce each map entry.</param>
        </member>
        <member name="T:Auki.Util.Protobuf.Collections.ProtobufEqualityComparers">
            <summary>
            Provides a central place to implement equality comparisons, primarily for bitwise float/double equality.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.ProtobufEqualityComparers.GetEqualityComparer``1">
            <summary>
            Returns an equality comparer for <typeparamref name="T" /> suitable for Protobuf equality comparisons.
            This is usually just the default equality comparer for the type, but floating point numbers are compared
            bitwise.
            </summary>
            <typeparam name="T">The type of equality comparer to return.</typeparam>
            <returns>The equality comparer.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.ProtobufEqualityComparers.BitwiseDoubleEqualityComparer">
            <summary>
            Returns an equality comparer suitable for comparing 64-bit floating point values, by bitwise comparison.
            (NaN values are considered equal, but only when they have the same representation.)
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.ProtobufEqualityComparers.BitwiseSingleEqualityComparer">
            <summary>
            Returns an equality comparer suitable for comparing 32-bit floating point values, by bitwise comparison.
            (NaN values are considered equal, but only when they have the same representation.)
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer">
            <summary>
            Returns an equality comparer suitable for comparing nullable 64-bit floating point values, by bitwise comparison.
            (NaN values are considered equal, but only when they have the same representation.)
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.ProtobufEqualityComparers.BitwiseNullableSingleEqualityComparer">
            <summary>
            Returns an equality comparer suitable for comparing nullable 32-bit floating point values, by bitwise comparison.
            (NaN values are considered equal, but only when they have the same representation.)
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Collections.RepeatedField`1">
            <summary>
            The contents of a repeated field: essentially, a collection with some extra
            restrictions (no null values) and capabilities (deep cloning).
            </summary>
            <remarks>
            This implementation does not generally prohibit the use of types which are not
            supported by Protocol Buffers but nor does it guarantee that all operations will work in such cases.
            </remarks>
            <typeparam name="T">The element type of the repeated field.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.Clone">
            <summary>
            Creates a deep clone of this repeated field.
            </summary>
            <remarks>
            If the field type is
            a message type, each element is also cloned; otherwise, it is
            assumed that the field type is primitive (including string and
            bytes, both of which are immutable) and so a simple copy is
            equivalent to a deep clone.
            </remarks>
            <returns>A deep clone of this repeated field.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.AddEntriesFrom(Auki.Util.Protobuf.CodedInputStream,Auki.Util.Protobuf.FieldCodec{`0})">
            <summary>
            Adds the entries from the given input stream, decoding them with the specified codec.
            </summary>
            <param name="input">The input stream to read from.</param>
            <param name="codec">The codec to use in order to read each entry.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.CalculateSize(Auki.Util.Protobuf.FieldCodec{`0})">
            <summary>
            Calculates the size of this collection based on the given codec.
            </summary>
            <param name="codec">The codec to use when encoding each field.</param>
            <returns>The number of bytes that would be written to a <see cref="T:Auki.Util.Protobuf.CodedOutputStream" /> by <see cref="M:Auki.Util.Protobuf.Collections.RepeatedField`1.WriteTo(Auki.Util.Protobuf.CodedOutputStream,Auki.Util.Protobuf.FieldCodec{`0})" />,
            using the same codec.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.WriteTo(Auki.Util.Protobuf.CodedOutputStream,Auki.Util.Protobuf.FieldCodec{`0})">
            <summary>
            Writes the contents of this collection to the given <see cref="T:Auki.Util.Protobuf.CodedOutputStream" />,
            encoding each value using the specified codec.
            </summary>
            <param name="output">The output stream to write to.</param>
            <param name="codec">The codec to use when encoding each value.</param>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.RepeatedField`1.Capacity">
            <summary>
            Gets and sets the capacity of the RepeatedField's internal array.  WHen set, the internal array is reallocated to the given capacity.
            <exception cref="T:System.ArgumentOutOfRangeException">The new value is less than Count -or- when Count is less than 0.</exception>
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.Add(`0)">
            <summary>
            Adds the specified item to the collection.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.Clear">
            <summary>
            Removes all items from the collection.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.Contains(`0)">
            <summary>
            Determines whether this collection contains the given item.
            </summary>
            <param name="item">The item to find.</param>
            <returns><c>true</c> if this collection contains the given item; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies this collection to the given array.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The first index of the array to copy to.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.Remove(`0)">
            <summary>
            Removes the specified item from the collection
            </summary>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found and removed; <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.RepeatedField`1.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.RepeatedField`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the collection is read-only.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all of the specified values into this collection.
            </summary>
            <param name="values">The values to add to this collection.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all of the specified values into this collection. This method is present to
            allow repeated fields to be constructed from queries within collection initializers.
            Within non-collection-initializer code, consider using the equivalent <see cref="M:Auki.Util.Protobuf.Collections.RepeatedField`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
            method instead for clarity.
            </summary>
            <param name="values">The values to add to this collection.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An enumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.Equals(Auki.Util.Protobuf.Collections.RepeatedField{`0})">
            <summary>
            Compares this repeated field with another for equality.
            </summary>
            <param name="other">The repeated field to compare this with.</param>
            <returns><c>true</c> if <paramref name="other" /> refers to an equal repeated field; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.IndexOf(`0)">
            <summary>
            Returns the index of the given item within the collection, or -1 if the item is not
            present.
            </summary>
            <param name="item">The item to find in the collection.</param>
            <returns>The zero-based index of the item, or -1 if it is not found.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the given item at the specified index.
            </summary>
            <param name="index">The index at which to insert the item.</param>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.ToString">
            <summary>
            Returns a string representation of this repeated field, in the same
            way as it would be represented by the default JSON formatter.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.RepeatedField`1.Item(System.Int32)">
            <summary>
            Gets or sets the item at the specified index.
            </summary>
            <value>
            The element at the specified index.
            </value>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.Extension">
            <summary>
            Represents a non-generic extension definition. This API is experimental and subject to change.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Extension.#ctor(System.Int32)">
            <summary>
            Internal use. Creates a new extension with the specified field number.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Extension.FieldNumber">
            <summary>
            Gets the field number of this extension
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Extension`2">
            <summary>
            Represents a type-safe extension identifier used for getting and setting single extension values in <see cref="T:Auki.Util.Protobuf.IExtendableMessage`1" /> instances. 
            This API is experimental and subject to change.
            </summary>
            <typeparam name="TTarget">The message type this field applies to</typeparam>
            <typeparam name="TValue">The field value type of this extension</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.Extension`2.#ctor(System.Int32,Auki.Util.Protobuf.FieldCodec{`1})">
            <summary>
            Creates a new extension identifier with the specified field number and codec
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.RepeatedExtension`2">
            <summary>
            Represents a type-safe extension identifier used for getting repeated extension values in <see cref="T:Auki.Util.Protobuf.IExtendableMessage`1" /> instances.
            This API is experimental and subject to change.
            </summary>
            <typeparam name="TTarget">The message type this field applies to</typeparam>
            <typeparam name="TValue">The repeated field value type of this extension</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.RepeatedExtension`2.#ctor(System.Int32,Auki.Util.Protobuf.FieldCodec{`1})">
            <summary>
            Creates a new repeated extension identifier with the specified field number and codec
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.ExtensionRegistry">
            <summary>
            Provides extensions to messages while parsing. This API is experimental and subject to change.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.#ctor">
            <summary>
            Creates a new empty extension registry
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.ExtensionRegistry.Count">
            <summary>
            Gets the total number of extensions in this extension registry
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.ExtensionRegistry.System#Collections#Generic#ICollection{Auki#Util#Protobuf#Extension}#IsReadOnly">
            <summary>
            Returns whether the registry is readonly
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.Add(Auki.Util.Protobuf.Extension)">
            <summary>
            Adds the specified extension to the registry
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.AddRange(System.Collections.Generic.IEnumerable{Auki.Util.Protobuf.Extension})">
            <summary>
            Adds the specified extensions to the registry
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.Clear">
            <summary>
            Clears the registry of all values
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.Contains(Auki.Util.Protobuf.Extension)">
            <summary>
            Gets whether the extension registry contains the specified extension
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.System#Collections#Generic#ICollection{Auki#Util#Protobuf#Extension}#CopyTo(Auki.Util.Protobuf.Extension[],System.Int32)">
            <summary>
            Copies the arrays in the registry set to the specified array at the specified index
            </summary>
            <param name="array">The array to copy to</param>
            <param name="arrayIndex">The array index to start at</param>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.GetEnumerator">
            <summary>
            Returns an enumerator to enumerate through the items in the registry
            </summary>
            <returns>Returns an enumerator for the extensions in this registry</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.Remove(Auki.Util.Protobuf.Extension)">
            <summary>
            Removes the specified extension from the set
            </summary>
            <param name="item">The extension</param>
            <returns><c>true</c> if the extension was removed, otherwise <c>false</c></returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.Clone">
            <summary>
            Clones the registry into a new registry
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.ExtensionSet">
            <summary>
            Methods for managing <see cref="T:Auki.Util.Protobuf.ExtensionSet`1" />s with null checking.
            
            Most users will not use this class directly and its API is experimental and subject to change.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.Get``2(Auki.Util.Protobuf.ExtensionSet{``0}@,Auki.Util.Protobuf.Extension{``0,``1})">
            <summary>
            Gets the value of the specified extension
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.Get``2(Auki.Util.Protobuf.ExtensionSet{``0}@,Auki.Util.Protobuf.RepeatedExtension{``0,``1})">
            <summary>
            Gets the value of the specified repeated extension or null if it doesn't exist in this set
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.GetOrInitialize``2(Auki.Util.Protobuf.ExtensionSet{``0}@,Auki.Util.Protobuf.RepeatedExtension{``0,``1})">
            <summary>
            Gets the value of the specified repeated extension, registering it if it doesn't exist
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.Set``2(Auki.Util.Protobuf.ExtensionSet{``0}@,Auki.Util.Protobuf.Extension{``0,``1},``1)">
            <summary>
            Sets the value of the specified extension. This will make a new instance of ExtensionSet if the set is null.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.Has``2(Auki.Util.Protobuf.ExtensionSet{``0}@,Auki.Util.Protobuf.Extension{``0,``1})">
            <summary>
            Gets whether the value of the specified extension is set
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.Clear``2(Auki.Util.Protobuf.ExtensionSet{``0}@,Auki.Util.Protobuf.Extension{``0,``1})">
            <summary>
            Clears the value of the specified extension
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.Clear``2(Auki.Util.Protobuf.ExtensionSet{``0}@,Auki.Util.Protobuf.RepeatedExtension{``0,``1})">
            <summary>
            Clears the value of the specified extension
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.TryMergeFieldFrom``1(Auki.Util.Protobuf.ExtensionSet{``0}@,Auki.Util.Protobuf.CodedInputStream)">
            <summary>
            Tries to merge a field from the coded input, returning true if the field was merged.
            If the set is null or the field was not otherwise merged, this returns false.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.MergeFrom``1(Auki.Util.Protobuf.ExtensionSet{``0}@,Auki.Util.Protobuf.ExtensionSet{``0})">
            <summary>
            Merges the second set into the first set, creating a new instance if first is null
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet.Clone``1(Auki.Util.Protobuf.ExtensionSet{``0})">
            <summary>
            Clones the set into a new set. If the set is null, this returns null
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.ExtensionSet`1">
            <summary>
            Used for keeping track of extensions in messages. 
            <see cref="T:Auki.Util.Protobuf.IExtendableMessage`1" /> methods route to this set.
            
            Most users will not need to use this class directly
            </summary>
            <typeparam name="TTarget">The message type that extensions in this set target</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet`1.GetHashCode">
            <summary>
            Gets a hash code of the set
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet`1.Equals(System.Object)">
            <summary>
            Returns whether this set is equal to the other object
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet`1.CalculateSize">
            <summary>
            Calculates the size of this extension set
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionSet`1.WriteTo(Auki.Util.Protobuf.CodedOutputStream)">
            <summary>
            Writes the extension values in this set to the output stream
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.FieldCodec">
            <summary>
            Factory methods for <see cref="T:Auki.Util.Protobuf.FieldCodec`1" />.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForString(System.UInt32)">
            <summary>
            Retrieves a codec suitable for a string field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForBytes(System.UInt32)">
            <summary>
            Retrieves a codec suitable for a bytes field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForBool(System.UInt32)">
            <summary>
            Retrieves a codec suitable for a bool field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForInt32(System.UInt32)">
            <summary>
            Retrieves a codec suitable for an int32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForSInt32(System.UInt32)">
            <summary>
            Retrieves a codec suitable for an sint32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForFixed32(System.UInt32)">
            <summary>
            Retrieves a codec suitable for a fixed32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForSFixed32(System.UInt32)">
            <summary>
            Retrieves a codec suitable for an sfixed32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForUInt32(System.UInt32)">
            <summary>
            Retrieves a codec suitable for a uint32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForInt64(System.UInt32)">
            <summary>
            Retrieves a codec suitable for an int64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForSInt64(System.UInt32)">
            <summary>
            Retrieves a codec suitable for an sint64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForFixed64(System.UInt32)">
            <summary>
            Retrieves a codec suitable for a fixed64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForSFixed64(System.UInt32)">
            <summary>
            Retrieves a codec suitable for an sfixed64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForUInt64(System.UInt32)">
            <summary>
            Retrieves a codec suitable for a uint64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForFloat(System.UInt32)">
            <summary>
            Retrieves a codec suitable for a float field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForDouble(System.UInt32)">
            <summary>
            Retrieves a codec suitable for a double field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForEnum``1(System.UInt32,System.Func{``0,System.Int32},System.Func{System.Int32,``0})">
            <summary>
            Retrieves a codec suitable for an enum field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="toInt32">A conversion function from <see cref="T:System.Int32" /> to the enum type.</param>
            <param name="fromInt32">A conversion function from the enum type to <see cref="T:System.Int32" />.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForString(System.UInt32,System.String)">
            <summary>
            Retrieves a codec suitable for a string field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForBytes(System.UInt32,Auki.Util.Protobuf.ByteString)">
            <summary>
            Retrieves a codec suitable for a bytes field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForBool(System.UInt32,System.Boolean)">
            <summary>
            Retrieves a codec suitable for a bool field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForInt32(System.UInt32,System.Int32)">
            <summary>
            Retrieves a codec suitable for an int32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForSInt32(System.UInt32,System.Int32)">
            <summary>
            Retrieves a codec suitable for an sint32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForFixed32(System.UInt32,System.UInt32)">
            <summary>
            Retrieves a codec suitable for a fixed32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForSFixed32(System.UInt32,System.Int32)">
            <summary>
            Retrieves a codec suitable for an sfixed32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForUInt32(System.UInt32,System.UInt32)">
            <summary>
            Retrieves a codec suitable for a uint32 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForInt64(System.UInt32,System.Int64)">
            <summary>
            Retrieves a codec suitable for an int64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForSInt64(System.UInt32,System.Int64)">
            <summary>
            Retrieves a codec suitable for an sint64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForFixed64(System.UInt32,System.UInt64)">
            <summary>
            Retrieves a codec suitable for a fixed64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForSFixed64(System.UInt32,System.Int64)">
            <summary>
            Retrieves a codec suitable for an sfixed64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForUInt64(System.UInt32,System.UInt64)">
            <summary>
            Retrieves a codec suitable for a uint64 field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForFloat(System.UInt32,System.Single)">
            <summary>
            Retrieves a codec suitable for a float field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForDouble(System.UInt32,System.Double)">
            <summary>
            Retrieves a codec suitable for a double field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForEnum``1(System.UInt32,System.Func{``0,System.Int32},System.Func{System.Int32,``0},``0)">
            <summary>
            Retrieves a codec suitable for an enum field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="toInt32">A conversion function from <see cref="T:System.Int32" /> to the enum type.</param>
            <param name="fromInt32">A conversion function from the enum type to <see cref="T:System.Int32" />.</param>
            <param name="defaultValue">The default value.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForMessage``1(System.UInt32,Auki.Util.Protobuf.MessageParser{``0})">
            <summary>
            Retrieves a codec suitable for a message field with the given tag.
            </summary>
            <param name="tag">The tag.</param>
            <param name="parser">A parser to use for the message type.</param>
            <returns>A codec for the given tag.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForGroup``1(System.UInt32,System.UInt32,Auki.Util.Protobuf.MessageParser{``0})">
            <summary>
            Retrieves a codec suitable for a group field with the given tag.
            </summary>
            <param name="startTag">The start group tag.</param>
            <param name="endTag">The end group tag.</param>
            <param name="parser">A parser to use for the group message type.</param>
            <returns>A codec for given tag</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForClassWrapper``1(System.UInt32)">
            <summary>
            Creates a codec for a wrapper type of a class - which must be string or ByteString.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec.ForStructWrapper``1(System.UInt32)">
            <summary>
            Creates a codec for a wrapper type of a struct - which must be Int32, Int64, UInt32, UInt64,
            Bool, Single or Double.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.FieldCodec`1">
            <summary>
            <para>
            An encode/decode pair for a single field. This effectively encapsulates
            all the information needed to read or write the field value from/to a coded
            stream.
            </para>
            <para>
            This class is public and has to be as it is used by generated code, but its public
            API is very limited - just what the generated code needs to call directly.
            </para>
            </summary>
            <remarks>
            This never writes default values to the stream, and does not address "packedness"
            in repeated fields itself, other than to know whether or not the field *should* be packed.
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec`1.WriteTagAndValue(Auki.Util.Protobuf.CodedOutputStream,`0)">
            <summary>
            Write a tag and the given value, *if* the value is not the default.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec`1.Read(Auki.Util.Protobuf.CodedInputStream)">
            <summary>
            Reads a value of the codec type from the given <see cref="T:Auki.Util.Protobuf.CodedInputStream" />.
            </summary>
            <param name="input">The input stream to read from.</param>
            <returns>The value read from the stream.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.FieldCodec`1.CalculateSizeWithTag(`0)">
            <summary>
            Calculates the size required to write the given value, with a tag,
            if the value is not the default.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.ICustomDiagnosticMessage">
            <summary>
            A message type that has a custom string format for diagnostic purposes.
            </summary>
            <remarks>
            <para>
            Calling <see cref="M:System.Object.ToString" /> on a generated message type normally
            returns the JSON representation. If a message type implements this interface,
            then the <see cref="M:Auki.Util.Protobuf.ICustomDiagnosticMessage.ToDiagnosticString" /> method will be called instead of the regular
            JSON formatting code, but only when <c>ToString()</c> is called either on the message itself
            or on another message which contains it. This does not affect the normal JSON formatting of
            the message.
            </para>
            <para>
            For example, if you create a proto message representing a GUID, the internal
            representation may be a <c>bytes</c> field or four <c>fixed32</c> fields. However, when debugging
            it may be more convenient to see a result in the same format as <see cref="T:System.Guid" /> provides.
            </para>
            <para>This interface extends <see cref="T:Auki.Util.Protobuf.IMessage" /> to avoid it accidentally being implemented
            on types other than messages, where it would not be used by anything in the framework.</para>
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.ICustomDiagnosticMessage.ToDiagnosticString">
            <summary>
            Returns a string representation of this object, for diagnostic purposes.
            </summary>
            <remarks>
            This method is called when a message is formatted as part of a <see cref="M:System.Object.ToString" />
            call. It does not affect the JSON representation used by <see cref="T:Auki.Util.Protobuf.JsonFormatter" /> other than
            in calls to <see cref="M:Auki.Util.Protobuf.JsonFormatter.ToDiagnosticString(Auki.Util.Protobuf.IMessage)" />. While it is recommended
            that the result is valid JSON, this is never assumed by the Protobuf library.
            </remarks>
            <returns>A string representation of this object, for diagnostic purposes.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.IDeepCloneable`1">
            <summary>
            Generic interface for a deeply cloneable type.
            </summary>
            <remarks>
            <para>
            All generated messages implement this interface, but so do some non-message types.
            Additionally, due to the type constraint on <c>T</c> in <see cref="T:Auki.Util.Protobuf.IMessage`1" />,
            it is simpler to keep this as a separate interface.
            </para>
            </remarks>
            <typeparam name="T">The type itself, returned by the <see cref="M:Auki.Util.Protobuf.IDeepCloneable`1.Clone" /> method.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.IDeepCloneable`1.Clone">
            <summary>
            Creates a deep clone of this object.
            </summary>
            <returns>A deep clone of this object.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.IExtendableMessage`1">
            <summary>
            Generic interface for a Protocol Buffers message containing one or more extensions, where the type parameter is expected to be the same type as the implementation class.
            This interface is experiemental and is subject to change.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.IExtendableMessage`1.GetExtension``1(Auki.Util.Protobuf.Extension{`0,``0})">
            <summary>
            Gets the value of the specified extension
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.IExtendableMessage`1.GetExtension``1(Auki.Util.Protobuf.RepeatedExtension{`0,``0})">
            <summary>
            Gets the value of the specified repeated extension or null if the extension isn't registered in this set.
            For a version of this method that never returns null, use <see cref="M:Auki.Util.Protobuf.IExtendableMessage`1.GetOrInitializeExtension``1(Auki.Util.Protobuf.RepeatedExtension{`0,``0})" />
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.IExtendableMessage`1.GetOrInitializeExtension``1(Auki.Util.Protobuf.RepeatedExtension{`0,``0})">
            <summary>
            Gets the value of the specified repeated extension, registering it if it hasn't already been registered.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.IExtendableMessage`1.SetExtension``1(Auki.Util.Protobuf.Extension{`0,``0},``0)">
            <summary>
            Sets the value of the specified extension
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.IExtendableMessage`1.HasExtension``1(Auki.Util.Protobuf.Extension{`0,``0})">
            <summary>
            Gets whether the value of the specified extension is set
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.IExtendableMessage`1.ClearExtension``1(Auki.Util.Protobuf.Extension{`0,``0})">
            <summary>
            Clears the value of the specified extension
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.IExtendableMessage`1.ClearExtension``1(Auki.Util.Protobuf.RepeatedExtension{`0,``0})">
            <summary>
            Clears the value of the specified repeated extension
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.IMessage">
            <summary>
            Interface for a Protocol Buffers message, supporting
            basic operations required for serialization.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.IMessage.MergeFrom(Auki.Util.Protobuf.CodedInputStream)">
            <summary>
            Merges the data from the specified coded input stream with the current message.
            </summary>
            <remarks>See the user guide for precise merge semantics.</remarks>
            <param name="input"></param>
        </member>
        <member name="M:Auki.Util.Protobuf.IMessage.WriteTo(Auki.Util.Protobuf.CodedOutputStream)">
            <summary>
            Writes the data to the given coded output stream.
            </summary>
            <param name="output">Coded output stream to write the data to. Must not be null.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.IMessage.CalculateSize">
            <summary>
            Calculates the size of this message in Protocol Buffer wire format, in bytes.
            </summary>
            <returns>The number of bytes required to write this message
            to a coded output stream.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.IMessage.Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.IMessage`1">
            <summary>
            Generic interface for a Protocol Buffers message,
            where the type parameter is expected to be the same type as
            the implementation class.
            </summary>
            <typeparam name="T">The message type.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.IMessage`1.MergeFrom(`0)">
            <summary>
            Merges the given message into this one.
            </summary>
            <remarks>See the user guide for precise merge semantics.</remarks>
            <param name="message">The message to merge with this one. Must not be null.</param>
        </member>
        <member name="T:Auki.Util.Protobuf.InvalidJsonException">
            <summary>
            Thrown when an attempt is made to parse invalid JSON, e.g. using
            a non-string property key, or including a redundant comma. Parsing a protocol buffer
            message represented in JSON using <see cref="T:Auki.Util.Protobuf.JsonParser" /> can throw both this
            exception and <see cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException" /> depending on the situation. This
            exception is only thrown for "pure JSON" errors, whereas <c>InvalidProtocolBufferException</c>
            is thrown when the JSON may be valid in and of itself, but cannot be parsed as a protocol buffer
            message.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.InvalidProtocolBufferException">
            <summary>
            Thrown when a protocol message being parsed is invalid in some way,
            e.g. it contains a malformed varint or a negative byte length.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.JsonFormatter">
            <summary>
            Reflection-based converter from messages to JSON.
            </summary>
            <remarks>
            <para>
            Instances of this class are thread-safe, with no mutable state.
            </para>
            <para>
            This is a simple start to get JSON formatting working. As it's reflection-based,
            it's not as quick as baking calls into generated messages - but is a simpler implementation.
            (This code is generally not heavily optimized.)
            </para>
            </remarks>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonFormatter.Default">
            <summary>
            Returns a formatter using the default settings.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.#ctor(Auki.Util.Protobuf.JsonFormatter.Settings)">
            <summary>
            Creates a new formatted with the given settings.
            </summary>
            <param name="settings">The settings.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.Format(Auki.Util.Protobuf.IMessage)">
            <summary>
            Formats the specified message as JSON.
            </summary>
            <param name="message">The message to format.</param>
            <returns>The formatted message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.Format(Auki.Util.Protobuf.IMessage,System.IO.TextWriter)">
            <summary>
            Formats the specified message as JSON.
            </summary>
            <param name="message">The message to format.</param>
            <param name="writer">The TextWriter to write the formatted message to.</param>
            <returns>The formatted message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.ToDiagnosticString(Auki.Util.Protobuf.IMessage)">
            <summary>
            Converts a message to JSON for diagnostic purposes with no extra context.
            </summary>
            <remarks>
            <para>
            This differs from calling <see cref="M:Auki.Util.Protobuf.JsonFormatter.Format(Auki.Util.Protobuf.IMessage)" /> on the default JSON
            formatter in its handling of <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Any" />. As no type registry is available
            in <see cref="M:System.Object.ToString" /> calls, the normal way of resolving the type of
            an <c>Any</c> message cannot be applied. Instead, a JSON property named <c>@value</c>
            is included with the base64 data from the <see cref="P:Auki.Util.Protobuf.WellKnownTypes.Any.Value" /> property of the message.
            </para>
            <para>The value returned by this method is only designed to be used for diagnostic
            purposes. It may not be parsable by <see cref="T:Auki.Util.Protobuf.JsonParser" />, and may not be parsable
            by other Protocol Buffer implementations.</para>
            </remarks>
            <param name="message">The message to format for diagnostic purposes.</param>
            <returns>The diagnostic-only JSON representation of the message</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.WriteValue(System.IO.TextWriter,System.Object)">
            <summary>
            Writes a single value to the given writer as JSON. Only types understood by
            Protocol Buffers can be written in this way. This method is only exposed for
            advanced use cases; most users should be using <see cref="M:Auki.Util.Protobuf.JsonFormatter.Format(Auki.Util.Protobuf.IMessage)" />
            or <see cref="M:Auki.Util.Protobuf.JsonFormatter.Format(Auki.Util.Protobuf.IMessage,System.IO.TextWriter)" />.
            </summary>
            <param name="writer">The writer to write the value to. Must not be null.</param>
            <param name="value">The value to write. May be null.</param>
        </member>
        <member name="T:Auki.Util.Protobuf.JsonFormatter.Settings">
            <summary>
            Settings controlling JSON formatting.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonFormatter.Settings.Default">
            <summary>
            Default settings, as used by <see cref="P:Auki.Util.Protobuf.JsonFormatter.Default" />
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonFormatter.Settings.FormatDefaultValues">
            <summary>
            Whether fields whose values are the default for the field type (e.g. 0 for integers)
            should be formatted (true) or omitted (false).
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonFormatter.Settings.TypeRegistry">
            <summary>
            The type registry used to format <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Any" /> messages.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonFormatter.Settings.FormatEnumsAsIntegers">
            <summary>
            Whether to format enums as ints. Defaults to false.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.Settings.#ctor(System.Boolean)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonFormatter.Settings" /> object with the specified formatting of default values
            and an empty type registry.
            </summary>
            <param name="formatDefaultValues"><c>true</c> if default values (0, empty strings etc) should be formatted; <c>false</c> otherwise.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.Settings.#ctor(System.Boolean,Auki.Util.Protobuf.Reflection.TypeRegistry)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonFormatter.Settings" /> object with the specified formatting of default values
            and type registry.
            </summary>
            <param name="formatDefaultValues"><c>true</c> if default values (0, empty strings etc) should be formatted; <c>false</c> otherwise.</param>
            <param name="typeRegistry">The <see cref="P:Auki.Util.Protobuf.JsonFormatter.Settings.TypeRegistry" /> to use when formatting <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Any" /> messages.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.Settings.WithFormatDefaultValues(System.Boolean)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonFormatter.Settings" /> object with the specified formatting of default values and the current settings.
            </summary>
            <param name="formatDefaultValues"><c>true</c> if default values (0, empty strings etc) should be formatted; <c>false</c> otherwise.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.Settings.WithTypeRegistry(Auki.Util.Protobuf.Reflection.TypeRegistry)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonFormatter.Settings" /> object with the specified type registry and the current settings.
            </summary>
            <param name="typeRegistry">The <see cref="P:Auki.Util.Protobuf.JsonFormatter.Settings.TypeRegistry" /> to use when formatting <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Any" /> messages.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonFormatter.Settings.WithFormatEnumsAsIntegers(System.Boolean)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonFormatter.Settings" /> object with the specified enums formatting option and the current settings.
            </summary>
            <param name="formatEnumsAsIntegers"><c>true</c> to format the enums as integers; <c>false</c> to format enums as enum names.</param>
        </member>
        <member name="T:Auki.Util.Protobuf.JsonParser">
            <summary>
            Reflection-based converter from JSON to messages.
            </summary>
            <remarks>
            <para>
            Instances of this class are thread-safe, with no mutable state.
            </para>
            <para>
            This is a simple start to get JSON parsing working. As it's reflection-based,
            it's not as quick as baking calls into generated messages - but is a simpler implementation.
            (This code is generally not heavily optimized.)
            </para>
            </remarks>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonParser.Default">
            <summary>
            Returns a formatter using the default settings.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.#ctor(Auki.Util.Protobuf.JsonParser.Settings)">
            <summary>
            Creates a new formatted with the given settings.
            </summary>
            <param name="settings">The settings.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.Parse``1(System.String)">
            <summary>
            Parses <paramref name="json" /> into a new message.
            </summary>
            <typeparam name="T">The type of message to create.</typeparam>
            <param name="json">The JSON to parse.</param>
            <exception cref="T:Auki.Util.Protobuf.InvalidJsonException">The JSON does not comply with RFC 7159</exception>
            <exception cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException">The JSON does not represent a Protocol Buffers message correctly</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.Parse``1(System.IO.TextReader)">
            <summary>
            Parses JSON read from <paramref name="jsonReader" /> into a new message.
            </summary>
            <typeparam name="T">The type of message to create.</typeparam>
            <param name="jsonReader">Reader providing the JSON to parse.</param>
            <exception cref="T:Auki.Util.Protobuf.InvalidJsonException">The JSON does not comply with RFC 7159</exception>
            <exception cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException">The JSON does not represent a Protocol Buffers message correctly</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.Parse(System.String,Auki.Util.Protobuf.Reflection.MessageDescriptor)">
            <summary>
            Parses <paramref name="json" /> into a new message.
            </summary>
            <param name="json">The JSON to parse.</param>
            <param name="descriptor">Descriptor of message type to parse.</param>
            <exception cref="T:Auki.Util.Protobuf.InvalidJsonException">The JSON does not comply with RFC 7159</exception>
            <exception cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException">The JSON does not represent a Protocol Buffers message correctly</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.Parse(System.IO.TextReader,Auki.Util.Protobuf.Reflection.MessageDescriptor)">
            <summary>
            Parses JSON read from <paramref name="jsonReader" /> into a new message.
            </summary>
            <param name="jsonReader">Reader providing the JSON to parse.</param>
            <param name="descriptor">Descriptor of message type to parse.</param>
            <exception cref="T:Auki.Util.Protobuf.InvalidJsonException">The JSON does not comply with RFC 7159</exception>
            <exception cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException">The JSON does not represent a Protocol Buffers message correctly</exception>
        </member>
        <member name="T:Auki.Util.Protobuf.JsonParser.Settings">
            <summary>
            Settings controlling JSON parsing.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonParser.Settings.Default">
            <summary>
            Default settings, as used by <see cref="P:Auki.Util.Protobuf.JsonParser.Default" />. This has the same default
            recursion limit as <see cref="T:Auki.Util.Protobuf.CodedInputStream" />, and an empty type registry.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonParser.Settings.RecursionLimit">
            <summary>
            The maximum depth of messages to parse. Note that this limit only applies to parsing
            messages, not collections - so a message within a collection within a message only counts as
            depth 2, not 3.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonParser.Settings.TypeRegistry">
            <summary>
            The type registry used to parse <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Any" /> messages.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.JsonParser.Settings.IgnoreUnknownFields">
            <summary>
            Whether the parser should ignore unknown fields (<c>true</c>) or throw an exception when
            they are encountered (<c>false</c>).
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.Settings.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonParser.Settings" /> object with the specified recursion limit.
            </summary>
            <param name="recursionLimit">The maximum depth of messages to parse</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.Settings.#ctor(System.Int32,Auki.Util.Protobuf.Reflection.TypeRegistry)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonParser.Settings" /> object with the specified recursion limit and type registry.
            </summary>
            <param name="recursionLimit">The maximum depth of messages to parse</param>
            <param name="typeRegistry">The type registry used to parse <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Any" /> messages</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.Settings.WithIgnoreUnknownFields(System.Boolean)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonParser.Settings" /> object set to either ignore unknown fields, or throw an exception
            when unknown fields are encountered.
            </summary>
            <param name="ignoreUnknownFields"><c>true</c> if unknown fields should be ignored when parsing; <c>false</c> to throw an exception.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.Settings.WithRecursionLimit(System.Int32)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonParser.Settings" /> object based on this one, but with the specified recursion limit.
            </summary>
            <param name="recursionLimit">The new recursion limit.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.JsonParser.Settings.WithTypeRegistry(Auki.Util.Protobuf.Reflection.TypeRegistry)">
            <summary>
            Creates a new <see cref="T:Auki.Util.Protobuf.JsonParser.Settings" /> object based on this one, but with the specified type registry.
            </summary>
            <param name="typeRegistry">The new type registry. Must not be null.</param>
        </member>
        <member name="T:Auki.Util.Protobuf.MessageExtensions">
            <summary>
            Extension methods on <see cref="T:Auki.Util.Protobuf.IMessage" /> and <see cref="T:Auki.Util.Protobuf.IMessage`1" />.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.MergeFrom(Auki.Util.Protobuf.IMessage,System.Byte[])">
            <summary>
            Merges data from the given byte array into an existing message.
            </summary>
            <param name="message">The message to merge the data into.</param>
            <param name="data">The data to merge, which must be protobuf-encoded binary data.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.MergeFrom(Auki.Util.Protobuf.IMessage,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Merges data from the given byte array slice into an existing message.
            </summary>
            <param name="message">The message to merge the data into.</param>
            <param name="data">The data containing the slice to merge, which must be protobuf-encoded binary data.</param>
            <param name="offset">The offset of the slice to merge.</param>
            <param name="length">The length of the slice to merge.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.MergeFrom(Auki.Util.Protobuf.IMessage,Auki.Util.Protobuf.ByteString)">
            <summary>
            Merges data from the given byte string into an existing message.
            </summary>
            <param name="message">The message to merge the data into.</param>
            <param name="data">The data to merge, which must be protobuf-encoded binary data.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.MergeFrom(Auki.Util.Protobuf.IMessage,System.IO.Stream)">
            <summary>
            Merges data from the given stream into an existing message.
            </summary>
            <param name="message">The message to merge the data into.</param>
            <param name="input">Stream containing the data to merge, which must be protobuf-encoded binary data.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.MergeDelimitedFrom(Auki.Util.Protobuf.IMessage,System.IO.Stream)">
            <summary>
            Merges length-delimited data from the given stream into an existing message.
            </summary>
            <remarks>
            The stream is expected to contain a length and then the data. Only the amount of data
            specified by the length will be consumed.
            </remarks>
            <param name="message">The message to merge the data into.</param>
            <param name="input">Stream containing the data to merge, which must be protobuf-encoded binary data.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.ToByteArray(Auki.Util.Protobuf.IMessage)">
            <summary>
            Converts the given message into a byte array in protobuf encoding.
            </summary>
            <param name="message">The message to convert.</param>
            <returns>The message data as a byte array.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.WriteTo(Auki.Util.Protobuf.IMessage,System.IO.Stream)">
            <summary>
            Writes the given message data to the given stream in protobuf encoding.
            </summary>
            <param name="message">The message to write to the stream.</param>
            <param name="output">The stream to write to.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.WriteDelimitedTo(Auki.Util.Protobuf.IMessage,System.IO.Stream)">
            <summary>
            Writes the length and then data of the given message to a stream.
            </summary>
            <param name="message">The message to write.</param>
            <param name="output">The output stream to write to.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.ToByteString(Auki.Util.Protobuf.IMessage)">
            <summary>
            Converts the given message into a byte string in protobuf encoding.
            </summary>
            <param name="message">The message to convert.</param>
            <returns>The message data as a byte string.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageExtensions.IsInitialized(Auki.Util.Protobuf.IMessage)">
            <summary>
            Checks if all required fields in a message have values set. For proto3 messages, this returns true
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.MessageParser">
            <summary>
            A general message parser, typically used by reflection-based code as all the methods
            return simple <see cref="T:Auki.Util.Protobuf.IMessage" />.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser.ParseFrom(System.Byte[])">
            <summary>
            Parses a message from a byte array.
            </summary>
            <param name="data">The byte array containing the message. Must not be null.</param>
            <returns>The newly parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser.ParseFrom(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parses a message from a byte array slice.
            </summary>
            <param name="data">The byte array containing the message. Must not be null.</param>
            <param name="offset">The offset of the slice to parse.</param>
            <param name="length">The length of the slice to parse.</param>
            <returns>The newly parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser.ParseFrom(Auki.Util.Protobuf.ByteString)">
            <summary>
            Parses a message from the given byte string.
            </summary>
            <param name="data">The data to parse.</param>
            <returns>The parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser.ParseFrom(System.IO.Stream)">
            <summary>
            Parses a message from the given stream.
            </summary>
            <param name="input">The stream to parse.</param>
            <returns>The parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser.ParseDelimitedFrom(System.IO.Stream)">
            <summary>
            Parses a length-delimited message from the given stream.
            </summary>
            <remarks>
            The stream is expected to contain a length and then the data. Only the amount of data
            specified by the length will be consumed.
            </remarks>
            <param name="input">The stream to parse.</param>
            <returns>The parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser.ParseFrom(Auki.Util.Protobuf.CodedInputStream)">
            <summary>
            Parses a message from the given coded input stream.
            </summary>
            <param name="input">The stream to parse.</param>
            <returns>The parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser.ParseJson(System.String)">
            <summary>
            Parses a message from the given JSON.
            </summary>
            <param name="json">The JSON to parse.</param>
            <returns>The parsed message.</returns>
            <exception cref="T:Auki.Util.Protobuf.InvalidJsonException">The JSON does not comply with RFC 7159</exception>
            <exception cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException">The JSON does not represent a Protocol Buffers message correctly</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser.WithDiscardUnknownFields(System.Boolean)">
            <summary>
            Creates a new message parser which optionally discards unknown fields when parsing.
            </summary>
            <param name="discardUnknownFields">Whether or not to discard unknown fields when parsing.</param>
            <returns>A newly configured message parser.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser.WithExtensionRegistry(Auki.Util.Protobuf.ExtensionRegistry)">
            <summary>
            Creates a new message parser which registers extensions from the specified registry upon creating the message instance
            </summary>
            <param name="registry">The extensions to register</param>
            <returns>A newly configured message parser.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.MessageParser`1">
            <summary>
            A parser for a specific message type.
            </summary>
            <remarks>
            <p>
            This delegates most behavior to the
            <see cref="M:Auki.Util.Protobuf.IMessage.MergeFrom(Auki.Util.Protobuf.CodedInputStream)" /> implementation within the original type, but
            provides convenient overloads to parse from a variety of sources.
            </p>
            <p>
            Most applications will never need to create their own instances of this type;
            instead, use the static <c>Parser</c> property of a generated message type to obtain a
            parser for that type.
            </p>
            </remarks>
            <typeparam name="T">The type of message to be parsed.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.#ctor(System.Func{`0})">
            <summary>
            Creates a new parser.
            </summary>
            <remarks>
            The factory method is effectively an optimization over using a generic constraint
            to require a parameterless constructor: delegates are significantly faster to execute.
            </remarks>
            <param name="factory">Function to invoke when a new, empty message is required.</param>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.ParseFrom(System.Byte[])">
            <summary>
            Parses a message from a byte array.
            </summary>
            <param name="data">The byte array containing the message. Must not be null.</param>
            <returns>The newly parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.ParseFrom(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parses a message from a byte array slice.
            </summary>
            <param name="data">The byte array containing the message. Must not be null.</param>
            <param name="offset">The offset of the slice to parse.</param>
            <param name="length">The length of the slice to parse.</param>
            <returns>The newly parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.ParseFrom(Auki.Util.Protobuf.ByteString)">
            <summary>
            Parses a message from the given byte string.
            </summary>
            <param name="data">The data to parse.</param>
            <returns>The parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.ParseFrom(System.IO.Stream)">
            <summary>
            Parses a message from the given stream.
            </summary>
            <param name="input">The stream to parse.</param>
            <returns>The parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.ParseDelimitedFrom(System.IO.Stream)">
            <summary>
            Parses a length-delimited message from the given stream.
            </summary>
            <remarks>
            The stream is expected to contain a length and then the data. Only the amount of data
            specified by the length will be consumed.
            </remarks>
            <param name="input">The stream to parse.</param>
            <returns>The parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.ParseFrom(Auki.Util.Protobuf.CodedInputStream)">
            <summary>
            Parses a message from the given coded input stream.
            </summary>
            <param name="input">The stream to parse.</param>
            <returns>The parsed message.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.ParseJson(System.String)">
            <summary>
            Parses a message from the given JSON.
            </summary>
            <param name="json">The JSON to parse.</param>
            <returns>The parsed message.</returns>
            <exception cref="T:Auki.Util.Protobuf.InvalidJsonException">The JSON does not comply with RFC 7159</exception>
            <exception cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException">The JSON does not represent a Protocol Buffers message correctly</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.WithDiscardUnknownFields(System.Boolean)">
            <summary>
            Creates a new message parser which optionally discards unknown fields when parsing.
            </summary>
            <param name="discardUnknownFields">Whether or not to discard unknown fields when parsing.</param>
            <returns>A newly configured message parser.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.MessageParser`1.WithExtensionRegistry(Auki.Util.Protobuf.ExtensionRegistry)">
            <summary>
            Creates a new message parser which registers extensions from the specified registry upon creating the message instance
            </summary>
            <param name="registry">The extensions to register</param>
            <returns>A newly configured message parser.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.ProtoPreconditions">
            <summary>
            Helper methods for throwing exceptions when preconditions are not met.
            </summary>
            <remarks>
            This class is used internally and by generated code; it is not particularly
            expected to be used from application code, although nothing prevents it
            from being used that way.
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.ProtoPreconditions.CheckNotNull``1(``0,System.String)">
            <summary>
            Throws an ArgumentNullException if the given value is null, otherwise
            return the value to the caller.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.CustomOptions">
            <summary>
            Container for a set of custom options specified within a message, field etc.
            </summary>
            <remarks>
            <para>
            This type is publicly immutable, but internally mutable. It is only populated
            by the descriptor parsing code - by the time any user code is able to see an instance,
            it will be fully initialized.
            </para>
            <para>
            If an option is requested using the incorrect method, an answer may still be returned: all
            of the numeric types are represented internally using 64-bit integers, for example. It is up to
            the caller to ensure that they make the appropriate method call for the option they're interested in.
            Note that enum options are simply stored as integers, so the value should be fetched using
            <see cref="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetInt32(System.Int32,System.Int32@)" /> and then cast appropriately.
            </para>
            <para>
            Repeated options are currently not supported. Asking for a single value of an option
            which was actually repeated will return the last value, except for message types where
            all the set values are merged together.
            </para>
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetBool(System.Int32,System.Boolean@)">
            <summary>
            Retrieves a Boolean value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetInt32(System.Int32,System.Int32@)">
            <summary>
            Retrieves a signed 32-bit integer value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetInt64(System.Int32,System.Int64@)">
            <summary>
            Retrieves a signed 64-bit integer value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetFixed32(System.Int32,System.UInt32@)">
            <summary>
            Retrieves an unsigned 32-bit integer value for the specified option field,
            assuming a fixed-length representation.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetFixed64(System.Int32,System.UInt64@)">
            <summary>
            Retrieves an unsigned 64-bit integer value for the specified option field,
            assuming a fixed-length representation.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetSFixed32(System.Int32,System.Int32@)">
            <summary>
            Retrieves a signed 32-bit integer value for the specified option field,
            assuming a fixed-length representation.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetSFixed64(System.Int32,System.Int64@)">
            <summary>
            Retrieves a signed 64-bit integer value for the specified option field,
            assuming a fixed-length representation.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetSInt32(System.Int32,System.Int32@)">
            <summary>
            Retrieves a signed 32-bit integer value for the specified option field,
            assuming a zigzag encoding.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetSInt64(System.Int32,System.Int64@)">
            <summary>
            Retrieves a signed 64-bit integer value for the specified option field,
            assuming a zigzag encoding.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetUInt32(System.Int32,System.UInt32@)">
            <summary>
            Retrieves an unsigned 32-bit integer value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetUInt64(System.Int32,System.UInt64@)">
            <summary>
            Retrieves an unsigned 64-bit integer value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetFloat(System.Int32,System.Single@)">
            <summary>
            Retrieves a 32-bit floating point value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetDouble(System.Int32,System.Double@)">
            <summary>
            Retrieves a 64-bit floating point value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetString(System.Int32,System.String@)">
            <summary>
            Retrieves a string value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetBytes(System.Int32,Auki.Util.Protobuf.ByteString@)">
            <summary>
            Retrieves a bytes value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.CustomOptions.TryGetMessage``1(System.Int32,``0@)">
            <summary>
            Retrieves a message value for the specified option field.
            </summary>
            <param name="field">The field to fetch the value for.</param>
            <param name="value">The output variable to populate.</param>
            <returns><c>true</c> if a suitable value for the field was found; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.DescriptorReflection">
            <summary>Holder for reflection information generated from google/protobuf/descriptor.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorReflection.Descriptor">
            <summary>File descriptor for google/protobuf/descriptor.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FileDescriptorSet">
            <summary>
            The protocol compiler can output a FileDescriptorSet containing the .proto
            files it parses.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorSet.FileFieldNumber">
            <summary>Field number for the "file" field.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FileDescriptorProto">
            <summary>
            Describes a complete .proto file.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.Name">
            <summary>
            file name, relative to root of source tree
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptorProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.PackageFieldNumber">
            <summary>Field number for the "package" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.Package">
            <summary>
            e.g. "foo", "foo.bar", etc.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.HasPackage">
            <summary>Gets whether the "package" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptorProto.ClearPackage">
            <summary>Clears the value of the "package" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.DependencyFieldNumber">
            <summary>Field number for the "dependency" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.Dependency">
            <summary>
            Names of files imported by this file.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.PublicDependencyFieldNumber">
            <summary>Field number for the "public_dependency" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.PublicDependency">
            <summary>
            Indexes of the public imported files in the dependency list above.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.WeakDependencyFieldNumber">
            <summary>Field number for the "weak_dependency" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.WeakDependency">
            <summary>
            Indexes of the weak imported files in the dependency list.
            For Google-internal migration only. Do not use.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.MessageTypeFieldNumber">
            <summary>Field number for the "message_type" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.MessageType">
            <summary>
            All top-level definitions in this file.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.EnumTypeFieldNumber">
            <summary>Field number for the "enum_type" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.ServiceFieldNumber">
            <summary>Field number for the "service" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.ExtensionFieldNumber">
            <summary>Field number for the "extension" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.SourceCodeInfoFieldNumber">
            <summary>Field number for the "source_code_info" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.SourceCodeInfo">
            <summary>
            This field contains optional information about the original source code.
            You may safely remove this entire field without harming runtime
            functionality of the descriptors -- the information is needed only by
            development tools.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileDescriptorProto.SyntaxFieldNumber">
            <summary>Field number for the "syntax" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.Syntax">
            <summary>
            The syntax of the proto file.
            The supported values are "proto2" and "proto3".
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.HasSyntax">
            <summary>Gets whether the "syntax" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptorProto.ClearSyntax">
            <summary>Clears the value of the "syntax" field</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.DescriptorProto">
            <summary>
            Describes a message type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.DescriptorProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.FieldFieldNumber">
            <summary>Field number for the "field" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.ExtensionFieldNumber">
            <summary>Field number for the "extension" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.NestedTypeFieldNumber">
            <summary>Field number for the "nested_type" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.EnumTypeFieldNumber">
            <summary>Field number for the "enum_type" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.ExtensionRangeFieldNumber">
            <summary>Field number for the "extension_range" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.OneofDeclFieldNumber">
            <summary>Field number for the "oneof_decl" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.ReservedRangeFieldNumber">
            <summary>Field number for the "reserved_range" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.ReservedNameFieldNumber">
            <summary>Field number for the "reserved_name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.ReservedName">
            <summary>
            Reserved field names, which may not be used by fields in the same message.
            A given name may only be reserved once.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.DescriptorProto.Types">
            <summary>Container for nested types declared in the DescriptorProto message type.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.StartFieldNumber">
            <summary>Field number for the "start" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.Start">
            <summary>
            Inclusive.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.HasStart">
            <summary>Gets whether the "start" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.ClearStart">
            <summary>Clears the value of the "start" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.EndFieldNumber">
            <summary>Field number for the "end" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.End">
            <summary>
            Exclusive.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.HasEnd">
            <summary>Gets whether the "end" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.ClearEnd">
            <summary>Clears the value of the "end" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange">
            <summary>
            Range of reserved tag numbers. Reserved tag numbers may not be used by
            fields or extension ranges in the same message. Reserved ranges may
            not overlap.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange.StartFieldNumber">
            <summary>Field number for the "start" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange.Start">
            <summary>
            Inclusive.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange.HasStart">
            <summary>Gets whether the "start" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange.ClearStart">
            <summary>Clears the value of the "start" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange.EndFieldNumber">
            <summary>Field number for the "end" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange.End">
            <summary>
            Exclusive.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange.HasEnd">
            <summary>Gets whether the "end" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange.ClearEnd">
            <summary>Clears the value of the "end" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.ExtensionRangeOptions.UninterpretedOptionFieldNumber">
            <summary>Field number for the "uninterpreted_option" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ExtensionRangeOptions.UninterpretedOption">
            <summary>
            The parser stores options it doesn't recognize here. See above.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FieldDescriptorProto">
            <summary>
            Describes a field within a message.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.NumberFieldNumber">
            <summary>Field number for the "number" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasNumber">
            <summary>Gets whether the "number" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearNumber">
            <summary>Clears the value of the "number" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.LabelFieldNumber">
            <summary>Field number for the "label" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasLabel">
            <summary>Gets whether the "label" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearLabel">
            <summary>Clears the value of the "label" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Type">
            <summary>
            If type_name is set, this need not be set.  If both this and type_name
            are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasType">
            <summary>Gets whether the "type" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearType">
            <summary>Clears the value of the "type" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.TypeNameFieldNumber">
            <summary>Field number for the "type_name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.TypeName">
            <summary>
            For message and enum types, this is the name of the type.  If the name
            starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
            rules are used to find the type (i.e. first the nested types within this
            message are searched, then within the parent, on up to the root
            namespace).
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasTypeName">
            <summary>Gets whether the "type_name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearTypeName">
            <summary>Clears the value of the "type_name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ExtendeeFieldNumber">
            <summary>Field number for the "extendee" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Extendee">
            <summary>
            For extensions, this is the name of the type being extended.  It is
            resolved in the same manner as type_name.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasExtendee">
            <summary>Gets whether the "extendee" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearExtendee">
            <summary>Clears the value of the "extendee" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.DefaultValueFieldNumber">
            <summary>Field number for the "default_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.DefaultValue">
            <summary>
            For numeric types, contains the original text representation of the value.
            For booleans, "true" or "false".
            For strings, contains the default text contents (not escaped in any way).
            For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
            TODO(kenton):  Base-64 encode?
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasDefaultValue">
            <summary>Gets whether the "default_value" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearDefaultValue">
            <summary>Clears the value of the "default_value" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.OneofIndexFieldNumber">
            <summary>Field number for the "oneof_index" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.OneofIndex">
            <summary>
            If set, gives the index of a oneof in the containing type's oneof_decl
            list.  This field is a member of that oneof.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasOneofIndex">
            <summary>Gets whether the "oneof_index" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearOneofIndex">
            <summary>Clears the value of the "oneof_index" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.JsonNameFieldNumber">
            <summary>Field number for the "json_name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.JsonName">
            <summary>
            JSON name of this field. The value is set by protocol compiler. If the
            user has set a "json_name" option on this field, that option's value
            will be used. Otherwise, it's deduced from the field's name by converting
            it to camelCase.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasJsonName">
            <summary>Gets whether the "json_name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearJsonName">
            <summary>Clears the value of the "json_name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Proto3OptionalFieldNumber">
            <summary>Field number for the "proto3_optional" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Proto3Optional">
             <summary>
             If true, this is a proto3 "optional". When a proto3 field is optional, it
             tracks presence regardless of field type.
            
             When proto3_optional is true, this field must be belong to a oneof to
             signal to old proto3 clients that presence is tracked for this field. This
             oneof is known as a "synthetic" oneof, and this field must be its sole
             member (each proto3 optional field gets its own synthetic oneof). Synthetic
             oneofs exist in the descriptor only, and do not generate any API. Synthetic
             oneofs must be ordered after all "real" oneofs.
            
             For message fields, proto3_optional doesn't create any semantic change,
             since non-repeated message fields always track presence. However it still
             indicates the semantic detail of whether the user wrote "optional" or not.
             This can be useful for round-tripping the .proto file. For consistency we
             give message fields a synthetic oneof also, even though it is not required
             to track presence. This is especially important because the parser can't
             tell if a field is a message or an enum, so it must always create a
             synthetic oneof.
            
             Proto2 optional fields do not set this flag, because they already indicate
             optional with `LABEL_OPTIONAL`.
             </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.HasProto3Optional">
            <summary>Gets whether the "proto3_optional" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.ClearProto3Optional">
            <summary>Clears the value of the "proto3_optional" field</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types">
            <summary>Container for nested types declared in the FieldDescriptorProto message type.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types.Type.Double">
            <summary>
            0 is reserved for errors.
            Order is weird for historical reasons.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types.Type.Int64">
            <summary>
            Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
            negative values are likely.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types.Type.Int32">
            <summary>
            Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
            negative values are likely.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types.Type.Group">
            <summary>
            Tag-delimited aggregate.
            Group type is deprecated and not supported in proto3. However, Proto3
            implementations should still be able to parse the group wire format and
            treat group fields as unknown fields.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types.Type.Message">
            <summary>
            Length-delimited aggregate.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types.Type.Bytes">
            <summary>
            New in version 2.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types.Type.Sint32">
            <summary>
            Uses ZigZag encoding.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types.Type.Sint64">
            <summary>
            Uses ZigZag encoding.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Types.Label.Optional">
            <summary>
            0 is reserved for errors
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.OneofDescriptorProto">
            <summary>
            Describes a oneof.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.OneofDescriptorProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofDescriptorProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.OneofDescriptorProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.OneofDescriptorProto.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.EnumDescriptorProto">
            <summary>
            Describes an enum type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.ReservedRangeFieldNumber">
            <summary>Field number for the "reserved_range" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.ReservedRange">
            <summary>
            Range of reserved numeric values. Reserved numeric values may not be used
            by enum values in the same enum declaration. Reserved ranges may not
            overlap.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.ReservedNameFieldNumber">
            <summary>Field number for the "reserved_name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.ReservedName">
            <summary>
            Reserved enum value names, which may not be reused. A given name may only
            be reserved once.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types">
            <summary>Container for nested types declared in the EnumDescriptorProto message type.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange">
             <summary>
             Range of reserved numeric values. Reserved values may not be used by
             entries in the same enum. Reserved ranges may not overlap.
            
             Note that this is distinct from DescriptorProto.ReservedRange in that it
             is inclusive such that it can appropriately represent the entire int32
             domain.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange.StartFieldNumber">
            <summary>Field number for the "start" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange.Start">
            <summary>
            Inclusive.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange.HasStart">
            <summary>Gets whether the "start" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange.ClearStart">
            <summary>Clears the value of the "start" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange.EndFieldNumber">
            <summary>Field number for the "end" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange.End">
            <summary>
            Inclusive.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange.HasEnd">
            <summary>Gets whether the "end" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange.ClearEnd">
            <summary>Clears the value of the "end" field</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.EnumValueDescriptorProto">
            <summary>
            Describes a value within an enum.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumValueDescriptorProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueDescriptorProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumValueDescriptorProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumValueDescriptorProto.NumberFieldNumber">
            <summary>Field number for the "number" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueDescriptorProto.HasNumber">
            <summary>Gets whether the "number" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumValueDescriptorProto.ClearNumber">
            <summary>Clears the value of the "number" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumValueDescriptorProto.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.ServiceDescriptorProto">
            <summary>
            Describes a service.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.ServiceDescriptorProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ServiceDescriptorProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.ServiceDescriptorProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.ServiceDescriptorProto.MethodFieldNumber">
            <summary>Field number for the "method" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.ServiceDescriptorProto.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.MethodDescriptorProto">
            <summary>
            Describes a method of a service.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.InputTypeFieldNumber">
            <summary>Field number for the "input_type" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.InputType">
            <summary>
            Input and output type names.  These are resolved in the same way as
            FieldDescriptorProto.type_name, but must refer to a message type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.HasInputType">
            <summary>Gets whether the "input_type" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.ClearInputType">
            <summary>Clears the value of the "input_type" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.OutputTypeFieldNumber">
            <summary>Field number for the "output_type" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.HasOutputType">
            <summary>Gets whether the "output_type" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.ClearOutputType">
            <summary>Clears the value of the "output_type" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.ClientStreamingFieldNumber">
            <summary>Field number for the "client_streaming" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.ClientStreaming">
            <summary>
            Identifies if client streams multiple client messages
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.HasClientStreaming">
            <summary>Gets whether the "client_streaming" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.ClearClientStreaming">
            <summary>Clears the value of the "client_streaming" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.ServerStreamingFieldNumber">
            <summary>Field number for the "server_streaming" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.ServerStreaming">
            <summary>
            Identifies if server streams multiple server messages
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.HasServerStreaming">
            <summary>Gets whether the "server_streaming" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.ClearServerStreaming">
            <summary>Clears the value of the "server_streaming" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.JavaPackageFieldNumber">
            <summary>Field number for the "java_package" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.JavaPackage">
            <summary>
            Sets the Java package where classes generated from this .proto will be
            placed.  By default, the proto package is used, but this is often
            inappropriate because proto packages do not normally start with backwards
            domain names.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasJavaPackage">
            <summary>Gets whether the "java_package" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearJavaPackage">
            <summary>Clears the value of the "java_package" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.JavaOuterClassnameFieldNumber">
            <summary>Field number for the "java_outer_classname" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.JavaOuterClassname">
            <summary>
            If set, all the classes from the .proto file are wrapped in a single
            outer class with the given name.  This applies to both Proto1
            (equivalent to the old "--one_java_file" option) and Proto2 (where
            a .proto always translates to a single class, but you may want to
            explicitly choose the class name).
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasJavaOuterClassname">
            <summary>Gets whether the "java_outer_classname" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearJavaOuterClassname">
            <summary>Clears the value of the "java_outer_classname" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.JavaMultipleFilesFieldNumber">
            <summary>Field number for the "java_multiple_files" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.JavaMultipleFiles">
            <summary>
            If set true, then the Java code generator will generate a separate .java
            file for each top-level message, enum, and service defined in the .proto
            file.  Thus, these types will *not* be nested inside the outer class
            named by java_outer_classname.  However, the outer class will still be
            generated to contain the file's getDescriptor() method as well as any
            top-level extensions defined in the file.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasJavaMultipleFiles">
            <summary>Gets whether the "java_multiple_files" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearJavaMultipleFiles">
            <summary>Clears the value of the "java_multiple_files" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.JavaGenerateEqualsAndHashFieldNumber">
            <summary>Field number for the "java_generate_equals_and_hash" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.JavaGenerateEqualsAndHash">
            <summary>
            This option does nothing.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasJavaGenerateEqualsAndHash">
            <summary>Gets whether the "java_generate_equals_and_hash" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearJavaGenerateEqualsAndHash">
            <summary>Clears the value of the "java_generate_equals_and_hash" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.JavaStringCheckUtf8FieldNumber">
            <summary>Field number for the "java_string_check_utf8" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.JavaStringCheckUtf8">
            <summary>
            If set true, then the Java2 code generator will generate code that
            throws an exception whenever an attempt is made to assign a non-UTF-8
            byte sequence to a string field.
            Message reflection will do the same.
            However, an extension field still accepts non-UTF-8 byte sequences.
            This option has no effect on when used with the lite runtime.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasJavaStringCheckUtf8">
            <summary>Gets whether the "java_string_check_utf8" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearJavaStringCheckUtf8">
            <summary>Clears the value of the "java_string_check_utf8" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.OptimizeForFieldNumber">
            <summary>Field number for the "optimize_for" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasOptimizeFor">
            <summary>Gets whether the "optimize_for" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearOptimizeFor">
            <summary>Clears the value of the "optimize_for" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.GoPackageFieldNumber">
            <summary>Field number for the "go_package" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.GoPackage">
            <summary>
            Sets the Go package where structs generated from this .proto will be
            placed. If omitted, the Go package will be derived from the following:
              - The basename of the package import path, if provided.
              - Otherwise, the package statement in the .proto file, if present.
              - Otherwise, the basename of the .proto file, without extension.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasGoPackage">
            <summary>Gets whether the "go_package" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearGoPackage">
            <summary>Clears the value of the "go_package" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.CcGenericServicesFieldNumber">
            <summary>Field number for the "cc_generic_services" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.CcGenericServices">
             <summary>
             Should generic services be generated in each language?  "Generic" services
             are not specific to any particular RPC system.  They are generated by the
             main code generators in each language (without additional plugins).
             Generic services were the only kind of service generation supported by
             early versions of google.protobuf.
            
             Generic services are now considered deprecated in favor of using plugins
             that generate code specific to your particular RPC system.  Therefore,
             these default to false.  Old code which depends on generic services should
             explicitly set them to true.
             </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasCcGenericServices">
            <summary>Gets whether the "cc_generic_services" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearCcGenericServices">
            <summary>Clears the value of the "cc_generic_services" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.JavaGenericServicesFieldNumber">
            <summary>Field number for the "java_generic_services" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasJavaGenericServices">
            <summary>Gets whether the "java_generic_services" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearJavaGenericServices">
            <summary>Clears the value of the "java_generic_services" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.PyGenericServicesFieldNumber">
            <summary>Field number for the "py_generic_services" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasPyGenericServices">
            <summary>Gets whether the "py_generic_services" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearPyGenericServices">
            <summary>Clears the value of the "py_generic_services" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.PhpGenericServicesFieldNumber">
            <summary>Field number for the "php_generic_services" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasPhpGenericServices">
            <summary>Gets whether the "php_generic_services" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearPhpGenericServices">
            <summary>Clears the value of the "php_generic_services" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.DeprecatedFieldNumber">
            <summary>Field number for the "deprecated" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.Deprecated">
            <summary>
            Is this file deprecated?
            Depending on the target platform, this can emit Deprecated annotations
            for everything in the file, or it will be completely ignored; in the very
            least, this is a formalization for deprecating files.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasDeprecated">
            <summary>Gets whether the "deprecated" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearDeprecated">
            <summary>Clears the value of the "deprecated" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.CcEnableArenasFieldNumber">
            <summary>Field number for the "cc_enable_arenas" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.CcEnableArenas">
            <summary>
            Enables the use of arenas for the proto messages in this file. This applies
            only to generated classes for C++.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasCcEnableArenas">
            <summary>Gets whether the "cc_enable_arenas" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearCcEnableArenas">
            <summary>Clears the value of the "cc_enable_arenas" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.ObjcClassPrefixFieldNumber">
            <summary>Field number for the "objc_class_prefix" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.ObjcClassPrefix">
            <summary>
            Sets the objective c class prefix which is prepended to all objective c
            generated classes from this .proto. There is no default.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasObjcClassPrefix">
            <summary>Gets whether the "objc_class_prefix" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearObjcClassPrefix">
            <summary>Clears the value of the "objc_class_prefix" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.CsharpNamespaceFieldNumber">
            <summary>Field number for the "csharp_namespace" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.CsharpNamespace">
            <summary>
            Namespace for generated classes; defaults to the package.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasCsharpNamespace">
            <summary>Gets whether the "csharp_namespace" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearCsharpNamespace">
            <summary>Clears the value of the "csharp_namespace" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.SwiftPrefixFieldNumber">
            <summary>Field number for the "swift_prefix" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.SwiftPrefix">
            <summary>
            By default Swift generators will take the proto package and CamelCase it
            replacing '.' with underscore and use that to prefix the types/symbols
            defined. When this options is provided, they will use this value instead
            to prefix the types/symbols defined.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasSwiftPrefix">
            <summary>Gets whether the "swift_prefix" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearSwiftPrefix">
            <summary>Clears the value of the "swift_prefix" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.PhpClassPrefixFieldNumber">
            <summary>Field number for the "php_class_prefix" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.PhpClassPrefix">
            <summary>
            Sets the php class prefix which is prepended to all php generated classes
            from this .proto. Default is empty.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasPhpClassPrefix">
            <summary>Gets whether the "php_class_prefix" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearPhpClassPrefix">
            <summary>Clears the value of the "php_class_prefix" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.PhpNamespaceFieldNumber">
            <summary>Field number for the "php_namespace" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.PhpNamespace">
            <summary>
            Use this option to change the namespace of php generated classes. Default
            is empty. When this option is empty, the package name will be used for
            determining the namespace.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasPhpNamespace">
            <summary>Gets whether the "php_namespace" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearPhpNamespace">
            <summary>Clears the value of the "php_namespace" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.PhpMetadataNamespaceFieldNumber">
            <summary>Field number for the "php_metadata_namespace" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.PhpMetadataNamespace">
            <summary>
            Use this option to change the namespace of php generated metadata classes.
            Default is empty. When this option is empty, the proto file name will be
            used for determining the namespace.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasPhpMetadataNamespace">
            <summary>Gets whether the "php_metadata_namespace" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearPhpMetadataNamespace">
            <summary>Clears the value of the "php_metadata_namespace" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.RubyPackageFieldNumber">
            <summary>Field number for the "ruby_package" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.RubyPackage">
            <summary>
            Use this option to change the package of ruby generated classes. Default
            is empty. When this option is not set, the package name will be used for
            determining the ruby package.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.HasRubyPackage">
            <summary>Gets whether the "ruby_package" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileOptions.ClearRubyPackage">
            <summary>Clears the value of the "ruby_package" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.UninterpretedOptionFieldNumber">
            <summary>Field number for the "uninterpreted_option" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.UninterpretedOption">
            <summary>
            The parser stores options it doesn't recognize here.
            See the documentation for the "Options" section above.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FileOptions.Types">
            <summary>Container for nested types declared in the FileOptions message type.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FileOptions.Types.OptimizeMode">
            <summary>
            Generated classes can be optimized for speed or code size.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.Types.OptimizeMode.Speed">
            <summary>
            Generate complete code for parsing, serialization,
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.Types.OptimizeMode.CodeSize">
            <summary>
            etc.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FileOptions.Types.OptimizeMode.LiteRuntime">
            <summary>
            Generate code using MessageLite and the lite runtime.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MessageOptions.MessageSetWireFormatFieldNumber">
            <summary>Field number for the "message_set_wire_format" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.MessageSetWireFormat">
             <summary>
             Set true to use the old proto1 MessageSet wire format for extensions.
             This is provided for backwards-compatibility with the MessageSet wire
             format.  You should not use this for any other reason:  It's less
             efficient, has fewer features, and is more complicated.
            
             The message must be defined exactly as follows:
               message Foo {
                 option message_set_wire_format = true;
                 extensions 4 to max;
               }
             Note that the message cannot have any defined fields; MessageSets only
             have extensions.
            
             All extensions of your type must be singular messages; e.g. they cannot
             be int32s, enums, or repeated messages.
            
             Because this is an option, the above two restrictions are not enforced by
             the protocol compiler.
             </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.HasMessageSetWireFormat">
            <summary>Gets whether the "message_set_wire_format" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageOptions.ClearMessageSetWireFormat">
            <summary>Clears the value of the "message_set_wire_format" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MessageOptions.NoStandardDescriptorAccessorFieldNumber">
            <summary>Field number for the "no_standard_descriptor_accessor" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.NoStandardDescriptorAccessor">
            <summary>
            Disables the generation of the standard "descriptor()" accessor, which can
            conflict with a field of the same name.  This is meant to make migration
            from proto1 easier; new code should avoid fields named "descriptor".
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.HasNoStandardDescriptorAccessor">
            <summary>Gets whether the "no_standard_descriptor_accessor" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageOptions.ClearNoStandardDescriptorAccessor">
            <summary>Clears the value of the "no_standard_descriptor_accessor" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MessageOptions.DeprecatedFieldNumber">
            <summary>Field number for the "deprecated" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.Deprecated">
            <summary>
            Is this message deprecated?
            Depending on the target platform, this can emit Deprecated annotations
            for the message, or it will be completely ignored; in the very least,
            this is a formalization for deprecating messages.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.HasDeprecated">
            <summary>Gets whether the "deprecated" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageOptions.ClearDeprecated">
            <summary>Clears the value of the "deprecated" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MessageOptions.MapEntryFieldNumber">
            <summary>Field number for the "map_entry" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.MapEntry">
             <summary>
             Whether the message is an automatically generated map entry type for the
             maps field.
            
             For maps fields:
                 map&lt;KeyType, ValueType&gt; map_field = 1;
             The parsed descriptor looks like:
                 message MapFieldEntry {
                     option map_entry = true;
                     optional KeyType key = 1;
                     optional ValueType value = 2;
                 }
                 repeated MapFieldEntry map_field = 1;
            
             Implementations may choose not to generate the map_entry=true message, but
             use a native map in the target language to hold the keys and values.
             The reflection APIs in such implementations still need to work as
             if the field is a repeated message field.
            
             NOTE: Do not set the option in .proto files. Always use the maps syntax
             instead. The option should only be implicitly set by the proto compiler
             parser.
             </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.HasMapEntry">
            <summary>Gets whether the "map_entry" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageOptions.ClearMapEntry">
            <summary>Clears the value of the "map_entry" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MessageOptions.UninterpretedOptionFieldNumber">
            <summary>Field number for the "uninterpreted_option" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.UninterpretedOption">
            <summary>
            The parser stores options it doesn't recognize here. See above.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.CtypeFieldNumber">
            <summary>Field number for the "ctype" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.Ctype">
            <summary>
            The ctype option instructs the C++ code generator to use a different
            representation of the field than it normally would.  See the specific
            options below.  This option is not yet implemented in the open source
            release -- sorry, we'll try to include it in a future version!
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.HasCtype">
            <summary>Gets whether the "ctype" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldOptions.ClearCtype">
            <summary>Clears the value of the "ctype" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.PackedFieldNumber">
            <summary>Field number for the "packed" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.Packed">
            <summary>
            The packed option can be enabled for repeated primitive fields to enable
            a more efficient representation on the wire. Rather than repeatedly
            writing the tag and type for each element, the entire array is encoded as
            a single length-delimited blob. In proto3, only explicit setting it to
            false will avoid using packed encoding.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.HasPacked">
            <summary>Gets whether the "packed" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldOptions.ClearPacked">
            <summary>Clears the value of the "packed" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.JstypeFieldNumber">
            <summary>Field number for the "jstype" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.Jstype">
             <summary>
             The jstype option determines the JavaScript type used for values of the
             field.  The option is permitted only for 64 bit integral and fixed types
             (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
             is represented as JavaScript string, which avoids loss of precision that
             can happen when a large value is converted to a floating point JavaScript.
             Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
             use the JavaScript "number" type.  The behavior of the default option
             JS_NORMAL is implementation dependent.
            
             This option is an enum to permit additional types to be added, e.g.
             goog.math.Integer.
             </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.HasJstype">
            <summary>Gets whether the "jstype" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldOptions.ClearJstype">
            <summary>Clears the value of the "jstype" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.LazyFieldNumber">
            <summary>Field number for the "lazy" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.Lazy">
             <summary>
             Should this field be parsed lazily?  Lazy applies only to message-type
             fields.  It means that when the outer message is initially parsed, the
             inner message's contents will not be parsed but instead stored in encoded
             form.  The inner message will actually be parsed when it is first accessed.
            
             This is only a hint.  Implementations are free to choose whether to use
             eager or lazy parsing regardless of the value of this option.  However,
             setting this option true suggests that the protocol author believes that
             using lazy parsing on this field is worth the additional bookkeeping
             overhead typically needed to implement it.
            
             This option does not affect the public interface of any generated code;
             all method signatures remain the same.  Furthermore, thread-safety of the
             interface is not affected by this option; const methods remain safe to
             call from multiple threads concurrently, while non-const methods continue
             to require exclusive access.
            
             Note that implementations may choose not to check required fields within
             a lazy sub-message.  That is, calling IsInitialized() on the outer message
             may return true even if the inner message has missing required fields.
             This is necessary because otherwise the inner message would have to be
             parsed in order to perform the check, defeating the purpose of lazy
             parsing.  An implementation which chooses not to check required fields
             must be consistent about it.  That is, for any particular sub-message, the
             implementation must either *always* check its required fields, or *never*
             check its required fields, regardless of whether or not the message has
             been parsed.
             </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.HasLazy">
            <summary>Gets whether the "lazy" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldOptions.ClearLazy">
            <summary>Clears the value of the "lazy" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.DeprecatedFieldNumber">
            <summary>Field number for the "deprecated" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.Deprecated">
            <summary>
            Is this field deprecated?
            Depending on the target platform, this can emit Deprecated annotations
            for accessors, or it will be completely ignored; in the very least, this
            is a formalization for deprecating fields.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.HasDeprecated">
            <summary>Gets whether the "deprecated" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldOptions.ClearDeprecated">
            <summary>Clears the value of the "deprecated" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.WeakFieldNumber">
            <summary>Field number for the "weak" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.Weak">
            <summary>
            For Google-internal migration only. Do not use.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.HasWeak">
            <summary>Gets whether the "weak" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldOptions.ClearWeak">
            <summary>Clears the value of the "weak" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.UninterpretedOptionFieldNumber">
            <summary>Field number for the "uninterpreted_option" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.UninterpretedOption">
            <summary>
            The parser stores options it doesn't recognize here. See above.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FieldOptions.Types">
            <summary>Container for nested types declared in the FieldOptions message type.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.Types.CType.String">
            <summary>
            Default mode.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.Types.JSType.JsNormal">
            <summary>
            Use the default type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.Types.JSType.JsString">
            <summary>
            Use JavaScript strings.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldOptions.Types.JSType.JsNumber">
            <summary>
            Use JavaScript numbers.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.OneofOptions.UninterpretedOptionFieldNumber">
            <summary>Field number for the "uninterpreted_option" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofOptions.UninterpretedOption">
            <summary>
            The parser stores options it doesn't recognize here. See above.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumOptions.AllowAliasFieldNumber">
            <summary>Field number for the "allow_alias" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumOptions.AllowAlias">
            <summary>
            Set this option to true to allow mapping different tag names to the same
            value.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumOptions.HasAllowAlias">
            <summary>Gets whether the "allow_alias" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumOptions.ClearAllowAlias">
            <summary>Clears the value of the "allow_alias" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumOptions.DeprecatedFieldNumber">
            <summary>Field number for the "deprecated" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumOptions.Deprecated">
            <summary>
            Is this enum deprecated?
            Depending on the target platform, this can emit Deprecated annotations
            for the enum, or it will be completely ignored; in the very least, this
            is a formalization for deprecating enums.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumOptions.HasDeprecated">
            <summary>Gets whether the "deprecated" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumOptions.ClearDeprecated">
            <summary>Clears the value of the "deprecated" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumOptions.UninterpretedOptionFieldNumber">
            <summary>Field number for the "uninterpreted_option" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumOptions.UninterpretedOption">
            <summary>
            The parser stores options it doesn't recognize here. See above.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumValueOptions.DeprecatedFieldNumber">
            <summary>Field number for the "deprecated" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueOptions.Deprecated">
            <summary>
            Is this enum value deprecated?
            Depending on the target platform, this can emit Deprecated annotations
            for the enum value, or it will be completely ignored; in the very least,
            this is a formalization for deprecating enum values.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueOptions.HasDeprecated">
            <summary>Gets whether the "deprecated" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumValueOptions.ClearDeprecated">
            <summary>Clears the value of the "deprecated" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.EnumValueOptions.UninterpretedOptionFieldNumber">
            <summary>Field number for the "uninterpreted_option" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueOptions.UninterpretedOption">
            <summary>
            The parser stores options it doesn't recognize here. See above.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.ServiceOptions.DeprecatedFieldNumber">
            <summary>Field number for the "deprecated" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ServiceOptions.Deprecated">
            <summary>
            Is this service deprecated?
            Depending on the target platform, this can emit Deprecated annotations
            for the service, or it will be completely ignored; in the very least,
            this is a formalization for deprecating services.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ServiceOptions.HasDeprecated">
            <summary>Gets whether the "deprecated" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.ServiceOptions.ClearDeprecated">
            <summary>Clears the value of the "deprecated" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.ServiceOptions.UninterpretedOptionFieldNumber">
            <summary>Field number for the "uninterpreted_option" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ServiceOptions.UninterpretedOption">
            <summary>
            The parser stores options it doesn't recognize here. See above.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodOptions.DeprecatedFieldNumber">
            <summary>Field number for the "deprecated" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodOptions.Deprecated">
            <summary>
            Is this method deprecated?
            Depending on the target platform, this can emit Deprecated annotations
            for the method, or it will be completely ignored; in the very least,
            this is a formalization for deprecating methods.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodOptions.HasDeprecated">
            <summary>Gets whether the "deprecated" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodOptions.ClearDeprecated">
            <summary>Clears the value of the "deprecated" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodOptions.IdempotencyLevelFieldNumber">
            <summary>Field number for the "idempotency_level" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodOptions.HasIdempotencyLevel">
            <summary>Gets whether the "idempotency_level" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodOptions.ClearIdempotencyLevel">
            <summary>Clears the value of the "idempotency_level" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodOptions.UninterpretedOptionFieldNumber">
            <summary>Field number for the "uninterpreted_option" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodOptions.UninterpretedOption">
            <summary>
            The parser stores options it doesn't recognize here. See above.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.MethodOptions.Types">
            <summary>Container for nested types declared in the MethodOptions message type.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.MethodOptions.Types.IdempotencyLevel">
            <summary>
            Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
            or neither? HTTP based RPC implementation may choose GET verb for safe
            methods, and PUT verb for idempotent methods instead of the default POST.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodOptions.Types.IdempotencyLevel.NoSideEffects">
            <summary>
            implies idempotent
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.MethodOptions.Types.IdempotencyLevel.Idempotent">
            <summary>
            idempotent, but may have side effects
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.UninterpretedOption">
            <summary>
            A message representing a option the parser does not recognize. This only
            appears in options protos created by the compiler::Parser class.
            DescriptorPool resolves these when building Descriptor objects. Therefore,
            options protos in descriptor objects (e.g. returned by Descriptor::options(),
            or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
            in them.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.UninterpretedOption.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.UninterpretedOption.IdentifierValueFieldNumber">
            <summary>Field number for the "identifier_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.IdentifierValue">
            <summary>
            The value of the uninterpreted option, in whatever type the tokenizer
            identified it as during parsing. Exactly one of these should be set.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.HasIdentifierValue">
            <summary>Gets whether the "identifier_value" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.UninterpretedOption.ClearIdentifierValue">
            <summary>Clears the value of the "identifier_value" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.UninterpretedOption.PositiveIntValueFieldNumber">
            <summary>Field number for the "positive_int_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.HasPositiveIntValue">
            <summary>Gets whether the "positive_int_value" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.UninterpretedOption.ClearPositiveIntValue">
            <summary>Clears the value of the "positive_int_value" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.UninterpretedOption.NegativeIntValueFieldNumber">
            <summary>Field number for the "negative_int_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.HasNegativeIntValue">
            <summary>Gets whether the "negative_int_value" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.UninterpretedOption.ClearNegativeIntValue">
            <summary>Clears the value of the "negative_int_value" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.UninterpretedOption.DoubleValueFieldNumber">
            <summary>Field number for the "double_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.HasDoubleValue">
            <summary>Gets whether the "double_value" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.UninterpretedOption.ClearDoubleValue">
            <summary>Clears the value of the "double_value" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.UninterpretedOption.StringValueFieldNumber">
            <summary>Field number for the "string_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.HasStringValue">
            <summary>Gets whether the "string_value" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.UninterpretedOption.ClearStringValue">
            <summary>Clears the value of the "string_value" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.UninterpretedOption.AggregateValueFieldNumber">
            <summary>Field number for the "aggregate_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.HasAggregateValue">
            <summary>Gets whether the "aggregate_value" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.UninterpretedOption.ClearAggregateValue">
            <summary>Clears the value of the "aggregate_value" field</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.UninterpretedOption.Types">
            <summary>Container for nested types declared in the UninterpretedOption message type.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.UninterpretedOption.Types.NamePart">
            <summary>
            The name of the uninterpreted option.  Each string represents a segment in
            a dot-separated name.  is_extension is true iff a segment represents an
            extension (denoted with parentheses in options specs in .proto files).
            E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
            "foo.(bar.baz).qux".
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.UninterpretedOption.Types.NamePart.NamePart_FieldNumber">
            <summary>Field number for the "name_part" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.Types.NamePart.HasNamePart_">
            <summary>Gets whether the "name_part" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.UninterpretedOption.Types.NamePart.ClearNamePart_">
            <summary>Clears the value of the "name_part" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.UninterpretedOption.Types.NamePart.IsExtensionFieldNumber">
            <summary>Field number for the "is_extension" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.Types.NamePart.HasIsExtension">
            <summary>Gets whether the "is_extension" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.UninterpretedOption.Types.NamePart.ClearIsExtension">
            <summary>Clears the value of the "is_extension" field</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.SourceCodeInfo">
            <summary>
            Encapsulates information about the original source file from which a
            FileDescriptorProto was generated.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.SourceCodeInfo.LocationFieldNumber">
            <summary>Field number for the "location" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Location">
             <summary>
             A Location identifies a piece of source code in a .proto file which
             corresponds to a particular definition.  This information is intended
             to be useful to IDEs, code indexers, documentation generators, and similar
             tools.
            
             For example, say we have a file like:
               message Foo {
                 optional string foo = 1;
               }
             Let's look at just the field definition:
               optional string foo = 1;
               ^       ^^     ^^  ^  ^^^
               a       bc     de  f  ghi
             We have the following locations:
               span   path               represents
               [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
               [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
               [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
               [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
               [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
            
             Notes:
             - A location may refer to a repeated field itself (i.e. not to any
               particular index within it).  This is used whenever a set of elements are
               logically enclosed in a single code segment.  For example, an entire
               extend block (possibly containing multiple extension definitions) will
               have an outer location whose path refers to the "extensions" repeated
               field without an index.
             - Multiple locations may have the same path.  This happens when a single
               logical declaration is spread out across multiple places.  The most
               obvious example is the "extend" block again -- there may be multiple
               extend blocks in the same scope, each of which will have the same path.
             - A location's span is not always a subset of its parent's span.  For
               example, the "extendee" of an extension declaration appears at the
               beginning of the "extend" block and is shared by all extensions within
               the block.
             - Just because a location's span is a subset of some other location's span
               does not mean that it is a descendant.  For example, a "group" defines
               both a type and a field in a single declaration.  Thus, the locations
               corresponding to the type and field and their components will overlap.
             - Code which tries to interpret locations should probably be designed to
               ignore those that it doesn't understand, as more types of locations could
               be recorded in the future.
             </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types">
            <summary>Container for nested types declared in the SourceCodeInfo message type.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.PathFieldNumber">
            <summary>Field number for the "path" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.Path">
             <summary>
             Identifies which part of the FileDescriptorProto was defined at this
             location.
            
             Each element is a field number or an index.  They form a path from
             the root FileDescriptorProto to the place where the definition.  For
             example, this path:
               [ 4, 3, 2, 7, 1 ]
             refers to:
               file.message_type(3)  // 4, 3
                   .field(7)         // 2, 7
                   .name()           // 1
             This is because FileDescriptorProto.message_type has field number 4:
               repeated DescriptorProto message_type = 4;
             and DescriptorProto.field has field number 2:
               repeated FieldDescriptorProto field = 2;
             and FieldDescriptorProto.name has field number 1:
               optional string name = 1;
            
             Thus, the above path gives the location of a field name.  If we removed
             the last element:
               [ 4, 3, 2, 7 ]
             this path refers to the whole field declaration (from the beginning
             of the label to the terminating semicolon).
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.SpanFieldNumber">
            <summary>Field number for the "span" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.Span">
            <summary>
            Always has exactly three or four elements: start line, start column,
            end line (optional, otherwise assumed same as start line), end column.
            These are packed into a single field for efficiency.  Note that line
            and column numbers are zero-based -- typically you will want to add
            1 to each before displaying to a user.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.LeadingCommentsFieldNumber">
            <summary>Field number for the "leading_comments" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.LeadingComments">
             <summary>
             If this SourceCodeInfo represents a complete declaration, these are any
             comments appearing before and after the declaration which appear to be
             attached to the declaration.
            
             A series of line comments appearing on consecutive lines, with no other
             tokens appearing on those lines, will be treated as a single comment.
            
             leading_detached_comments will keep paragraphs of comments that appear
             before (but not connected to) the current element. Each paragraph,
             separated by empty lines, will be one comment element in the repeated
             field.
            
             Only the comment content is provided; comment markers (e.g. //) are
             stripped out.  For block comments, leading whitespace and an asterisk
             will be stripped from the beginning of each line other than the first.
             Newlines are included in the output.
            
             Examples:
            
               optional int32 foo = 1;  // Comment attached to foo.
               // Comment attached to bar.
               optional int32 bar = 2;
            
               optional string baz = 3;
               // Comment attached to baz.
               // Another line attached to baz.
            
               // Comment attached to qux.
               //
               // Another line attached to qux.
               optional double qux = 4;
            
               // Detached comment for corge. This is not leading or trailing comments
               // to qux or corge because there are blank lines separating it from
               // both.
            
               // Detached comment for corge paragraph 2.
            
               optional string corge = 5;
               /* Block comment attached
                * to corge.  Leading asterisks
                * will be removed. */
               /* Block comment attached to
                * grault. */
               optional int32 grault = 6;
            
               // ignored detached comments.
             </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.HasLeadingComments">
            <summary>Gets whether the "leading_comments" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.ClearLeadingComments">
            <summary>Clears the value of the "leading_comments" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.TrailingCommentsFieldNumber">
            <summary>Field number for the "trailing_comments" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.HasTrailingComments">
            <summary>Gets whether the "trailing_comments" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.ClearTrailingComments">
            <summary>Clears the value of the "trailing_comments" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.LeadingDetachedCommentsFieldNumber">
            <summary>Field number for the "leading_detached_comments" field.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo">
            <summary>
            Describes the relationship between generated code and its original source
            file. A GeneratedCodeInfo message is associated with only one generated
            source file, but may contain references to different source .proto files.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.AnnotationFieldNumber">
            <summary>Field number for the "annotation" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Annotation">
            <summary>
            An Annotation connects some span of text in generated code to an element
            of its generating .proto file.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types">
            <summary>Container for nested types declared in the GeneratedCodeInfo message type.</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.PathFieldNumber">
            <summary>Field number for the "path" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.Path">
            <summary>
            Identifies the element in the original source .proto file. This field
            is formatted the same as SourceCodeInfo.Location.path.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.SourceFileFieldNumber">
            <summary>Field number for the "source_file" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.SourceFile">
            <summary>
            Identifies the filesystem path to the original source .proto.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.HasSourceFile">
            <summary>Gets whether the "source_file" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.ClearSourceFile">
            <summary>Clears the value of the "source_file" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.BeginFieldNumber">
            <summary>Field number for the "begin" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.Begin">
            <summary>
            Identifies the starting offset in bytes in the generated code
            that relates to the identified object.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.HasBegin">
            <summary>Gets whether the "begin" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.ClearBegin">
            <summary>Clears the value of the "begin" field</summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.EndFieldNumber">
            <summary>Field number for the "end" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.End">
            <summary>
            Identifies the ending offset in bytes in the generated code that
            relates to the identified offset. The end offset should be one past
            the last relevant byte (so the length of the text = end - begin).
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.HasEnd">
            <summary>Gets whether the "end" field is set</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.ClearEnd">
            <summary>Clears the value of the "end" field</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.DescriptorBase">
            <summary>
            Base class for nearly all descriptors, providing common functionality.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorBase.Index">
            <value>
            The index of this descriptor within its parent descriptor.
            </value>
            <remarks>
            This returns the index of this descriptor within its parent, for
            this descriptor's type. (There can be duplicate values for different
            types, e.g. one enum type with index 0 and one message type with index 0.)
            </remarks>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorBase.Name">
            <summary>
            Returns the name of the entity (field, message etc) being described.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorBase.FullName">
            <summary>
            The fully qualified name of the descriptor's target.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorBase.File">
            <value>
            The file this descriptor was declared in.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorBase.Declaration">
            <summary>
            The declaration information about the descriptor, or null if no declaration information
            is available for this descriptor.
            </summary>
            <remarks>
            This information is typically only available for dynamically loaded descriptors,
            for example within a protoc plugin where the full descriptors, including source info,
            are passed to the code by protoc.
            </remarks>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.DescriptorDeclaration">
            <summary>
            Provides additional information about the declaration of a descriptor,
            such as source location and comments.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorDeclaration.Descriptor">
            <summary>
            The descriptor this declaration relates to.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorDeclaration.StartLine">
            <summary>
            The start line of the declaration within the source file. This value is 1-based.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorDeclaration.StartColumn">
            <summary>
            The start column of the declaration within the source file. This value is 1-based.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorDeclaration.EndLine">
            <summary>
            // The end line of the declaration within the source file. This value is 1-based.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorDeclaration.EndColumn">
            <summary>
            The end column of the declaration within the source file. This value is 1-based, and
            exclusive. (The final character of the declaration is on the column before this value.)
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorDeclaration.LeadingComments">
            <summary>
            Comments appearing before the declaration. Never null, but may be empty. Multi-line comments
            are represented as a newline-separated string. Leading whitespace and the comment marker ("//")
            are removed from each line.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorDeclaration.TrailingComments">
            <summary>
            Comments appearing after the declaration. Never null, but may be empty. Multi-line comments
            are represented as a newline-separated string. Leading whitespace and the comment marker ("//")
            are removed from each line.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorDeclaration.LeadingDetachedComments">
            <summary>
            Comments appearing before the declaration, but separated from it by blank
            lines. Each string represents a newline-separated paragraph of comments.
            Leading whitespace and the comment marker ("//") are removed from each line.
            The list is never null, but may be empty. Likewise each element is never null, but may be empty.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.DescriptorValidationException">
            <summary>
            Thrown when building descriptors fails because the source DescriptorProtos
            are not valid.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorValidationException.ProblemSymbolName">
            <value>
            The full name of the descriptor where the error occurred.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorValidationException.Description">
            <value>
            A human-readable description of the error. (The Message property
            is made up of the descriptor's name and this description.)
            </value>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.EnumDescriptor">
            <summary>
            Descriptor for an enum type in a .proto file.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptor.Name">
            <summary>
            The brief name of the descriptor's target.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptor.ClrType">
            <summary>
            The CLR type for this enum. For generated code, this will be a CLR enum type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptor.ContainingType">
            <value>
            If this is a nested type, get the outer descriptor, otherwise null.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptor.Values">
            <value>
            An unmodifiable list of defined value descriptors for this enum.
            </value>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumDescriptor.FindValueByNumber(System.Int32)">
            <summary>
            Finds an enum value by number. If multiple enum values have the
            same number, this returns the first defined value with that number.
            If there is no value for the given number, this returns <c>null</c>.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumDescriptor.FindValueByName(System.String)">
            <summary>
            Finds an enum value by name.
            </summary>
            <param name="name">The unqualified name of the value (e.g. "FOO").</param>
            <returns>The value's descriptor, or null if not found.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptor.CustomOptions">
            <summary>
            The (possibly empty) set of custom options for this enum.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumDescriptor.GetOptions">
            <summary>
            The <c>EnumOptions</c>, defined in <c>descriptor.proto</c>.
            If the options message is not present (i.e. there are no options), <c>null</c> is returned.
            Custom options can be retrieved as extensions of the returned message.
            NOTE: A defensive copy is created each time this property is retrieved.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumDescriptor.GetOption``1(Auki.Util.Protobuf.Extension{Auki.Util.Protobuf.Reflection.EnumOptions,``0})">
            <summary>
            Gets a single value enum option for this descriptor
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumDescriptor.GetOption``1(Auki.Util.Protobuf.RepeatedExtension{Auki.Util.Protobuf.Reflection.EnumOptions,``0})">
            <summary>
            Gets a repeated value enum option for this descriptor
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.EnumValueDescriptor">
            <summary>
            Descriptor for a single enum value within an enum in a .proto file.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueDescriptor.Name">
            <summary>
            Returns the name of the enum value described by this object.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueDescriptor.Number">
            <summary>
            Returns the number associated with this enum value.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueDescriptor.EnumDescriptor">
            <summary>
            Returns the enum descriptor that this value is part of.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueDescriptor.CustomOptions">
            <summary>
            The (possibly empty) set of custom options for this enum value.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumValueDescriptor.GetOptions">
            <summary>
            The <c>EnumValueOptions</c>, defined in <c>descriptor.proto</c>.
            If the options message is not present (i.e. there are no options), <c>null</c> is returned.
            Custom options can be retrieved as extensions of the returned message.
            NOTE: A defensive copy is created each time this property is retrieved.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumValueDescriptor.GetOption``1(Auki.Util.Protobuf.Extension{Auki.Util.Protobuf.Reflection.EnumValueOptions,``0})">
            <summary>
            Gets a single value enum value option for this descriptor
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.EnumValueDescriptor.GetOption``1(Auki.Util.Protobuf.RepeatedExtension{Auki.Util.Protobuf.Reflection.EnumValueOptions,``0})">
            <summary>
            Gets a repeated value enum value option for this descriptor
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.ExtensionCollection">
            <summary>
            A collection to simplify retrieving the descriptors of extensions in a descriptor for a message
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ExtensionCollection.UnorderedExtensions">
            <summary>
            Returns a readonly list of all the extensions defined in this type in 
            the order they were defined in the source .proto file
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.ExtensionCollection.GetExtensionsInDeclarationOrder(Auki.Util.Protobuf.Reflection.MessageDescriptor)">
            <summary>
            Returns a readonly list of all the extensions define in this type that extend 
            the provided descriptor type in the order they were defined in the source .proto file
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.ExtensionCollection.GetExtensionsInNumberOrder(Auki.Util.Protobuf.Reflection.MessageDescriptor)">
            <summary>
            Returns a readonly list of all the extensions define in this type that extend 
            the provided descriptor type in accending field order
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FieldDescriptor">
            <summary>
            Descriptor for a field or extension within a message in a .proto file.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.ContainingType">
            <summary>
            Get the field's containing message type, or <c>null</c> if it is a field defined at the top level of a file as an extension.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.ContainingOneof">
            <summary>
            Returns the oneof containing this field, or <c>null</c> if it is not part of a oneof.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.RealContainingOneof">
            <summary>
            Returns the oneof containing this field if it's a "real" oneof, or <c>null</c> if either this
            field is not part of a oneof, or the oneof is synthetic.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.JsonName">
            <summary>
            The effective JSON name for this field. This is usually the lower-camel-cased form of the field name,
            but can be overridden using the <c>json_name</c> option in the .proto file.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.HasPresence">
            <summary>
            Indicates whether this field supports presence, either implicitly (e.g. due to it being a message
            type field) or explicitly via Has/Clear members. If this returns true, it is safe to call
            <see cref="M:Auki.Util.Protobuf.Reflection.IFieldAccessor.Clear(Auki.Util.Protobuf.IMessage)" /> and <see cref="M:Auki.Util.Protobuf.Reflection.IFieldAccessor.HasValue(Auki.Util.Protobuf.IMessage)" />
            on this field's accessor with a suitable message.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.Extension">
            <summary>
            An extension identifier for this field, or <c>null</c> if this field isn't an extension.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.Name">
            <summary>
            The brief name of the descriptor's target.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.Accessor">
            <summary>
            Returns the accessor for this field.
            </summary>
            <remarks>
            <para>
            While a <see cref="T:Auki.Util.Protobuf.Reflection.FieldDescriptor" /> describes the field, it does not provide
            any way of obtaining or changing the value of the field within a specific message;
            that is the responsibility of the accessor.
            </para>
            <para>
            In descriptors for generated code, the value returned by this property will be non-null for all
            regular fields. However, if a message containing a map field is introspected, the list of nested messages will include
            an auto-generated nested key/value pair message for the field. This is not represented in any
            generated type, and the value of the map field itself is represented by a dictionary in the
            reflection API. There are never instances of those "hidden" messages, so no accessor is provided
            and this property will return null.
            </para>
            <para>
            In dynamically loaded descriptors, the value returned by this property will current be null;
            if and when dynamic messages are supported, it will return a suitable accessor to work with
            them.
            </para>
            </remarks>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.IsRepeated">
            <summary>
            Returns <c>true</c> if this field is a repeated field; <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.IsRequired">
            <summary>
            Returns <c>true</c> if this field is a required field; <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.IsMap">
            <summary>
            Returns <c>true</c> if this field is a map field; <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.IsPacked">
            <summary>
            Returns <c>true</c> if this field is a packed, repeated field; <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.IsExtension">
            <summary>
            Returns <c>true</c> if this field extends another message type; <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.FieldType">
            <summary>
            Returns the type of the field.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.FieldNumber">
            <summary>
            Returns the field number declared in the proto file.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptor.CompareTo(Auki.Util.Protobuf.Reflection.FieldDescriptor)">
            <summary>
            Compares this descriptor with another one, ordering in "canonical" order
            which simply means ascending order by field number. <paramref name="other" />
            must be a field of the same type, i.e. the <see cref="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.ContainingType" /> of
            both fields must be the same.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.EnumType">
            <summary>
            For enum fields, returns the field's type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.MessageType">
            <summary>
            For embedded message and group fields, returns the field's type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.ExtendeeType">
            <summary>
            For extension fields, returns the extended type
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptor.CustomOptions">
            <summary>
            The (possibly empty) set of custom options for this field.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptor.GetOptions">
            <summary>
            The <c>FieldOptions</c>, defined in <c>descriptor.proto</c>.
            If the options message is not present (i.e. there are no options), <c>null</c> is returned.
            Custom options can be retrieved as extensions of the returned message.
            NOTE: A defensive copy is created each time this property is retrieved.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptor.GetOption``1(Auki.Util.Protobuf.Extension{Auki.Util.Protobuf.Reflection.FieldOptions,``0})">
            <summary>
            Gets a single value field option for this descriptor
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FieldDescriptor.GetOption``1(Auki.Util.Protobuf.RepeatedExtension{Auki.Util.Protobuf.Reflection.FieldOptions,``0})">
            <summary>
            Gets a repeated value field option for this descriptor
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FieldType">
            <summary>
            Enumeration of all the possible field types.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Double">
            <summary>
            The <c>double</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Float">
            <summary>
            The <c>float</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Int64">
            <summary>
            The <c>int64</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.UInt64">
            <summary>
            The <c>uint64</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Int32">
            <summary>
            The <c>int32</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Fixed64">
            <summary>
            The <c>fixed64</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Fixed32">
            <summary>
            The <c>fixed32</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Bool">
            <summary>
            The <c>bool</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.String">
            <summary>
            The <c>string</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Group">
            <summary>
            The field type used for groups.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Message">
            <summary>
            The field type used for message fields.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Bytes">
            <summary>
            The <c>bytes</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.UInt32">
            <summary>
            The <c>uint32</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.SFixed32">
            <summary>
            The <c>sfixed32</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.SFixed64">
            <summary>
            The <c>sfixed64</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.SInt32">
            <summary>
            The <c>sint32</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.SInt64">
            <summary>
            The <c>sint64</c> field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.FieldType.Enum">
            <summary>
            The field type used for enum fields.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.Syntax">
            <summary>
            The syntax of a .proto file
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.Syntax.Proto2">
            <summary>
            Proto2 syntax
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.Syntax.Proto3">
            <summary>
            Proto3 syntax
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.Reflection.Syntax.Unknown">
            <summary>
            An unknown declared syntax
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.FileDescriptor">
            <summary>
            Describes a .proto file, including everything defined within.
            IDescriptor is implemented such that the File property returns this descriptor,
            and the FullName is the same as the Name.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.Syntax">
            <summary>
            The syntax of the file
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.Name">
            <value>
            The file name.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.Package">
            <summary>
            The package as declared in the .proto file. This may or may not
            be equivalent to the .NET namespace of the generated classes.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.MessageTypes">
            <value>
            Unmodifiable list of top-level message types declared in this file.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.EnumTypes">
            <value>
            Unmodifiable list of top-level enum types declared in this file.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.Services">
            <value>
            Unmodifiable list of top-level services declared in this file.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.Extensions">
            <summary>
            Unmodifiable list of top-level extensions declared in this file.
            Note that some extensions may be incomplete (FieldDescriptor.Extension may be null)
            if this descriptor was generated using a version of protoc that did not fully
            support extensions in C#.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.Dependencies">
            <value>
            Unmodifiable list of this file's dependencies (imports).
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.PublicDependencies">
            <value>
            Unmodifiable list of this file's public dependencies (public imports).
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.SerializedData">
            <value>
            The original serialized binary form of this descriptor.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.Auki#Util#Protobuf#Reflection#IDescriptor#FullName">
            <value>
            Implementation of IDescriptor.FullName - just returns the same as Name.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.Auki#Util#Protobuf#Reflection#IDescriptor#File">
            <value>
            Implementation of IDescriptor.File - just returns this descriptor.
            </value>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptor.FindTypeByName``1(System.String)">
            <summary>
            Finds a type (message, enum, service or extension) in the file by name. Does not find nested types.
            </summary>
            <param name="name">The unqualified type name to look for.</param>
            <typeparam name="T">The type of descriptor to look for</typeparam>
            <returns>The type's descriptor, or null if not found.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptor.FromGeneratedCode(System.Byte[],Auki.Util.Protobuf.Reflection.FileDescriptor[],Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo)">
            <summary>
            Creates a descriptor for generated code.
            </summary>
            <remarks>
            This method is only designed to be used by the results of generating code with protoc,
            which creates the appropriate dependencies etc. It has to be public because the generated
            code is "external", but should not be called directly by end users.
            </remarks>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptor.BuildFromByteStrings(System.Collections.Generic.IEnumerable{Auki.Util.Protobuf.ByteString})">
            <summary>
            Converts the given descriptor binary data into FileDescriptor objects.
            Note: reflection using the returned FileDescriptors is not currently supported.
            </summary>
            <param name="descriptorData">The binary file descriptor proto data. Must not be null, and any
            dependencies must come before the descriptor which depends on them. (If A depends on B, and B
            depends on C, then the descriptors must be presented in the order C, B, A.) This is compatible
            with the order in which protoc provides descriptors to plugins.</param>
            <returns>The file descriptors corresponding to <paramref name="descriptorData" />.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptor.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.DescriptorProtoFileDescriptor">
            <summary>
            Returns the file descriptor for descriptor.proto.
            </summary>
            <remarks>
            This is used for protos which take a direct dependency on <c>descriptor.proto</c>, typically for
            annotations. While <c>descriptor.proto</c> is a proto2 file, it is built into the Auki.Protobuf
            runtime for reflection purposes. The messages are internal to the runtime as they would require
            proto2 semantics for full support, but the file descriptor is available via this property. The
            C# codegen in protoc automatically uses this property when it detects a dependency on <c>descriptor.proto</c>.
            </remarks>
            <value>
            The file descriptor for <c>descriptor.proto</c>.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptor.CustomOptions">
            <summary>
            The (possibly empty) set of custom options for this file.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptor.GetOptions">
            <summary>
            The <c>FileOptions</c>, defined in <c>descriptor.proto</c>.
            If the options message is not present (i.e. there are no options), <c>null</c> is returned.
            Custom options can be retrieved as extensions of the returned message.
            NOTE: A defensive copy is created each time this property is retrieved.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptor.GetOption``1(Auki.Util.Protobuf.Extension{Auki.Util.Protobuf.Reflection.FileOptions,``0})">
            <summary>
            Gets a single value file option for this descriptor
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptor.GetOption``1(Auki.Util.Protobuf.RepeatedExtension{Auki.Util.Protobuf.Reflection.FileOptions,``0})">
            <summary>
            Gets a repeated value file option for this descriptor
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.FileDescriptor.ForceReflectionInitialization``1">
            <summary>
            Performs initialization for the given generic type argument.
            </summary>
            <remarks>
            This method is present for the sake of AOT compilers. It allows code (whether handwritten or generated)
            to make calls into the reflection machinery of this library to express an intention to use that type
            reflectively (e.g. for JSON parsing and formatting). The call itself does almost nothing, but AOT compilers
            attempting to determine which generic type arguments need to be handled will spot the code path and act
            accordingly.
            </remarks>
            <typeparam name="T">The type to force initialization for.</typeparam>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo">
            <summary>
            Extra information provided by generated code when initializing a message or file descriptor.
            These are constructed as required, and are not long-lived. Hand-written code should
            never need to use this type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.ClrType">
            <summary>
            Irrelevant for file descriptors; the CLR type for the message for message descriptors.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.Parser">
            <summary>
            Irrelevant for file descriptors; the parser for message descriptors.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.PropertyNames">
            <summary>
            Irrelevant for file descriptors; the CLR property names (in message descriptor field order)
            for fields in the message for message descriptors.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.Extensions">
            <summary>
            The extensions defined within this file/message descriptor
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.OneofNames">
            <summary>
            Irrelevant for file descriptors; the CLR property "base" names (in message descriptor oneof order)
            for oneofs in the message for message descriptors. It is expected that for a oneof name of "Foo",
            there will be a "FooCase" property and a "ClearFoo" method.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.NestedTypes">
            <summary>
            The reflection information for types within this file/message descriptor. Elements may be null
            if there is no corresponding generated type, e.g. for map entry types.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.NestedEnums">
            <summary>
            The CLR types for enums within this file/message descriptor.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.#ctor(System.Type,Auki.Util.Protobuf.MessageParser,System.String[],System.String[],System.Type[],Auki.Util.Protobuf.Extension[],Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo[])">
            <summary>
            Creates a GeneratedClrTypeInfo for a message descriptor, with nested types, nested enums, the CLR type, property names and oneof names.
            Each array parameter may be null, to indicate a lack of values.
            The parameter order is designed to make it feasible to format the generated code readably.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.#ctor(System.Type,Auki.Util.Protobuf.MessageParser,System.String[],System.String[],System.Type[],Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo[])">
            <summary>
            Creates a GeneratedClrTypeInfo for a message descriptor, with nested types, nested enums, the CLR type, property names and oneof names.
            Each array parameter may be null, to indicate a lack of values.
            The parameter order is designed to make it feasible to format the generated code readably.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.#ctor(System.Type[],Auki.Util.Protobuf.Extension[],Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo[])">
            <summary>
            Creates a GeneratedClrTypeInfo for a file descriptor, with only types, enums, and extensions.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo.#ctor(System.Type[],Auki.Util.Protobuf.Reflection.GeneratedClrTypeInfo[])">
            <summary>
            Creates a GeneratedClrTypeInfo for a file descriptor, with only types and enums.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.IDescriptor">
            <summary>
            Interface implemented by all descriptor types.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.IDescriptor.Name">
            <summary>
            Returns the name of the entity (message, field etc) being described.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.IDescriptor.FullName">
            <summary>
            Returns the fully-qualified name of the entity being described.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.IDescriptor.File">
            <summary>
            Returns the descriptor for the .proto file that this entity is part of.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.IFieldAccessor">
            <summary>
            Allows fields to be reflectively accessed.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.IFieldAccessor.Descriptor">
            <summary>
            Returns the descriptor associated with this field.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.IFieldAccessor.Clear(Auki.Util.Protobuf.IMessage)">
            <summary>
            Clears the field in the specified message. (For repeated fields,
            this clears the list.)
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.IFieldAccessor.GetValue(Auki.Util.Protobuf.IMessage)">
            <summary>
            Fetches the field value. For repeated values, this will be an
            <see cref="T:System.Collections.IList" /> implementation. For map values, this will be an
            <see cref="T:System.Collections.IDictionary" /> implementation.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.IFieldAccessor.HasValue(Auki.Util.Protobuf.IMessage)">
            <summary>
            Indicates whether the field in the specified message is set.
            For proto3 fields that aren't explicitly optional, this throws an <see cref="T:System.InvalidOperationException" />
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.IFieldAccessor.SetValue(Auki.Util.Protobuf.IMessage,System.Object)">
            <summary>
            Mutator for single "simple" fields only.
            </summary>
            <remarks>
            Repeated fields are mutated by fetching the value and manipulating it as a list.
            Map fields are mutated by fetching the value and manipulating it as a dictionary.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The field is not a "simple" field.</exception>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.MessageDescriptor">
            <summary>
            Describes a message type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.Name">
            <summary>
            The brief name of the descriptor's target.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.ClrType">
            <summary>
            The CLR type used to represent message instances from this descriptor.
            </summary>
            <remarks>
            <para>
            The value returned by this property will be non-null for all regular fields. However,
            if a message containing a map field is introspected, the list of nested messages will include
            an auto-generated nested key/value pair message for the field. This is not represented in any
            generated type, so this property will return null in such cases.
            </para>
            <para>
            For wrapper types (<see cref="T:Auki.Util.Protobuf.WellKnownTypes.StringValue" /> and the like), the type returned here
            will be the generated message type, not the native type used by reflection for fields of those types. Code
            using reflection should call <see cref="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.IsWrapperType" /> to determine whether a message descriptor represents
            a wrapper type, and handle the result appropriately.
            </para>
            </remarks>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.Parser">
            <summary>
            A parser for this message type.
            </summary>
            <remarks>
            <para>
            As <see cref="T:Auki.Util.Protobuf.Reflection.MessageDescriptor" /> is not generic, this cannot be statically
            typed to the relevant type, but it should produce objects of a type compatible with <see cref="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.ClrType" />.
            </para>
            <para>
            The value returned by this property will be non-null for all regular fields. However,
            if a message containing a map field is introspected, the list of nested messages will include
            an auto-generated nested key/value pair message for the field. No message parser object is created for
            such messages, so this property will return null in such cases.
            </para>
            <para>
            For wrapper types (<see cref="T:Auki.Util.Protobuf.WellKnownTypes.StringValue" /> and the like), the parser returned here
            will be the generated message type, not the native type used by reflection for fields of those types. Code
            using reflection should call <see cref="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.IsWrapperType" /> to determine whether a message descriptor represents
            a wrapper type, and handle the result appropriately.
            </para>
            </remarks>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.ContainingType">
            <value>
            If this is a nested type, get the outer descriptor, otherwise null.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.Fields">
            <value>
            A collection of fields, which can be retrieved by name or field number.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.Extensions">
            <summary>
            An unmodifiable list of extensions defined in this message's scope.
            Note that some extensions may be incomplete (FieldDescriptor.Extension may be null)
            if they are declared in a file generated using a version of protoc that did not fully
            support extensions in C#.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.NestedTypes">
            <value>
            An unmodifiable list of this message type's nested types.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.EnumTypes">
            <value>
            An unmodifiable list of this message type's enum types.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.Oneofs">
            <value>
            An unmodifiable list of the "oneof" field collections in this message type.
            All "real" oneofs (where <see cref="P:Auki.Util.Protobuf.Reflection.OneofDescriptor.IsSynthetic" /> returns false)
            come before synthetic ones.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.RealOneofCount">
            <summary>
            The number of real "oneof" descriptors in this message type. Every element in <see cref="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.Oneofs" />
            with an index less than this will have a <see cref="P:Auki.Util.Protobuf.Reflection.OneofDescriptor.IsSynthetic" /> property value
            of <c>false</c>; every element with an index greater than or equal to this will have a
            <see cref="P:Auki.Util.Protobuf.Reflection.OneofDescriptor.IsSynthetic" /> property value of <c>true</c>.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageDescriptor.FindFieldByName(System.String)">
            <summary>
            Finds a field by field name.
            </summary>
            <param name="name">The unqualified name of the field (e.g. "foo").</param>
            <returns>The field's descriptor, or null if not found.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageDescriptor.FindFieldByNumber(System.Int32)">
            <summary>
            Finds a field by field number.
            </summary>
            <param name="number">The field number within this message type.</param>
            <returns>The field's descriptor, or null if not found.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageDescriptor.FindDescriptor``1(System.String)">
            <summary>
            Finds a nested descriptor by name. The is valid for fields, nested
            message types, oneofs and enums.
            </summary>
            <param name="name">The unqualified name of the descriptor, e.g. "Foo"</param>
            <returns>The descriptor, or null if not found.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.CustomOptions">
            <summary>
            The (possibly empty) set of custom options for this message.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageDescriptor.GetOptions">
            <summary>
            The <c>MessageOptions</c>, defined in <c>descriptor.proto</c>.
            If the options message is not present (i.e. there are no options), <c>null</c> is returned.
            Custom options can be retrieved as extensions of the returned message.
            NOTE: A defensive copy is created each time this property is retrieved.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageDescriptor.GetOption``1(Auki.Util.Protobuf.Extension{Auki.Util.Protobuf.Reflection.MessageOptions,``0})">
            <summary>
            Gets a single value message option for this descriptor
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageDescriptor.GetOption``1(Auki.Util.Protobuf.RepeatedExtension{Auki.Util.Protobuf.Reflection.MessageOptions,``0})">
            <summary>
            Gets a repeated value message option for this descriptor
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.MessageDescriptor.FieldCollection">
            <summary>
            A collection to simplify retrieving the field accessor for a particular field.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageDescriptor.FieldCollection.InDeclarationOrder">
            <value>
            Returns the fields in the message as an immutable list, in the order in which they
            are declared in the source .proto file.
            </value>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MessageDescriptor.FieldCollection.InFieldNumberOrder">
            <value>
            Returns the fields in the message as an immutable list, in ascending field number
            order. Field numbers need not be contiguous, so there is no direct mapping from the
            index in the list to the field number; to retrieve a field by field number, it is better
            to use the <see cref="T:Auki.Util.Protobuf.Reflection.MessageDescriptor.FieldCollection" /> indexer.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.FieldCollection.Item(System.Int32)">
            <summary>
            Retrieves the descriptor for the field with the given number.
            </summary>
            <param name="number">Number of the field to retrieve the descriptor for</param>
            <returns>The accessor for the given field</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The message descriptor does not contain a field
            with the given number</exception>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageDescriptor.FieldCollection.Item(System.String)">
            <summary>
            Retrieves the descriptor for the field with the given name.
            </summary>
            <param name="name">Name of the field to retrieve the descriptor for</param>
            <returns>The descriptor for the given field</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The message descriptor does not contain a field
            with the given name</exception>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.MethodDescriptor">
            <summary>
            Describes a single method in a service.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptor.Service">
            <value>
            The service this method belongs to.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptor.InputType">
            <value>
            The method's input type.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptor.OutputType">
            <value>
            The method's input type.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptor.IsClientStreaming">
            <value>
            Indicates if client streams multiple requests.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptor.IsServerStreaming">
            <value>
            Indicates if server streams multiple responses.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptor.CustomOptions">
            <summary>
            The (possibly empty) set of custom options for this method.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodDescriptor.GetOptions">
            <summary>
            The <c>MethodOptions</c>, defined in <c>descriptor.proto</c>.
            If the options message is not present (i.e. there are no options), <c>null</c> is returned.
            Custom options can be retrieved as extensions of the returned message.
            NOTE: A defensive copy is created each time this property is retrieved.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodDescriptor.GetOption``1(Auki.Util.Protobuf.Extension{Auki.Util.Protobuf.Reflection.MethodOptions,``0})">
            <summary>
            Gets a single value method option for this descriptor
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.MethodDescriptor.GetOption``1(Auki.Util.Protobuf.RepeatedExtension{Auki.Util.Protobuf.Reflection.MethodOptions,``0})">
            <summary>
            Gets a repeated value method option for this descriptor
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptor.Name">
            <summary>
            The brief name of the descriptor's target.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.OneofAccessor">
            <summary>
            Reflection access for a oneof, allowing clear and "get case" actions.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofAccessor.Descriptor">
            <summary>
            Gets the descriptor for this oneof.
            </summary>
            <value>
            The descriptor of the oneof.
            </value>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.OneofAccessor.Clear(Auki.Util.Protobuf.IMessage)">
            <summary>
            Clears the oneof in the specified message.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.OneofAccessor.GetCaseFieldDescriptor(Auki.Util.Protobuf.IMessage)">
            <summary>
            Indicates which field in the oneof is set for specified message
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.OneofDescriptor">
            <summary>
            Describes a "oneof" field collection in a message type: a set of
            fields of which at most one can be set in any particular message.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofDescriptor.Name">
            <summary>
            The brief name of the descriptor's target.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofDescriptor.ContainingType">
            <summary>
            Gets the message type containing this oneof.
            </summary>
            <value>
            The message type containing this oneof.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofDescriptor.Fields">
            <summary>
            Gets the fields within this oneof, in declaration order.
            </summary>
            <value>
            The fields within this oneof, in declaration order.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofDescriptor.IsSynthetic">
            <summary>
            Returns <c>true</c> if this oneof is a synthetic oneof containing a proto3 optional field;
            <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofDescriptor.Accessor">
            <summary>
            Gets an accessor for reflective access to the values associated with the oneof
            in a particular message.
            </summary>
            <remarks>
            <para>
            In descriptors for generated code, the value returned by this property will always be non-null.
            </para>
            <para>
            In dynamically loaded descriptors, the value returned by this property will current be null;
            if and when dynamic messages are supported, it will return a suitable accessor to work with
            them.
            </para>
            </remarks>
            <value>
            The accessor used for reflective access.
            </value>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofDescriptor.CustomOptions">
            <summary>
            The (possibly empty) set of custom options for this oneof.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.OneofDescriptor.GetOptions">
            <summary>
            The <c>OneofOptions</c>, defined in <c>descriptor.proto</c>.
            If the options message is not present (i.e. there are no options), <c>null</c> is returned.
            Custom options can be retrieved as extensions of the returned message.
            NOTE: A defensive copy is created each time this property is retrieved.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.OneofDescriptor.GetOption``1(Auki.Util.Protobuf.Extension{Auki.Util.Protobuf.Reflection.OneofOptions,``0})">
            <summary>
            Gets a single value oneof option for this descriptor
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.OneofDescriptor.GetOption``1(Auki.Util.Protobuf.RepeatedExtension{Auki.Util.Protobuf.Reflection.OneofOptions,``0})">
            <summary>
            Gets a repeated value oneof option for this descriptor
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.OriginalNameAttribute">
            <summary>
            Specifies the original name (in the .proto file) of a named element,
            such as an enum value.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OriginalNameAttribute.Name">
            <summary>
            The name of the element in the .proto file.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OriginalNameAttribute.PreferredAlias">
            <summary>
            If the name is preferred in the .proto file.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.OriginalNameAttribute.#ctor(System.String)">
            <summary>
            Constructs a new attribute instance for the given name.
            </summary>
            <param name="name">The name of the element in the .proto file.</param>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.ServiceDescriptor">
            <summary>
            Describes a service type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ServiceDescriptor.Name">
            <summary>
            The brief name of the descriptor's target.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ServiceDescriptor.Methods">
            <value>
            An unmodifiable list of methods in this service.
            </value>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.ServiceDescriptor.FindMethodByName(System.String)">
            <summary>
            Finds a method by name.
            </summary>
            <param name="name">The unqualified name of the method (e.g. "Foo").</param>
            <returns>The method's descriptor, or null if not found.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ServiceDescriptor.CustomOptions">
            <summary>
            The (possibly empty) set of custom options for this service.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.ServiceDescriptor.GetOptions">
            <summary>
            The <c>ServiceOptions</c>, defined in <c>descriptor.proto</c>.
            If the options message is not present (i.e. there are no options), <c>null</c> is returned.
            Custom options can be retrieved as extensions of the returned message.
            NOTE: A defensive copy is created each time this property is retrieved.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.ServiceDescriptor.GetOption``1(Auki.Util.Protobuf.Extension{Auki.Util.Protobuf.Reflection.ServiceOptions,``0})">
            <summary>
            Gets a single value service option for this descriptor
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.ServiceDescriptor.GetOption``1(Auki.Util.Protobuf.RepeatedExtension{Auki.Util.Protobuf.Reflection.ServiceOptions,``0})">
            <summary>
            Gets a repeated value service option for this descriptor
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.Reflection.TypeRegistry">
            <summary>
            An immutable registry of types which can be looked up by their full name.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.TypeRegistry.Empty">
            <summary>
            An empty type registry, containing no types.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.TypeRegistry.Find(System.String)">
            <summary>
            Attempts to find a message descriptor by its full name.
            </summary>
            <param name="fullName">The full name of the message, which is the dot-separated
            combination of package, containing messages and message name</param>
            <returns>The message descriptor corresponding to <paramref name="fullName" /> or null
            if there is no such message descriptor.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.TypeRegistry.FromFiles(Auki.Util.Protobuf.Reflection.FileDescriptor[])">
            <summary>
            Creates a type registry from the specified set of file descriptors.
            </summary>
            <remarks>
            This is a convenience overload for <see cref="M:Auki.Util.Protobuf.Reflection.TypeRegistry.FromFiles(System.Collections.Generic.IEnumerable{Auki.Util.Protobuf.Reflection.FileDescriptor})" />
            to allow calls such as <c>TypeRegistry.FromFiles(descriptor1, descriptor2)</c>.
            </remarks>
            <param name="fileDescriptors">The set of files to include in the registry. Must not contain null values.</param>
            <returns>A type registry for the given files.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.TypeRegistry.FromFiles(System.Collections.Generic.IEnumerable{Auki.Util.Protobuf.Reflection.FileDescriptor})">
            <summary>
            Creates a type registry from the specified set of file descriptors.
            </summary>
            <remarks>
            All message types within all the specified files are added to the registry, and
            the dependencies of the specified files are also added, recursively.
            </remarks>
            <param name="fileDescriptors">The set of files to include in the registry. Must not contain null values.</param>
            <returns>A type registry for the given files.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.TypeRegistry.FromMessages(Auki.Util.Protobuf.Reflection.MessageDescriptor[])">
            <summary>
            Creates a type registry from the file descriptor parents of the specified set of message descriptors.
            </summary>
            <remarks>
            This is a convenience overload for <see cref="M:Auki.Util.Protobuf.Reflection.TypeRegistry.FromMessages(System.Collections.Generic.IEnumerable{Auki.Util.Protobuf.Reflection.MessageDescriptor})" />
            to allow calls such as <c>TypeRegistry.FromFiles(descriptor1, descriptor2)</c>.
            </remarks>
            <param name="messageDescriptors">The set of message descriptors to use to identify file descriptors to include in the registry.
            Must not contain null values.</param>
            <returns>A type registry for the given files.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Reflection.TypeRegistry.FromMessages(System.Collections.Generic.IEnumerable{Auki.Util.Protobuf.Reflection.MessageDescriptor})">
            <summary>
            Creates a type registry from the file descriptor parents of the specified set of message descriptors.
            </summary>
            <remarks>
            The specified message descriptors are only used to identify their file descriptors; the returned registry
            contains all the types within the file descriptors which contain the specified message descriptors (and
            the dependencies of those files), not just the specified messages.
            </remarks>
            <param name="messageDescriptors">The set of message descriptors to use to identify file descriptors to include in the registry.
            Must not contain null values.</param>
            <returns>A type registry for the given files.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.UnknownFieldSet">
             <summary>
             Used to keep track of fields which were seen when parsing a protocol message
             but whose field numbers or types are unrecognized. This most frequently
             occurs when new fields are added to a message type and then messages containing
             those fields are read by old software that was built before the new types were
             added.
            
             Most users will never need to use this class directly.
             </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.UnknownFieldSet.WriteTo(Auki.Util.Protobuf.CodedOutputStream)">
            <summary>
            Serializes the set and writes it to <paramref name="output" />.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.UnknownFieldSet.CalculateSize">
            <summary>
            Gets the number of bytes required to encode this set.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.UnknownFieldSet.Equals(System.Object)">
            <summary>
            Checks if two unknown field sets are equal.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.UnknownFieldSet.GetHashCode">
            <summary>
            Gets the unknown field set's hash code.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.UnknownFieldSet.MergeFieldFrom(Auki.Util.Protobuf.UnknownFieldSet,Auki.Util.Protobuf.CodedInputStream)">
            <summary>
            Create a new UnknownFieldSet if unknownFields is null.
            Parse a single field from <paramref name="input" /> and merge it
            into unknownFields. If <paramref name="input" /> is configured to discard unknown fields,
            <paramref name="unknownFields" /> will be returned as-is and the field will be skipped.
            </summary>
            <param name="unknownFields">The UnknownFieldSet which need to be merged</param>
            <param name="input">The coded input stream containing the field</param>
            <returns>The merged UnknownFieldSet</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.UnknownFieldSet.MergeFrom(Auki.Util.Protobuf.UnknownFieldSet,Auki.Util.Protobuf.UnknownFieldSet)">
            <summary>
            Created a new UnknownFieldSet to <paramref name="unknownFields" /> if
            needed and merges the fields from <paramref name="other" /> into the first set.
            If a field number exists in both sets, the values in <paramref name="other" />
            will be appended to the values in this set.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.UnknownFieldSet.Clone(Auki.Util.Protobuf.UnknownFieldSet)">
            <summary>
            Clone an unknown field set from <paramref name="other" />.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.AnyReflection">
            <summary>Holder for reflection information generated from google/protobuf/any.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.AnyReflection.Descriptor">
            <summary>File descriptor for google/protobuf/any.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Any">
             <summary>
             `Any` contains an arbitrary serialized protocol buffer message along with a
             URL that describes the type of the serialized message.
            
             Protobuf library provides support to pack/unpack Any values in the form
             of utility functions or additional generated methods of the Any type.
            
             Example 1: Pack and unpack a message in C++.
            
                 Foo foo = ...;
                 Any any;
                 any.PackFrom(foo);
                 ...
                 if (any.UnpackTo(&amp;foo)) {
                   ...
                 }
            
             Example 2: Pack and unpack a message in Java.
            
                 Foo foo = ...;
                 Any any = Any.pack(foo);
                 ...
                 if (any.is(Foo.class)) {
                   foo = any.unpack(Foo.class);
                 }
            
              Example 3: Pack and unpack a message in Python.
            
                 foo = Foo(...)
                 any = Any()
                 any.Pack(foo)
                 ...
                 if any.Is(Foo.DESCRIPTOR):
                   any.Unpack(foo)
                   ...
            
              Example 4: Pack and unpack a message in Go
            
                  foo := &amp;pb.Foo{...}
                  any, err := ptypes.MarshalAny(foo)
                  ...
                  foo := &amp;pb.Foo{}
                  if err := ptypes.UnmarshalAny(any, foo); err != nil {
                    ...
                  }
            
             The pack methods provided by protobuf library will by default use
             'type.googleapis.com/full.type.name' as the type URL and the unpack
             methods only use the fully qualified type name after the last '/'
             in the type URL, for example "foo.bar.com/x/y.z" will yield type
             name "y.z".
            
             JSON
             ====
             The JSON representation of an `Any` value uses the regular
             representation of the deserialized, embedded message, with an
             additional field `@type` which contains the type URL. Example:
            
                 package google.profile;
                 message Person {
                   string first_name = 1;
                   string last_name = 2;
                 }
            
                 {
                   "@type": "type.googleapis.com/google.profile.Person",
                   "firstName": &lt;string&gt;,
                   "lastName": &lt;string&gt;
                 }
            
             If the embedded message type is well-known and has a custom JSON
             representation, that representation will be embedded adding a field
             `value` which holds the custom JSON in addition to the `@type`
             field. Example (for message [google.protobuf.Duration][]):
            
                 {
                   "@type": "type.googleapis.com/google.protobuf.Duration",
                   "value": "1.212s"
                 }
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Any.TypeUrlFieldNumber">
            <summary>Field number for the "type_url" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Any.TypeUrl">
             <summary>
             A URL/resource name that uniquely identifies the type of the serialized
             protocol buffer message. This string must contain at least
             one "/" character. The last segment of the URL's path must represent
             the fully qualified name of the type (as in
             `path/google.protobuf.Duration`). The name should be in a canonical form
             (e.g., leading "." is not accepted).
            
             In practice, teams usually precompile into the binary all types that they
             expect it to use in the context of Any. However, for URLs which use the
             scheme `http`, `https`, or no scheme, one can optionally set up a type
             server that maps type URLs to message definitions as follows:
            
             * If no scheme is provided, `https` is assumed.
             * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               value in binary format, or produce an error.
             * Applications are allowed to cache lookup results based on the
               URL, or have them precompiled into a binary to avoid any
               lookup. Therefore, binary compatibility needs to be preserved
               on changes to types. (Use versioned type names to manage
               breaking changes.)
            
             Note: this functionality is not currently available in the official
             protobuf release, and it is not used for type URLs beginning with
             type.googleapis.com.
            
             Schemes other than `http`, `https` (or the empty scheme) might be
             used with implementation specific semantics.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Any.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Any.Value">
            <summary>
            Must be a valid serialized protocol buffer of the above specified type.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Any.GetTypeName(System.String)">
            <summary>
            Retrieves the type name for a type URL, matching the <see cref="P:Auki.Util.Protobuf.Reflection.DescriptorBase.FullName" />
            of the packed message type.
            </summary>
            <remarks>
            <para>
            This is always just the last part of the URL, after the final slash. No validation of
            anything before the trailing slash is performed. If the type URL does not include a slash,
            an empty string is returned rather than an exception being thrown; this won't match any types,
            and the calling code is probably in a better position to give a meaningful error.
            </para>
            <para>
            There is no handling of fragments or queries  at the moment.
            </para>
            </remarks>
            <param name="typeUrl">The URL to extract the type name from</param>
            <returns>The type name</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Any.Is(Auki.Util.Protobuf.Reflection.MessageDescriptor)">
            <summary>
            Returns a bool indictating whether this Any message is of the target message type
            </summary>
            <param name="descriptor">The descriptor of the message type</param>
            <returns><c>true</c> if the type name matches the descriptor's full name or <c>false</c> otherwise</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Any.Unpack``1">
            <summary>
            Unpacks the content of this Any message into the target message type,
            which must match the type URL within this Any message.
            </summary>
            <typeparam name="T">The type of message to unpack the content into.</typeparam>
            <returns>The unpacked message.</returns>
            <exception cref="T:Auki.Util.Protobuf.InvalidProtocolBufferException">The target message type doesn't match the type URL in this message</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Any.TryUnpack``1(``0@)">
            <summary>
            Attempts to unpack the content of this Any message into the target message type,
            if it matches the type URL within this Any message.
            </summary>
            <typeparam name="T">The type of message to attempt to unpack the content into.</typeparam>
            <returns><c>true</c> if the message was successfully unpacked; <c>false</c> if the type name didn't match</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Any.Pack(Auki.Util.Protobuf.IMessage)">
            <summary>
            Packs the specified message into an Any message using a type URL prefix of "type.googleapis.com".
            </summary>
            <param name="message">The message to pack.</param>
            <returns>An Any message with the content and type URL of <paramref name="message" />.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Any.Pack(Auki.Util.Protobuf.IMessage,System.String)">
            <summary>
            Packs the specified message into an Any message using the specified type URL prefix.
            </summary>
            <param name="message">The message to pack.</param>
            <param name="typeUrlPrefix">The prefix for the type URL.</param>
            <returns>An Any message with the content and type URL of <paramref name="message" />.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.ApiReflection">
            <summary>Holder for reflection information generated from google/protobuf/api.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.ApiReflection.Descriptor">
            <summary>File descriptor for google/protobuf/api.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Api">
             <summary>
             Api is a light-weight descriptor for an API Interface.
            
             Interfaces are also described as "protocol buffer services" in some contexts,
             such as by the "service" keyword in a .proto file, but they are different
             from API Services, which represent a concrete implementation of an interface
             as opposed to simply a description of methods and bindings. They are also
             sometimes simply referred to as "APIs" in other contexts, such as the name of
             this message itself. See https://cloud.google.com/apis/design/glossary for
             detailed terminology.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Api.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Api.Name">
            <summary>
            The fully qualified name of this interface, including package name
            followed by the interface's simple name.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Api.MethodsFieldNumber">
            <summary>Field number for the "methods" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Api.Methods">
            <summary>
            The methods of this interface, in unspecified order.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Api.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Api.Options">
            <summary>
            Any metadata attached to the interface.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Api.VersionFieldNumber">
            <summary>Field number for the "version" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Api.Version">
             <summary>
             A version string for this interface. If specified, must have the form
             `major-version.minor-version`, as in `1.10`. If the minor version is
             omitted, it defaults to zero. If the entire version field is empty, the
             major version is derived from the package name, as outlined below. If the
             field is not empty, the version in the package name will be verified to be
             consistent with what is provided here.
            
             The versioning schema uses [semantic
             versioning](http://semver.org) where the major version number
             indicates a breaking change and the minor version an additive,
             non-breaking change. Both version numbers are signals to users
             what to expect from different versions, and should be carefully
             chosen based on the product plan.
            
             The major version is also reflected in the package name of the
             interface, which must end in `v&lt;major-version&gt;`, as in
             `google.feature.v1`. For major versions 0 and 1, the suffix can
             be omitted. Zero major versions must only be used for
             experimental, non-GA interfaces.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Api.SourceContextFieldNumber">
            <summary>Field number for the "source_context" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Api.SourceContext">
            <summary>
            Source context for the protocol buffer service represented by this
            message.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Api.MixinsFieldNumber">
            <summary>Field number for the "mixins" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Api.Mixins">
            <summary>
            Included interfaces. See [Mixin][].
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Api.SyntaxFieldNumber">
            <summary>Field number for the "syntax" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Api.Syntax">
            <summary>
            The source syntax of the service.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Method">
            <summary>
            Method represents a method of an API interface.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Method.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Method.Name">
            <summary>
            The simple name of this method.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Method.RequestTypeUrlFieldNumber">
            <summary>Field number for the "request_type_url" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Method.RequestTypeUrl">
            <summary>
            A URL of the input message type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Method.RequestStreamingFieldNumber">
            <summary>Field number for the "request_streaming" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Method.RequestStreaming">
            <summary>
            If true, the request is streamed.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Method.ResponseTypeUrlFieldNumber">
            <summary>Field number for the "response_type_url" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Method.ResponseTypeUrl">
            <summary>
            The URL of the output message type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Method.ResponseStreamingFieldNumber">
            <summary>Field number for the "response_streaming" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Method.ResponseStreaming">
            <summary>
            If true, the response is streamed.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Method.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Method.Options">
            <summary>
            Any metadata attached to the method.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Method.SyntaxFieldNumber">
            <summary>Field number for the "syntax" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Method.Syntax">
            <summary>
            The source syntax of this method.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Mixin">
             <summary>
             Declares an API Interface to be included in this interface. The including
             interface must redeclare all the methods from the included interface, but
             documentation and options are inherited as follows:
            
             - If after comment and whitespace stripping, the documentation
               string of the redeclared method is empty, it will be inherited
               from the original method.
            
             - Each annotation belonging to the service config (http,
               visibility) which is not set in the redeclared method will be
               inherited.
            
             - If an http annotation is inherited, the path pattern will be
               modified as follows. Any version prefix will be replaced by the
               version of the including interface plus the [root][] path if
               specified.
            
             Example of a simple mixin:
            
                 package google.acl.v1;
                 service AccessControl {
                   // Get the underlying ACL object.
                   rpc GetAcl(GetAclRequest) returns (Acl) {
                     option (google.api.http).get = "/v1/{resource=**}:getAcl";
                   }
                 }
            
                 package google.storage.v2;
                 service Storage {
                   rpc GetAcl(GetAclRequest) returns (Acl);
            
                   // Get a data record.
                   rpc GetData(GetDataRequest) returns (Data) {
                     option (google.api.http).get = "/v2/{resource=**}";
                   }
                 }
            
             Example of a mixin configuration:
            
                 apis:
                 - name: google.storage.v2.Storage
                   mixins:
                   - name: google.acl.v1.AccessControl
            
             The mixin construct implies that all methods in `AccessControl` are
             also declared with same name and request/response types in
             `Storage`. A documentation generator or annotation processor will
             see the effective `Storage.GetAcl` method after inherting
             documentation and annotations as follows:
            
                 service Storage {
                   // Get the underlying ACL object.
                   rpc GetAcl(GetAclRequest) returns (Acl) {
                     option (google.api.http).get = "/v2/{resource=**}:getAcl";
                   }
                   ...
                 }
            
             Note how the version in the path pattern changed from `v1` to `v2`.
            
             If the `root` field in the mixin is specified, it should be a
             relative path under which inherited HTTP paths are placed. Example:
            
                 apis:
                 - name: google.storage.v2.Storage
                   mixins:
                   - name: google.acl.v1.AccessControl
                     root: acls
            
             This implies the following inherited HTTP annotation:
            
                 service Storage {
                   // Get the underlying ACL object.
                   rpc GetAcl(GetAclRequest) returns (Acl) {
                     option (google.api.http).get = "/v2/acls/{resource=**}:getAcl";
                   }
                   ...
                 }
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Mixin.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Mixin.Name">
            <summary>
            The fully qualified name of the interface which is included.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Mixin.RootFieldNumber">
            <summary>Field number for the "root" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Mixin.Root">
            <summary>
            If non-empty specifies a path under which inherited HTTP paths
            are rooted.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.DurationReflection">
            <summary>Holder for reflection information generated from google/protobuf/duration.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.DurationReflection.Descriptor">
            <summary>File descriptor for google/protobuf/duration.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Duration">
             <summary>
             A Duration represents a signed, fixed-length span of time represented
             as a count of seconds and fractions of seconds at nanosecond
             resolution. It is independent of any calendar and concepts like "day"
             or "month". It is related to Timestamp in that the difference between
             two Timestamp values is a Duration and it can be added or subtracted
             from a Timestamp. Range is approximately +-10,000 years.
            
             # Examples
            
             Example 1: Compute Duration from two Timestamps in pseudo code.
            
                 Timestamp start = ...;
                 Timestamp end = ...;
                 Duration duration = ...;
            
                 duration.seconds = end.seconds - start.seconds;
                 duration.nanos = end.nanos - start.nanos;
            
                 if (duration.seconds &lt; 0 &amp;&amp; duration.nanos &gt; 0) {
                   duration.seconds += 1;
                   duration.nanos -= 1000000000;
                 } else if (duration.seconds &gt; 0 &amp;&amp; duration.nanos &lt; 0) {
                   duration.seconds -= 1;
                   duration.nanos += 1000000000;
                 }
            
             Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
            
                 Timestamp start = ...;
                 Duration duration = ...;
                 Timestamp end = ...;
            
                 end.seconds = start.seconds + duration.seconds;
                 end.nanos = start.nanos + duration.nanos;
            
                 if (end.nanos &lt; 0) {
                   end.seconds -= 1;
                   end.nanos += 1000000000;
                 } else if (end.nanos &gt;= 1000000000) {
                   end.seconds += 1;
                   end.nanos -= 1000000000;
                 }
            
             Example 3: Compute Duration from datetime.timedelta in Python.
            
                 td = datetime.timedelta(days=3, minutes=10)
                 duration = Duration()
                 duration.FromTimedelta(td)
            
             # JSON Mapping
            
             In JSON format, the Duration type is encoded as a string rather than an
             object, where the string ends in the suffix "s" (indicating seconds) and
             is preceded by the number of seconds, with nanoseconds expressed as
             fractional seconds. For example, 3 seconds with 0 nanoseconds should be
             encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
             be expressed in JSON format as "3.000000001s", and 3 seconds and 1
             microsecond should be expressed in JSON format as "3.000001s".
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Duration.SecondsFieldNumber">
            <summary>Field number for the "seconds" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Duration.Seconds">
            <summary>
            Signed seconds of the span of time. Must be from -315,576,000,000
            to +315,576,000,000 inclusive. Note: these bounds are computed from:
            60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Duration.NanosFieldNumber">
            <summary>Field number for the "nanos" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Duration.Nanos">
            <summary>
            Signed fractions of a second at nanosecond resolution of the span
            of time. Durations less than one second are represented with a 0
            `seconds` field and a positive or negative `nanos` field. For durations
            of one second or more, a non-zero value for the `nanos` field must be
            of the same sign as the `seconds` field. Must be from -999,999,999
            to +999,999,999 inclusive.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Duration.NanosecondsPerSecond">
            <summary>
            The number of nanoseconds in a second.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Duration.NanosecondsPerTick">
            <summary>
            The number of nanoseconds in a BCL tick (as used by <see cref="T:System.TimeSpan" /> and <see cref="T:System.DateTime" />).
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Duration.MaxSeconds">
            <summary>
            The maximum permitted number of seconds.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Duration.MinSeconds">
            <summary>
            The minimum permitted number of seconds.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Duration.ToTimeSpan">
            <summary>
            Converts this <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Duration" /> to a <see cref="T:System.TimeSpan" />.
            </summary>
            <remarks>If the duration is not a precise number of ticks, it is truncated towards 0.</remarks>
            <returns>The value of this duration, as a <c>TimeSpan</c>.</returns>
            <exception cref="T:System.InvalidOperationException">This value isn't a valid normalized duration, as
            described in the documentation.</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Duration.FromTimeSpan(System.TimeSpan)">
            <summary>
            Converts the given <see cref="T:System.TimeSpan" /> to a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Duration" />.
            </summary>
            <param name="timeSpan">The <c>TimeSpan</c> to convert.</param>
            <returns>The value of the given <c>TimeSpan</c>, as a <c>Duration</c>.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Duration.op_UnaryNegation(Auki.Util.Protobuf.WellKnownTypes.Duration)">
            <summary>
            Returns the result of negating the duration. For example, the negation of 5 minutes is -5 minutes.
            </summary>
            <param name="value">The duration to negate. Must not be null.</param>
            <returns>The negated value of this duration.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Duration.op_Addition(Auki.Util.Protobuf.WellKnownTypes.Duration,Auki.Util.Protobuf.WellKnownTypes.Duration)">
            <summary>
            Adds the two specified <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Duration" /> values together.
            </summary>
            <param name="lhs">The first value to add. Must not be null.</param>
            <param name="rhs">The second value to add. Must not be null.</param>
            <returns></returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Duration.op_Subtraction(Auki.Util.Protobuf.WellKnownTypes.Duration,Auki.Util.Protobuf.WellKnownTypes.Duration)">
            <summary>
            Subtracts one <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Duration" /> from another.
            </summary>
            <param name="lhs">The duration to subtract from. Must not be null.</param>
            <param name="rhs">The duration to subtract. Must not be null.</param>
            <returns>The difference between the two specified durations.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Duration.ToDiagnosticString">
            <summary>
            Returns a string representation of this <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Duration" /> for diagnostic purposes.
            </summary>
            <remarks>
            Normally the returned value will be a JSON string value (including leading and trailing quotes) but
            when the value is non-normalized or out of range, a JSON object representation will be returned
            instead, including a warning. This is to avoid exceptions being thrown when trying to
            diagnose problems - the regular JSON formatter will still throw an exception for non-normalized
            values.
            </remarks>
            <returns>A string representation of this value.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.EmptyReflection">
            <summary>Holder for reflection information generated from google/protobuf/empty.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.EmptyReflection.Descriptor">
            <summary>File descriptor for google/protobuf/empty.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Empty">
             <summary>
             A generic empty message that you can re-use to avoid defining duplicated
             empty messages in your APIs. A typical example is to use it as the request
             or the response type of an API method. For instance:
            
                 service Foo {
                   rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
                 }
            
             The JSON representation for `Empty` is empty JSON object `{}`.
             </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.FieldMaskReflection">
            <summary>Holder for reflection information generated from google/protobuf/field_mask.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.FieldMaskReflection.Descriptor">
            <summary>File descriptor for google/protobuf/field_mask.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.FieldMask">
             <summary>
             `FieldMask` represents a set of symbolic field paths, for example:
            
                 paths: "f.a"
                 paths: "f.b.d"
            
             Here `f` represents a field in some root message, `a` and `b`
             fields in the message found in `f`, and `d` a field found in the
             message in `f.b`.
            
             Field masks are used to specify a subset of fields that should be
             returned by a get operation or modified by an update operation.
             Field masks also have a custom JSON encoding (see below).
            
             # Field Masks in Projections
            
             When used in the context of a projection, a response message or
             sub-message is filtered by the API to only contain those fields as
             specified in the mask. For example, if the mask in the previous
             example is applied to a response message as follows:
            
                 f {
                   a : 22
                   b {
                     d : 1
                     x : 2
                   }
                   y : 13
                 }
                 z: 8
            
             The result will not contain specific values for fields x,y and z
             (their value will be set to the default, and omitted in proto text
             output):
            
                 f {
                   a : 22
                   b {
                     d : 1
                   }
                 }
            
             A repeated field is not allowed except at the last position of a
             paths string.
            
             If a FieldMask object is not present in a get operation, the
             operation applies to all fields (as if a FieldMask of all fields
             had been specified).
            
             Note that a field mask does not necessarily apply to the
             top-level response message. In case of a REST get operation, the
             field mask applies directly to the response, but in case of a REST
             list operation, the mask instead applies to each individual message
             in the returned resource list. In case of a REST custom method,
             other definitions may be used. Where the mask applies will be
             clearly documented together with its declaration in the API.  In
             any case, the effect on the returned resource/resources is required
             behavior for APIs.
            
             # Field Masks in Update Operations
            
             A field mask in update operations specifies which fields of the
             targeted resource are going to be updated. The API is required
             to only change the values of the fields as specified in the mask
             and leave the others untouched. If a resource is passed in to
             describe the updated values, the API ignores the values of all
             fields not covered by the mask.
            
             If a repeated field is specified for an update operation, new values will
             be appended to the existing repeated field in the target resource. Note that
             a repeated field is only allowed in the last position of a `paths` string.
            
             If a sub-message is specified in the last position of the field mask for an
             update operation, then new value will be merged into the existing sub-message
             in the target resource.
            
             For example, given the target message:
            
                 f {
                   b {
                     d: 1
                     x: 2
                   }
                   c: [1]
                 }
            
             And an update message:
            
                 f {
                   b {
                     d: 10
                   }
                   c: [2]
                 }
            
             then if the field mask is:
            
              paths: ["f.b", "f.c"]
            
             then the result will be:
            
                 f {
                   b {
                     d: 10
                     x: 2
                   }
                   c: [1, 2]
                 }
            
             An implementation may provide options to override this default behavior for
             repeated and message fields.
            
             In order to reset a field's value to the default, the field must
             be in the mask and set to the default value in the provided resource.
             Hence, in order to reset all fields of a resource, provide a default
             instance of the resource and set all fields in the mask, or do
             not provide a mask as described below.
            
             If a field mask is not present on update, the operation applies to
             all fields (as if a field mask of all fields has been specified).
             Note that in the presence of schema evolution, this may mean that
             fields the client does not know and has therefore not filled into
             the request will be reset to their default. If this is unwanted
             behavior, a specific service may require a client to always specify
             a field mask, producing an error if not.
            
             As with get operations, the location of the resource which
             describes the updated values in the request message depends on the
             operation kind. In any case, the effect of the field mask is
             required to be honored by the API.
            
             ## Considerations for HTTP REST
            
             The HTTP kind of an update operation which uses a field mask must
             be set to PATCH instead of PUT in order to satisfy HTTP semantics
             (PUT must only be used for full updates).
            
             # JSON Encoding of Field Masks
            
             In JSON, a field mask is encoded as a single string where paths are
             separated by a comma. Fields name in each path are converted
             to/from lower-camel naming conventions.
            
             As an example, consider the following message declarations:
            
                 message Profile {
                   User user = 1;
                   Photo photo = 2;
                 }
                 message User {
                   string display_name = 1;
                   string address = 2;
                 }
            
             In proto a field mask for `Profile` may look as such:
            
                 mask {
                   paths: "user.display_name"
                   paths: "photo"
                 }
            
             In JSON, the same mask is represented as below:
            
                 {
                   mask: "user.displayName,photo"
                 }
            
             # Field Masks and Oneof Fields
            
             Field masks treat fields in oneofs just as regular fields. Consider the
             following message:
            
                 message SampleMessage {
                   oneof test_oneof {
                     string name = 4;
                     SubMessage sub_message = 9;
                   }
                 }
            
             The field mask can be:
            
                 mask {
                   paths: "name"
                 }
            
             Or:
            
                 mask {
                   paths: "sub_message"
                 }
            
             Note that oneof type names ("test_oneof" in this case) cannot be used in
             paths.
            
             ## Field Mask Verification
            
             The implementation of any API method which has a FieldMask type field in the
             request should verify the included field paths, and return an
             `INVALID_ARGUMENT` error if any path is unmappable.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.FieldMask.PathsFieldNumber">
            <summary>Field number for the "paths" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.FieldMask.Paths">
            <summary>
            The set of field mask paths.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.ToDiagnosticString">
            <summary>
            Returns a string representation of this <see cref="T:Auki.Util.Protobuf.WellKnownTypes.FieldMask" /> for diagnostic purposes.
            </summary>
            <remarks>
            Normally the returned value will be a JSON string value (including leading and trailing quotes) but
            when the value is non-normalized or out of range, a JSON object representation will be returned
            instead, including a warning. This is to avoid exceptions being thrown when trying to
            diagnose problems - the regular JSON formatter will still throw an exception for non-normalized
            values.
            </remarks>
            <returns>A string representation of this value.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.FromString(System.String)">
            <summary>
            Parses from a string to a FieldMask.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.FromString``1(System.String)">
            <summary>
            Parses from a string to a FieldMask and validates all field paths.
            </summary>
            <typeparam name="T">The type to validate the field paths against.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.FromStringEnumerable``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs a FieldMask for a list of field paths in a certain type.
            </summary>
            <typeparam name="T">The type to validate the field paths against.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.FromFieldNumbers``1(System.Int32[])">
            <summary>
            Constructs a FieldMask from the passed field numbers.
            </summary>
            <typeparam name="T">The type to validate the field paths against.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.FromFieldNumbers``1(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Constructs a FieldMask from the passed field numbers.
            </summary>
            <typeparam name="T">The type to validate the field paths against.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.IsValid``1(Auki.Util.Protobuf.WellKnownTypes.FieldMask)">
            <summary>
            Checks whether paths in a given fields mask are valid.
            </summary>
            <typeparam name="T">The type to validate the field paths against.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.IsValid(Auki.Util.Protobuf.Reflection.MessageDescriptor,Auki.Util.Protobuf.WellKnownTypes.FieldMask)">
            <summary>
            Checks whether paths in a given fields mask are valid.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.IsValid``1(System.String)">
            <summary>
            Checks whether a given field path is valid.
            </summary>
            <typeparam name="T">The type to validate the field paths against.</typeparam>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.IsValid(Auki.Util.Protobuf.Reflection.MessageDescriptor,System.String)">
            <summary>
            Checks whether paths in a given fields mask are valid.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.Normalize">
            <summary>
            Converts this FieldMask to its canonical form. In the canonical form of a
            FieldMask, all field paths are sorted alphabetically and redundant field
            paths are removed.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.Union(Auki.Util.Protobuf.WellKnownTypes.FieldMask[])">
            <summary>
            Creates a union of two or more FieldMasks.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.Intersection(Auki.Util.Protobuf.WellKnownTypes.FieldMask)">
            <summary>
            Calculates the intersection of two FieldMasks.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.Merge(Auki.Util.Protobuf.IMessage,Auki.Util.Protobuf.IMessage,Auki.Util.Protobuf.WellKnownTypes.FieldMask.MergeOptions)">
            <summary>
            Merges fields specified by this FieldMask from one message to another with the
            specified merge options.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.FieldMask.Merge(Auki.Util.Protobuf.IMessage,Auki.Util.Protobuf.IMessage)">
            <summary>
            Merges fields specified by this FieldMask from one message to another.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.FieldMask.MergeOptions">
            <summary>
            Options to customize merging behavior.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.FieldMask.MergeOptions.ReplaceMessageFields">
            <summary>
            Whether to replace message fields(i.e., discard existing content in
            destination message fields) when merging.
            Default behavior is to merge the source message field into the
            destination message field.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.FieldMask.MergeOptions.ReplaceRepeatedFields">
            <summary>
            Whether to replace repeated fields (i.e., discard existing content in
            destination repeated fields) when merging.
            Default behavior is to append elements from source repeated field to the
            destination repeated field.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.FieldMask.MergeOptions.ReplacePrimitiveFields">
             <summary>
             Whether to replace primitive (non-repeated and non-message) fields in
             destination message fields with the source primitive fields (i.e., if the
             field is set in the source, the value is copied to the
             destination; if the field is unset in the source, the field is cleared
             from the destination) when merging.
            
             Default behavior is to always set the value of the source primitive
             field to the destination primitive field, and if the source field is
             unset, the default value of the source field is copied to the
             destination.
             </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.SourceContextReflection">
            <summary>Holder for reflection information generated from google/protobuf/source_context.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.SourceContextReflection.Descriptor">
            <summary>File descriptor for google/protobuf/source_context.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.SourceContext">
            <summary>
            `SourceContext` represents information about the source of a
            protobuf element, like the file in which it is defined.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.SourceContext.FileNameFieldNumber">
            <summary>Field number for the "file_name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.SourceContext.FileName">
            <summary>
            The path-qualified name of the .proto file that contained the associated
            protobuf element.  For example: `"google/protobuf/source_context.proto"`.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.StructReflection">
            <summary>Holder for reflection information generated from google/protobuf/struct.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.StructReflection.Descriptor">
            <summary>File descriptor for google/protobuf/struct.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.NullValue">
             <summary>
             `NullValue` is a singleton enumeration to represent the null value for the
             `Value` type union.
            
              The JSON representation for `NullValue` is JSON `null`.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.NullValue.NullValue">
            <summary>
            Null value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Struct">
             <summary>
             `Struct` represents a structured data value, consisting of fields
             which map to dynamically typed values. In some languages, `Struct`
             might be supported by a native representation. For example, in
             scripting languages like JS a struct is represented as an
             object. The details of that representation are described together
             with the proto support for the language.
            
             The JSON representation for `Struct` is JSON object.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Struct.FieldsFieldNumber">
            <summary>Field number for the "fields" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Struct.Fields">
            <summary>
            Unordered map of dynamically typed values.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Value">
             <summary>
             `Value` represents a dynamically typed value which can be either
             null, a number, a string, a boolean, a recursive struct value, or a
             list of values. A producer of value is expected to set one of that
             variants, absence of any variant indicates an error.
            
             The JSON representation for `Value` is JSON value.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Value.NullValueFieldNumber">
            <summary>Field number for the "null_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Value.NullValue">
            <summary>
            Represents a null value.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Value.NumberValueFieldNumber">
            <summary>Field number for the "number_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Value.NumberValue">
            <summary>
            Represents a double value.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Value.StringValueFieldNumber">
            <summary>Field number for the "string_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Value.StringValue">
            <summary>
            Represents a string value.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Value.BoolValueFieldNumber">
            <summary>Field number for the "bool_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Value.BoolValue">
            <summary>
            Represents a boolean value.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Value.StructValueFieldNumber">
            <summary>Field number for the "struct_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Value.StructValue">
            <summary>
            Represents a structured value.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Value.ListValueFieldNumber">
            <summary>Field number for the "list_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Value.ListValue">
            <summary>
            Represents a repeated `Value`.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Value.KindOneofCase">
            <summary>Enum of possible cases for the "kind" oneof.</summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Value.ForString(System.String)">
            <summary>
            Convenience method to create a Value message with a string value.
            </summary>
            <param name="value">Value to set for the StringValue property.</param>
            <returns>A newly-created Value message with the given value.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Value.ForNumber(System.Double)">
            <summary>
            Convenience method to create a Value message with a number value.
            </summary>
            <param name="value">Value to set for the NumberValue property.</param>
            <returns>A newly-created Value message with the given value.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Value.ForBool(System.Boolean)">
            <summary>
            Convenience method to create a Value message with a Boolean value.
            </summary>
            <param name="value">Value to set for the BoolValue property.</param>
            <returns>A newly-created Value message with the given value.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Value.ForNull">
            <summary>
            Convenience method to create a Value message with a null initial value.
            </summary>
            <returns>A newly-created Value message a null initial value.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Value.ForList(Auki.Util.Protobuf.WellKnownTypes.Value[])">
            <summary>
            Convenience method to create a Value message with an initial list of values.
            </summary>
            <remarks>The values provided are not cloned; the references are copied directly.</remarks>
            <returns>A newly-created Value message an initial list value.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Value.ForStruct(Auki.Util.Protobuf.WellKnownTypes.Struct)">
            <summary>
            Convenience method to create a Value message with an initial struct value
            </summary>
            <remarks>The value provided is not cloned; the reference is copied directly.</remarks>
            <returns>A newly-created Value message an initial struct value.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.ListValue">
             <summary>
             `ListValue` is a wrapper around a repeated field of values.
            
             The JSON representation for `ListValue` is JSON array.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.ListValue.ValuesFieldNumber">
            <summary>Field number for the "values" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.ListValue.Values">
            <summary>
            Repeated field of dynamically typed values.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.TimeExtensions">
            <summary>
            Extension methods on BCL time-related types, converting to protobuf types.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.TimeExtensions.ToTimestamp(System.DateTime)">
            <summary>
            Converts the given <see cref="T:System.DateTime" /> to a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Timestamp" />.
            </summary>
            <param name="dateTime">The date and time to convert to a timestamp.</param>
            <exception cref="T:System.ArgumentException">The <paramref name="dateTime" /> value has a <see cref="P:System.DateTime.Kind" />other than <c>Utc</c>.</exception>
            <returns>The converted timestamp.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.TimeExtensions.ToTimestamp(System.DateTimeOffset)">
            <summary>
            Converts the given <see cref="T:System.DateTimeOffset" /> to a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Timestamp" />
            </summary>
            <remarks>The offset is taken into consideration when converting the value (so the same instant in time
            is represented) but is not a separate part of the resulting value. In other words, there is no
            roundtrip operation to retrieve the original <c>DateTimeOffset</c>.</remarks>
            <param name="dateTimeOffset">The date and time (with UTC offset) to convert to a timestamp.</param>
            <returns>The converted timestamp.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.TimeExtensions.ToDuration(System.TimeSpan)">
            <summary>
            Converts the given <see cref="T:System.TimeSpan" /> to a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Duration" />.
            </summary>
            <param name="timeSpan">The time span to convert.</param>
            <returns>The converted duration.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.TimestampReflection">
            <summary>Holder for reflection information generated from google/protobuf/timestamp.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.TimestampReflection.Descriptor">
            <summary>File descriptor for google/protobuf/timestamp.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Timestamp">
             <summary>
             A Timestamp represents a point in time independent of any time zone or local
             calendar, encoded as a count of seconds and fractions of seconds at
             nanosecond resolution. The count is relative to an epoch at UTC midnight on
             January 1, 1970, in the proleptic Gregorian calendar which extends the
             Gregorian calendar backwards to year one.
            
             All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
             second table is needed for interpretation, using a [24-hour linear
             smear](https://developers.google.com/time/smear).
            
             The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
             restricting to that range, we ensure that we can convert to and from [RFC
             3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
            
             # Examples
            
             Example 1: Compute Timestamp from POSIX `time()`.
            
                 Timestamp timestamp;
                 timestamp.set_seconds(time(NULL));
                 timestamp.set_nanos(0);
            
             Example 2: Compute Timestamp from POSIX `gettimeofday()`.
            
                 struct timeval tv;
                 gettimeofday(&amp;tv, NULL);
            
                 Timestamp timestamp;
                 timestamp.set_seconds(tv.tv_sec);
                 timestamp.set_nanos(tv.tv_usec * 1000);
            
             Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
            
                 FILETIME ft;
                 GetSystemTimeAsFileTime(&amp;ft);
                 UINT64 ticks = (((UINT64)ft.dwHighDateTime) &lt;&lt; 32) | ft.dwLowDateTime;
            
                 // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
                 // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
                 Timestamp timestamp;
                 timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
                 timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
            
             Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
            
                 long millis = System.currentTimeMillis();
            
                 Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
                     .setNanos((int) ((millis % 1000) * 1000000)).build();
            
             Example 5: Compute Timestamp from current time in Python.
            
                 timestamp = Timestamp()
                 timestamp.GetCurrentTime()
            
             # JSON Mapping
            
             In JSON format, the Timestamp type is encoded as a string in the
             [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
             format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
             where {year} is always expressed using four digits while {month}, {day},
             {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
             seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
             are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
             is required. A proto3 JSON serializer should always use UTC (as indicated by
             "Z") when printing the Timestamp type and a proto3 JSON parser should be
             able to accept both UTC and other timezones (as indicated by an offset).
            
             For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
             01:30 UTC on January 15, 2017.
            
             In JavaScript, one can convert a Date object to this format using the
             standard
             [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
             method. In Python, a standard `datetime.datetime` object can be converted
             to this format using
             [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
             the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
             the Joda Time's [`ISODateTimeFormat.dateTime()`](
             http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
             ) to obtain a formatter capable of generating timestamps in this format.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Timestamp.SecondsFieldNumber">
            <summary>Field number for the "seconds" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Timestamp.Seconds">
            <summary>
            Represents seconds of UTC time since Unix epoch
            1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
            9999-12-31T23:59:59Z inclusive.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Timestamp.NanosFieldNumber">
            <summary>Field number for the "nanos" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Timestamp.Nanos">
            <summary>
            Non-negative fractions of a second at nanosecond resolution. Negative
            second values with fractions must still have non-negative nanos values
            that count forward in time. Must be from 0 to 999,999,999
            inclusive.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.op_Subtraction(Auki.Util.Protobuf.WellKnownTypes.Timestamp,Auki.Util.Protobuf.WellKnownTypes.Timestamp)">
            <summary>
            Returns the difference between one <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Timestamp" /> and another, as a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Duration" />.
            </summary>
            <param name="lhs">The timestamp to subtract from. Must not be null.</param>
            <param name="rhs">The timestamp to subtract. Must not be null.</param>
            <returns>The difference between the two specified timestamps.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.op_Addition(Auki.Util.Protobuf.WellKnownTypes.Timestamp,Auki.Util.Protobuf.WellKnownTypes.Duration)">
            <summary>
            Adds a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Duration" /> to a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Timestamp" />, to obtain another <c>Timestamp</c>.
            </summary>
            <param name="lhs">The timestamp to add the duration to. Must not be null.</param>
            <param name="rhs">The duration to add. Must not be null.</param>
            <returns>The result of adding the duration to the timestamp.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.op_Subtraction(Auki.Util.Protobuf.WellKnownTypes.Timestamp,Auki.Util.Protobuf.WellKnownTypes.Duration)">
            <summary>
            Subtracts a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Duration" /> from a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Timestamp" />, to obtain another <c>Timestamp</c>.
            </summary>
            <param name="lhs">The timestamp to subtract the duration from. Must not be null.</param>
            <param name="rhs">The duration to subtract.</param>
            <returns>The result of subtracting the duration from the timestamp.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.ToDateTime">
            <summary>
            Converts this timestamp into a <see cref="T:System.DateTime" />.
            </summary>
            <remarks>
            The resulting <c>DateTime</c> will always have a <c>Kind</c> of <c>Utc</c>.
            If the timestamp is not a precise number of ticks, it will be truncated towards the start
            of time. For example, a timestamp with a <see cref="P:Auki.Util.Protobuf.WellKnownTypes.Timestamp.Nanos" /> value of 99 will result in a
            <see cref="T:System.DateTime" /> value precisely on a second.
            </remarks>
            <returns>This timestamp as a <c>DateTime</c>.</returns>
            <exception cref="T:System.InvalidOperationException">The timestamp contains invalid values; either it is
            incorrectly normalized or is outside the valid range.</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.ToDateTimeOffset">
            <summary>
            Converts this timestamp into a <see cref="T:System.DateTimeOffset" />.
            </summary>
            <remarks>
            The resulting <c>DateTimeOffset</c> will always have an <c>Offset</c> of zero.
            If the timestamp is not a precise number of ticks, it will be truncated towards the start
            of time. For example, a timestamp with a <see cref="P:Auki.Util.Protobuf.WellKnownTypes.Timestamp.Nanos" /> value of 99 will result in a
            <see cref="T:System.DateTimeOffset" /> value precisely on a second.
            </remarks>
            <returns>This timestamp as a <c>DateTimeOffset</c>.</returns>
            <exception cref="T:System.InvalidOperationException">The timestamp contains invalid values; either it is
            incorrectly normalized or is outside the valid range.</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.FromDateTime(System.DateTime)">
            <summary>
            Converts the specified <see cref="T:System.DateTime" /> to a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Timestamp" />.
            </summary>
            <param name="dateTime"></param>
            <exception cref="T:System.ArgumentException">The <c>Kind</c> of <paramref name="dateTime" /> is not <c>DateTimeKind.Utc</c>.</exception>
            <returns>The converted timestamp.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.FromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            Converts the given <see cref="T:System.DateTimeOffset" /> to a <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Timestamp" />
            </summary>
            <remarks>The offset is taken into consideration when converting the value (so the same instant in time
            is represented) but is not a separate part of the resulting value. In other words, there is no
            roundtrip operation to retrieve the original <c>DateTimeOffset</c>.</remarks>
            <param name="dateTimeOffset">The date and time (with UTC offset) to convert to a timestamp.</param>
            <returns>The converted timestamp.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.CompareTo(Auki.Util.Protobuf.WellKnownTypes.Timestamp)">
            <summary>
            Given another timestamp, returns 0 if the timestamps are equivalent, -1 if this timestamp precedes the other, and 1 otherwise
            </summary>
            <remarks>
            Make sure the timestamps are normalized. Comparing non-normalized timestamps is not specified and may give unexpected results.
            </remarks>
            <param name="other">Timestamp to compare</param>
            <returns>an integer indicating whether this timestamp precedes or follows the other</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.op_LessThan(Auki.Util.Protobuf.WellKnownTypes.Timestamp,Auki.Util.Protobuf.WellKnownTypes.Timestamp)">
            <summary>
            Compares two timestamps and returns whether the first is less than (chronologically precedes) the second
            </summary>
            <remarks>
            Make sure the timestamps are normalized. Comparing non-normalized timestamps is not specified and may give unexpected results.
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <returns>true if a precedes b</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.op_GreaterThan(Auki.Util.Protobuf.WellKnownTypes.Timestamp,Auki.Util.Protobuf.WellKnownTypes.Timestamp)">
            <summary>
            Compares two timestamps and returns whether the first is greater than (chronologically follows) the second
            </summary>
            <remarks>
            Make sure the timestamps are normalized. Comparing non-normalized timestamps is not specified and may give unexpected results.
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <returns>true if a follows b</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.op_LessThanOrEqual(Auki.Util.Protobuf.WellKnownTypes.Timestamp,Auki.Util.Protobuf.WellKnownTypes.Timestamp)">
            <summary>
            Compares two timestamps and returns whether the first is less than (chronologically precedes) the second
            </summary>
            <remarks>
            Make sure the timestamps are normalized. Comparing non-normalized timestamps is not specified and may give unexpected results.
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <returns>true if a precedes b</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.op_GreaterThanOrEqual(Auki.Util.Protobuf.WellKnownTypes.Timestamp,Auki.Util.Protobuf.WellKnownTypes.Timestamp)">
            <summary>
            Compares two timestamps and returns whether the first is greater than (chronologically follows) the second
            </summary>
            <remarks>
            Make sure the timestamps are normalized. Comparing non-normalized timestamps is not specified and may give unexpected results.
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <returns>true if a follows b</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.op_Equality(Auki.Util.Protobuf.WellKnownTypes.Timestamp,Auki.Util.Protobuf.WellKnownTypes.Timestamp)">
            <summary>
            Returns whether two timestamps are equivalent
            </summary>
            <remarks>
            Make sure the timestamps are normalized. Comparing non-normalized timestamps is not specified and may give unexpected results.
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <returns>true if the two timestamps refer to the same nanosecond</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.op_Inequality(Auki.Util.Protobuf.WellKnownTypes.Timestamp,Auki.Util.Protobuf.WellKnownTypes.Timestamp)">
            <summary>
            Returns whether two timestamps differ
            </summary>
            <remarks>
            Make sure the timestamps are normalized. Comparing non-normalized timestamps is not specified and may give unexpected results.
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <returns>true if the two timestamps differ</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.WellKnownTypes.Timestamp.ToDiagnosticString">
            <summary>
            Returns a string representation of this <see cref="T:Auki.Util.Protobuf.WellKnownTypes.Timestamp" /> for diagnostic purposes.
            </summary>
            <remarks>
            Normally the returned value will be a JSON string value (including leading and trailing quotes) but
            when the value is non-normalized or out of range, a JSON object representation will be returned
            instead, including a warning. This is to avoid exceptions being thrown when trying to
            diagnose problems - the regular JSON formatter will still throw an exception for non-normalized
            values.
            </remarks>
            <returns>A string representation of this value.</returns>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.TypeReflection">
            <summary>Holder for reflection information generated from google/protobuf/type.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.TypeReflection.Descriptor">
            <summary>File descriptor for google/protobuf/type.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Syntax">
            <summary>
            The syntax in which a protocol buffer element is defined.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Syntax.Proto2">
            <summary>
            Syntax `proto2`.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Syntax.Proto3">
            <summary>
            Syntax `proto3`.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Type">
            <summary>
            A protocol buffer message type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Type.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Type.Name">
            <summary>
            The fully qualified message name.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Type.FieldsFieldNumber">
            <summary>Field number for the "fields" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Type.Fields">
            <summary>
            The list of fields.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Type.OneofsFieldNumber">
            <summary>Field number for the "oneofs" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Type.Oneofs">
            <summary>
            The list of types appearing in `oneof` definitions in this type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Type.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Type.Options">
            <summary>
            The protocol buffer options.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Type.SourceContextFieldNumber">
            <summary>Field number for the "source_context" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Type.SourceContext">
            <summary>
            The source context.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Type.SyntaxFieldNumber">
            <summary>Field number for the "syntax" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Type.Syntax">
            <summary>
            The source syntax.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Field">
            <summary>
            A single field of a message type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.KindFieldNumber">
            <summary>Field number for the "kind" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.Kind">
            <summary>
            The field type.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.CardinalityFieldNumber">
            <summary>Field number for the "cardinality" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.Cardinality">
            <summary>
            The field cardinality.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.NumberFieldNumber">
            <summary>Field number for the "number" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.Number">
            <summary>
            The field number.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.Name">
            <summary>
            The field name.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.TypeUrlFieldNumber">
            <summary>Field number for the "type_url" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.TypeUrl">
            <summary>
            The field type URL, without the scheme, for message or enumeration
            types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.OneofIndexFieldNumber">
            <summary>Field number for the "oneof_index" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.OneofIndex">
            <summary>
            The index of the field type in `Type.oneofs`, for message or enumeration
            types. The first type has index 1; zero means the type is not in the list.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.PackedFieldNumber">
            <summary>Field number for the "packed" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.Packed">
            <summary>
            Whether to use alternative packed wire representation.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.Options">
            <summary>
            The protocol buffer options.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.JsonNameFieldNumber">
            <summary>Field number for the "json_name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.JsonName">
            <summary>
            The field JSON name.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.DefaultValueFieldNumber">
            <summary>Field number for the "default_value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.DefaultValue">
            <summary>
            The string value of the default value of this field. Proto2 syntax only.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Field.Types">
            <summary>Container for nested types declared in the Field message type.</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind">
            <summary>
            Basic field types.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeUnknown">
            <summary>
            Field type unknown.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeDouble">
            <summary>
            Field type double.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeFloat">
            <summary>
            Field type float.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeInt64">
            <summary>
            Field type int64.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeUint64">
            <summary>
            Field type uint64.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeInt32">
            <summary>
            Field type int32.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeFixed64">
            <summary>
            Field type fixed64.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeFixed32">
            <summary>
            Field type fixed32.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeBool">
            <summary>
            Field type bool.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeString">
            <summary>
            Field type string.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeGroup">
            <summary>
            Field type group. Proto2 syntax only, and deprecated.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeMessage">
            <summary>
            Field type message.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeBytes">
            <summary>
            Field type bytes.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeUint32">
            <summary>
            Field type uint32.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeEnum">
            <summary>
            Field type enum.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeSfixed32">
            <summary>
            Field type sfixed32.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeSfixed64">
            <summary>
            Field type sfixed64.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeSint32">
            <summary>
            Field type sint32.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Kind.TypeSint64">
            <summary>
            Field type sint64.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Cardinality">
            <summary>
            Whether a field is optional, required, or repeated.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Cardinality.Unknown">
            <summary>
            For fields with unknown cardinality.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Cardinality.Optional">
            <summary>
            For optional fields.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Cardinality.Required">
            <summary>
            For required fields. Proto2 syntax only.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Field.Types.Cardinality.Repeated">
            <summary>
            For repeated fields.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Enum">
            <summary>
            Enum type definition.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Enum.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Enum.Name">
            <summary>
            Enum type name.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Enum.EnumvalueFieldNumber">
            <summary>Field number for the "enumvalue" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Enum.Enumvalue">
            <summary>
            Enum value definitions.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Enum.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Enum.Options">
            <summary>
            Protocol buffer options.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Enum.SourceContextFieldNumber">
            <summary>Field number for the "source_context" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Enum.SourceContext">
            <summary>
            The source context.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Enum.SyntaxFieldNumber">
            <summary>Field number for the "syntax" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Enum.Syntax">
            <summary>
            The source syntax.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.EnumValue">
            <summary>
            Enum value definition.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.EnumValue.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.EnumValue.Name">
            <summary>
            Enum value name.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.EnumValue.NumberFieldNumber">
            <summary>Field number for the "number" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.EnumValue.Number">
            <summary>
            Enum value number.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.EnumValue.OptionsFieldNumber">
            <summary>Field number for the "options" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.EnumValue.Options">
            <summary>
            Protocol buffer options.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Option">
            <summary>
            A protocol buffer option, which can be attached to a message, field,
            enumeration, etc.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Option.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Option.Name">
            <summary>
            The option's name. For protobuf built-in options (options defined in
            descriptor.proto), this is the short name. For example, `"map_entry"`.
            For custom options, it should be the fully-qualified name. For example,
            `"google.api.http"`.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Option.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Option.Value">
            <summary>
            The option's value packed in an Any message. If the value is a primitive,
            the corresponding wrapper type defined in google/protobuf/wrappers.proto
            should be used. If the value is an enum, it should be stored as an int32
            value using the google.protobuf.Int32Value type.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.WrappersReflection">
            <summary>Holder for reflection information generated from google/protobuf/wrappers.proto</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.WrappersReflection.Descriptor">
            <summary>File descriptor for google/protobuf/wrappers.proto</summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.DoubleValue">
             <summary>
             Wrapper message for `double`.
            
             The JSON representation for `DoubleValue` is JSON number.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.DoubleValue.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.DoubleValue.Value">
            <summary>
            The double value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.FloatValue">
             <summary>
             Wrapper message for `float`.
            
             The JSON representation for `FloatValue` is JSON number.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.FloatValue.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.FloatValue.Value">
            <summary>
            The float value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Int64Value">
             <summary>
             Wrapper message for `int64`.
            
             The JSON representation for `Int64Value` is JSON string.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Int64Value.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Int64Value.Value">
            <summary>
            The int64 value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.UInt64Value">
             <summary>
             Wrapper message for `uint64`.
            
             The JSON representation for `UInt64Value` is JSON string.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.UInt64Value.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.UInt64Value.Value">
            <summary>
            The uint64 value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.Int32Value">
             <summary>
             Wrapper message for `int32`.
            
             The JSON representation for `Int32Value` is JSON number.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.Int32Value.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Int32Value.Value">
            <summary>
            The int32 value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.UInt32Value">
             <summary>
             Wrapper message for `uint32`.
            
             The JSON representation for `UInt32Value` is JSON number.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.UInt32Value.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.UInt32Value.Value">
            <summary>
            The uint32 value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.BoolValue">
             <summary>
             Wrapper message for `bool`.
            
             The JSON representation for `BoolValue` is JSON `true` and `false`.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.BoolValue.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.BoolValue.Value">
            <summary>
            The bool value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.StringValue">
             <summary>
             Wrapper message for `string`.
            
             The JSON representation for `StringValue` is JSON string.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.StringValue.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.StringValue.Value">
            <summary>
            The string value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WellKnownTypes.BytesValue">
             <summary>
             Wrapper message for `bytes`.
            
             The JSON representation for `BytesValue` is JSON string.
             </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WellKnownTypes.BytesValue.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.BytesValue.Value">
            <summary>
            The bytes value.
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WireFormat">
            <summary>
            This class is used internally by the Protocol Buffer Library and generated
            message implementations. It is public only for the sake of those generated
            messages. Others should not use this class directly.
            <para>
            This class contains constants and helper functions useful for dealing with
            the Protocol Buffer wire format.
            </para>
            </summary>
        </member>
        <member name="T:Auki.Util.Protobuf.WireFormat.WireType">
            <summary>
            Wire types within protobuf encoding.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WireFormat.WireType.Varint">
            <summary>
            Variable-length integer.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WireFormat.WireType.Fixed64">
            <summary>
            A fixed-length 64-bit value.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WireFormat.WireType.LengthDelimited">
            <summary>
            A length-delimited value, i.e. a length followed by that many bytes of data.
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WireFormat.WireType.StartGroup">
            <summary>
            A "start group" value
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WireFormat.WireType.EndGroup">
            <summary>
            An "end group" value
            </summary>
        </member>
        <member name="F:Auki.Util.Protobuf.WireFormat.WireType.Fixed32">
            <summary>
            A fixed-length 32-bit value.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WireFormat.GetTagWireType(System.UInt32)">
            <summary>
            Given a tag value, determines the wire type (lower 3 bits).
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WireFormat.GetTagFieldNumber(System.UInt32)">
            <summary>
            Given a tag value, determines the field number (the upper 29 bits).
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.WireFormat.MakeTag(System.Int32,Auki.Util.Protobuf.WireFormat.WireType)">
            <summary>
            Makes a tag value given a field number and wire type.
            </summary>
        </member>
        <member name="M:Auki.Util.BitwiseNativeArrayView.System#Collections#Generic#IEnumerable{System#Boolean}#GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary><returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Auki.Util.BitwiseNativeArrayView.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary><returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.ExtensionRegistry.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary><returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Any.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Api.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Method.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Mixin.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Duration.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Empty.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.FieldMask.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.SourceContext.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Struct.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Value.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.ListValue.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Timestamp.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Type.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Field.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Enum.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.EnumValue.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Option.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.DoubleValue.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.FloatValue.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Int64Value.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.UInt64Value.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.Int32Value.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.UInt32Value.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.BoolValue.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.StringValue.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.WellKnownTypes.BytesValue.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorSet.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileDescriptorProto.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ExtensionRangeOptions.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldDescriptorProto.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofDescriptorProto.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueDescriptorProto.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ServiceDescriptorProto.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodDescriptorProto.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FileOptions.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MessageOptions.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.FieldOptions.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.OneofOptions.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumOptions.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumValueOptions.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.ServiceOptions.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.MethodOptions.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.</summary><param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add. </param><param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add. </param><exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null. </exception><exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary" /> object. </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.</summary><param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param><returns>true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.</returns><exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null. </exception>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.</summary><returns>An <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.</summary><param name="key">The key of the element to remove. </param><exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null. </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.</summary><param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing. </param><param name="index">The zero-based index in <paramref name="array" /> at which copying begins. </param><exception cref="T:System.ArgumentNullException"><paramref name="array" /> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero. </exception><exception cref="T:System.ArgumentException"><paramref name="array" /> is multidimensional.-or- The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.-or-The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#IDictionary#IsFixedSize">
            <summary>Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object has a fixed size.</summary><returns>true if the <see cref="T:System.Collections.IDictionary" /> object has a fixed size; otherwise, false.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#IDictionary#Keys">
            <summary>Gets an <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.</summary><returns>An <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#IDictionary#Values">
            <summary>Gets an <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.</summary><returns>An <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#ICollection#IsSynchronized">
            <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).</summary><returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#ICollection#SyncRoot">
            <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</summary><returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>Gets or sets the element with the specified key.</summary><param name="key">The key of the element to get or set. </param><returns>The element with the specified key, or null if the key does not exist.</returns><exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null. </exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.IDictionary" /> object is read-only.-or- The property is set, <paramref name="key" /> does not exist in the collection, and the <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TValue}#Keys">
            <summary>Gets an enumerable collection that contains the keys in the read-only dictionary. </summary><returns>An enumerable collection that contains the keys in the read-only dictionary.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.MapField`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TValue}#Values">
            <summary>Gets an enumerable collection that contains the values in the read-only dictionary.</summary><returns>An enumerable collection that contains the values in the read-only dictionary.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#IList#IsFixedSize">
            <summary>Gets a value indicating whether the <see cref="T:System.Collections.IList" /> has a fixed size.</summary><returns>true if the <see cref="T:System.Collections.IList" /> has a fixed size; otherwise, false.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.</summary><param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing. </param><param name="index">The zero-based index in <paramref name="array" /> at which copying begins. </param><exception cref="T:System.ArgumentNullException"><paramref name="array" /> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero. </exception><exception cref="T:System.ArgumentException"><paramref name="array" /> is multidimensional.-or- The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.-or-The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#ICollection#IsSynchronized">
            <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).</summary><returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#ICollection#SyncRoot">
            <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</summary><returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#IList#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary><param name="index">The zero-based index of the element to get or set. </param><returns>The element at the specified index.</returns><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />. </exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.IList" /> is read-only. </exception>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the <see cref="T:System.Collections.IList" />.</summary><param name="value">The object to add to the <see cref="T:System.Collections.IList" />. </param><returns>The position into which the new element was inserted, or -1 to indicate that the item was not inserted into the collection.</returns><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IList" /> is read-only.-or- The <see cref="T:System.Collections.IList" /> has a fixed size. </exception>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#IList#Contains(System.Object)">
            <summary>Determines whether the <see cref="T:System.Collections.IList" /> contains a specific value.</summary><param name="value">The object to locate in the <see cref="T:System.Collections.IList" />. </param><returns>true if the <see cref="T:System.Object" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, false.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</summary><param name="value">The object to locate in the <see cref="T:System.Collections.IList" />. </param><returns>The index of <paramref name="value" /> if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</summary><param name="index">The zero-based index at which <paramref name="value" /> should be inserted. </param><param name="value">The object to insert into the <see cref="T:System.Collections.IList" />. </param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />. </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IList" /> is read-only.-or- The <see cref="T:System.Collections.IList" /> has a fixed size. </exception><exception cref="T:System.NullReferenceException"><paramref name="value" /> is null reference in the <see cref="T:System.Collections.IList" />.</exception>
        </member>
        <member name="M:Auki.Util.Protobuf.Collections.RepeatedField`1.System#Collections#IList#Remove(System.Object)">
            <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</summary><param name="value">The object to remove from the <see cref="T:System.Collections.IList" />. </param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IList" /> is read-only.-or- The <see cref="T:System.Collections.IList" /> has a fixed size. </exception>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Participant.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Entity.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Pose.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Msg.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Request.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.Response.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ErrorResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.SyncClock.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.SessionState.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantJoinBroadcast.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ParticipantLeaveBroadcast.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityAddBroadcast.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityDeleteBroadcast.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePose.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityUpdatePoseBroadcast.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessage.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.CustomMessageBroadcast.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponent.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeAddResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetNameResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeGetIdResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentAddBroadcast.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentDeleteBroadcast.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdate.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentUpdateBroadcast.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentListResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeSubscribeResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.EntityComponentTypeUnsubscribeResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptRequest.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.ConjureKit.Hagall.Protobuf.Gen.ReceiptResponse.pb::Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.ArrayView`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>Gets the current element in the collection.</summary><returns>The current element in the collection.</returns>
        </member>
        <member name="P:Auki.Util.BitwiseArrayView.Enumerator.System#Collections#IEnumerator#Current">
            <summary>Gets the current element in the collection.</summary><returns>The current element in the collection.</returns>
        </member>
        <member name="P:Auki.Util.BitwiseNativeArrayView.Enumerator.System#Collections#IEnumerator#Current">
            <summary>Gets the current element in the collection.</summary><returns>The current element in the collection.</returns>
        </member>
        <member name="P:Auki.Util.NativeArrayView`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>Gets the current element in the collection.</summary><returns>The current element in the collection.</returns>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ExtensionRange.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.DescriptorProto.Types.ReservedRange.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.EnumDescriptorProto.Types.EnumReservedRange.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.UninterpretedOption.Types.NamePart.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.SourceCodeInfo.Types.Location.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
        <member name="P:Auki.Util.Protobuf.Reflection.GeneratedCodeInfo.Types.Annotation.Auki#Util#Protobuf#IMessage#Descriptor">
            <summary>
            Descriptor for this message. All instances are expected to return the same descriptor,
            and for generated types this will be an explicitly-implemented member, returning the
            same value as the static property declared on the type.
            </summary>
        </member>
    </members>
</doc>
